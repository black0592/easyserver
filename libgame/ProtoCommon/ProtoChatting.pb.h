// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoChatting.proto

#ifndef PROTOBUF_ProtoChatting_2eproto__INCLUDED
#define PROTOBUF_ProtoChatting_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoChatting_2eproto();
void protobuf_AssignDesc_ProtoChatting_2eproto();
void protobuf_ShutdownFile_ProtoChatting_2eproto();

class ChatSendAttachInfo;
class ChatReceiveAttachInfo;
class RequestSendChatContent;
class NotifySendChatContent;
class RequestGetChatAttachDetail;
class ResponseGetChatAttachDetail;
class RequestSetChatChannel;
class ResponseSetChatChannel;

enum ChattingOpCode {
  OP_CHATTING_SEND_CONTENT = 1,
  OP_CHATTING_GET_ATTACH_DETAIL = 2,
  OP_CHATTING_SET_CHAT_CHANNEL = 3
};
bool ChattingOpCode_IsValid(int value);
const ChattingOpCode ChattingOpCode_MIN = OP_CHATTING_SEND_CONTENT;
const ChattingOpCode ChattingOpCode_MAX = OP_CHATTING_SET_CHAT_CHANNEL;
const int ChattingOpCode_ARRAYSIZE = ChattingOpCode_MAX + 1;

enum ChatChannel {
  CHAT_CHANNEL_PRIVATE = 1,
  CHAT_CHANNEL_ROUND = 2,
  CHAT_CHANNEL_MAP = 4,
  CHAT_CHANNEL_TEAM = 8,
  CHAT_CHANNEL_GUILD = 16,
  CHAT_CHANNEL_COUNTRY = 32,
  CHAT_CHANNEL_SERVER = 64,
  CHAT_CHANNEL_SYSTEM = 128
};
bool ChatChannel_IsValid(int value);
const ChatChannel ChatChannel_MIN = CHAT_CHANNEL_PRIVATE;
const ChatChannel ChatChannel_MAX = CHAT_CHANNEL_SYSTEM;
const int ChatChannel_ARRAYSIZE = ChatChannel_MAX + 1;

enum ChatAttachType {
  CHAT_ATTACH_ITEM = 0
};
bool ChatAttachType_IsValid(int value);
const ChatAttachType ChatAttachType_MIN = CHAT_ATTACH_ITEM;
const ChatAttachType ChatAttachType_MAX = CHAT_ATTACH_ITEM;
const int ChatAttachType_ARRAYSIZE = ChatAttachType_MAX + 1;

// ===================================================================

class ChatSendAttachInfo : public ::google::protobuf::MessageLite {
 public:
  ChatSendAttachInfo();
  virtual ~ChatSendAttachInfo();

  ChatSendAttachInfo(const ChatSendAttachInfo& from);

  inline ChatSendAttachInfo& operator=(const ChatSendAttachInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatSendAttachInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatSendAttachInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatSendAttachInfo* other);

  // implements Message ----------------------------------------------

  ChatSendAttachInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatSendAttachInfo& from);
  void MergeFrom(const ChatSendAttachInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.ChatAttachType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Protocol::ChatAttachType type() const;
  inline void set_type(::Protocol::ChatAttachType value);

  // optional .ItemLoc loc = 5;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 5;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // @@protoc_insertion_point(class_scope:Protocol.ChatSendAttachInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_loc();
  inline void clear_has_loc();

  ::ItemLoc* loc_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static ChatSendAttachInfo* default_instance_;
};
// -------------------------------------------------------------------

class ChatReceiveAttachInfo : public ::google::protobuf::MessageLite {
 public:
  ChatReceiveAttachInfo();
  virtual ~ChatReceiveAttachInfo();

  ChatReceiveAttachInfo(const ChatReceiveAttachInfo& from);

  inline ChatReceiveAttachInfo& operator=(const ChatReceiveAttachInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ChatReceiveAttachInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChatReceiveAttachInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChatReceiveAttachInfo* other);

  // implements Message ----------------------------------------------

  ChatReceiveAttachInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChatReceiveAttachInfo& from);
  void MergeFrom(const ChatReceiveAttachInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.ChatAttachType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Protocol::ChatAttachType type() const;
  inline void set_type(::Protocol::ChatAttachType value);

  // optional int32 uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline ::google::protobuf::int32 uuid() const;
  inline void set_uuid(::google::protobuf::int32 value);

  // optional int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 star = 4;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 4;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ChatReceiveAttachInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_star();
  inline void clear_has_star();

  int type_;
  ::google::protobuf::int32 uuid_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 star_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static ChatReceiveAttachInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestSendChatContent : public ::google::protobuf::MessageLite {
 public:
  RequestSendChatContent();
  virtual ~RequestSendChatContent();

  RequestSendChatContent(const RequestSendChatContent& from);

  inline RequestSendChatContent& operator=(const RequestSendChatContent& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestSendChatContent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSendChatContent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSendChatContent* other);

  // implements Message ----------------------------------------------

  RequestSendChatContent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSendChatContent& from);
  void MergeFrom(const RequestSendChatContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.ChatChannel channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::Protocol::ChatChannel channel() const;
  inline void set_channel(::Protocol::ChatChannel value);

  // optional string receiver = 2;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 2;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // optional string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // repeated .Protocol.ChatSendAttachInfo send_attachs = 4;
  inline int send_attachs_size() const;
  inline void clear_send_attachs();
  static const int kSendAttachsFieldNumber = 4;
  inline const ::Protocol::ChatSendAttachInfo& send_attachs(int index) const;
  inline ::Protocol::ChatSendAttachInfo* mutable_send_attachs(int index);
  inline ::Protocol::ChatSendAttachInfo* add_send_attachs();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::ChatSendAttachInfo >&
      send_attachs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::ChatSendAttachInfo >*
      mutable_send_attachs();

  // @@protoc_insertion_point(class_scope:Protocol.RequestSendChatContent)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_content();
  inline void clear_has_content();

  ::std::string* receiver_;
  ::std::string* content_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::ChatSendAttachInfo > send_attachs_;
  int channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static RequestSendChatContent* default_instance_;
};
// -------------------------------------------------------------------

class NotifySendChatContent : public ::google::protobuf::MessageLite {
 public:
  NotifySendChatContent();
  virtual ~NotifySendChatContent();

  NotifySendChatContent(const NotifySendChatContent& from);

  inline NotifySendChatContent& operator=(const NotifySendChatContent& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifySendChatContent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifySendChatContent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifySendChatContent* other);

  // implements Message ----------------------------------------------

  NotifySendChatContent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifySendChatContent& from);
  void MergeFrom(const NotifySendChatContent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.ChatChannel channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::Protocol::ChatChannel channel() const;
  inline void set_channel(::Protocol::ChatChannel value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string sender = 3;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 3;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string receiver = 4;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 4;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // repeated .Protocol.ChatReceiveAttachInfo receive_attachs = 5;
  inline int receive_attachs_size() const;
  inline void clear_receive_attachs();
  static const int kReceiveAttachsFieldNumber = 5;
  inline const ::Protocol::ChatReceiveAttachInfo& receive_attachs(int index) const;
  inline ::Protocol::ChatReceiveAttachInfo* mutable_receive_attachs(int index);
  inline ::Protocol::ChatReceiveAttachInfo* add_receive_attachs();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::ChatReceiveAttachInfo >&
      receive_attachs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::ChatReceiveAttachInfo >*
      mutable_receive_attachs();

  // @@protoc_insertion_point(class_scope:Protocol.NotifySendChatContent)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_receiver();
  inline void clear_has_receiver();

  ::std::string* content_;
  ::std::string* sender_;
  ::std::string* receiver_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::ChatReceiveAttachInfo > receive_attachs_;
  int channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static NotifySendChatContent* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetChatAttachDetail : public ::google::protobuf::MessageLite {
 public:
  RequestGetChatAttachDetail();
  virtual ~RequestGetChatAttachDetail();

  RequestGetChatAttachDetail(const RequestGetChatAttachDetail& from);

  inline RequestGetChatAttachDetail& operator=(const RequestGetChatAttachDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetChatAttachDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetChatAttachDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetChatAttachDetail* other);

  // implements Message ----------------------------------------------

  RequestGetChatAttachDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetChatAttachDetail& from);
  void MergeFrom(const RequestGetChatAttachDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline ::google::protobuf::int32 uuid() const;
  inline void set_uuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetChatAttachDetail)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::int32 uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static RequestGetChatAttachDetail* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetChatAttachDetail : public ::google::protobuf::MessageLite {
 public:
  ResponseGetChatAttachDetail();
  virtual ~ResponseGetChatAttachDetail();

  ResponseGetChatAttachDetail(const ResponseGetChatAttachDetail& from);

  inline ResponseGetChatAttachDetail& operator=(const ResponseGetChatAttachDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetChatAttachDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetChatAttachDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetChatAttachDetail* other);

  // implements Message ----------------------------------------------

  ResponseGetChatAttachDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetChatAttachDetail& from);
  void MergeFrom(const ResponseGetChatAttachDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemData item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::ItemData& item() const;
  inline ::ItemData* mutable_item();
  inline ::ItemData* release_item();
  inline void set_allocated_item(::ItemData* item);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetChatAttachDetail)
 private:
  inline void set_has_item();
  inline void clear_has_item();

  ::ItemData* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetChatAttachDetail* default_instance_;
};
// -------------------------------------------------------------------

class RequestSetChatChannel : public ::google::protobuf::MessageLite {
 public:
  RequestSetChatChannel();
  virtual ~RequestSetChatChannel();

  RequestSetChatChannel(const RequestSetChatChannel& from);

  inline RequestSetChatChannel& operator=(const RequestSetChatChannel& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestSetChatChannel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSetChatChannel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSetChatChannel* other);

  // implements Message ----------------------------------------------

  RequestSetChatChannel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSetChatChannel& from);
  void MergeFrom(const RequestSetChatChannel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 channel = 1;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 1;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestSetChatChannel)
 private:
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static RequestSetChatChannel* default_instance_;
};
// -------------------------------------------------------------------

class ResponseSetChatChannel : public ::google::protobuf::MessageLite {
 public:
  ResponseSetChatChannel();
  virtual ~ResponseSetChatChannel();

  ResponseSetChatChannel(const ResponseSetChatChannel& from);

  inline ResponseSetChatChannel& operator=(const ResponseSetChatChannel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseSetChatChannel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseSetChatChannel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseSetChatChannel* other);

  // implements Message ----------------------------------------------

  ResponseSetChatChannel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseSetChatChannel& from);
  void MergeFrom(const ResponseSetChatChannel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseSetChatChannel)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_channel();
  inline void clear_has_channel();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 channel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoChatting_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoChatting_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoChatting_2eproto();
  friend void protobuf_ShutdownFile_ProtoChatting_2eproto();

  void InitAsDefaultInstance();
  static ResponseSetChatChannel* default_instance_;
};
// ===================================================================


// ===================================================================

// ChatSendAttachInfo

// optional .Protocol.ChatAttachType type = 1;
inline bool ChatSendAttachInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatSendAttachInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatSendAttachInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatSendAttachInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Protocol::ChatAttachType ChatSendAttachInfo::type() const {
  return static_cast< ::Protocol::ChatAttachType >(type_);
}
inline void ChatSendAttachInfo::set_type(::Protocol::ChatAttachType value) {
  assert(::Protocol::ChatAttachType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .ItemLoc loc = 5;
inline bool ChatSendAttachInfo::has_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatSendAttachInfo::set_has_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatSendAttachInfo::clear_has_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatSendAttachInfo::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& ChatSendAttachInfo::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* ChatSendAttachInfo::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* ChatSendAttachInfo::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void ChatSendAttachInfo::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// -------------------------------------------------------------------

// ChatReceiveAttachInfo

// optional .Protocol.ChatAttachType type = 1;
inline bool ChatReceiveAttachInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReceiveAttachInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReceiveAttachInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReceiveAttachInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Protocol::ChatAttachType ChatReceiveAttachInfo::type() const {
  return static_cast< ::Protocol::ChatAttachType >(type_);
}
inline void ChatReceiveAttachInfo::set_type(::Protocol::ChatAttachType value) {
  assert(::Protocol::ChatAttachType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 uuid = 2;
inline bool ChatReceiveAttachInfo::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatReceiveAttachInfo::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatReceiveAttachInfo::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatReceiveAttachInfo::clear_uuid() {
  uuid_ = 0;
  clear_has_uuid();
}
inline ::google::protobuf::int32 ChatReceiveAttachInfo::uuid() const {
  return uuid_;
}
inline void ChatReceiveAttachInfo::set_uuid(::google::protobuf::int32 value) {
  set_has_uuid();
  uuid_ = value;
}

// optional int32 id = 3;
inline bool ChatReceiveAttachInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChatReceiveAttachInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChatReceiveAttachInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChatReceiveAttachInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ChatReceiveAttachInfo::id() const {
  return id_;
}
inline void ChatReceiveAttachInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 star = 4;
inline bool ChatReceiveAttachInfo::has_star() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChatReceiveAttachInfo::set_has_star() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChatReceiveAttachInfo::clear_has_star() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChatReceiveAttachInfo::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 ChatReceiveAttachInfo::star() const {
  return star_;
}
inline void ChatReceiveAttachInfo::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// -------------------------------------------------------------------

// RequestSendChatContent

// optional .Protocol.ChatChannel channel = 1;
inline bool RequestSendChatContent::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSendChatContent::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSendChatContent::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSendChatContent::clear_channel() {
  channel_ = 1;
  clear_has_channel();
}
inline ::Protocol::ChatChannel RequestSendChatContent::channel() const {
  return static_cast< ::Protocol::ChatChannel >(channel_);
}
inline void RequestSendChatContent::set_channel(::Protocol::ChatChannel value) {
  assert(::Protocol::ChatChannel_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// optional string receiver = 2;
inline bool RequestSendChatContent::has_receiver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSendChatContent::set_has_receiver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSendChatContent::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSendChatContent::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& RequestSendChatContent::receiver() const {
  return *receiver_;
}
inline void RequestSendChatContent::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void RequestSendChatContent::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void RequestSendChatContent::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestSendChatContent::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* RequestSendChatContent::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestSendChatContent::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 3;
inline bool RequestSendChatContent::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestSendChatContent::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestSendChatContent::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestSendChatContent::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& RequestSendChatContent::content() const {
  return *content_;
}
inline void RequestSendChatContent::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RequestSendChatContent::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RequestSendChatContent::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestSendChatContent::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* RequestSendChatContent::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestSendChatContent::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Protocol.ChatSendAttachInfo send_attachs = 4;
inline int RequestSendChatContent::send_attachs_size() const {
  return send_attachs_.size();
}
inline void RequestSendChatContent::clear_send_attachs() {
  send_attachs_.Clear();
}
inline const ::Protocol::ChatSendAttachInfo& RequestSendChatContent::send_attachs(int index) const {
  return send_attachs_.Get(index);
}
inline ::Protocol::ChatSendAttachInfo* RequestSendChatContent::mutable_send_attachs(int index) {
  return send_attachs_.Mutable(index);
}
inline ::Protocol::ChatSendAttachInfo* RequestSendChatContent::add_send_attachs() {
  return send_attachs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::ChatSendAttachInfo >&
RequestSendChatContent::send_attachs() const {
  return send_attachs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::ChatSendAttachInfo >*
RequestSendChatContent::mutable_send_attachs() {
  return &send_attachs_;
}

// -------------------------------------------------------------------

// NotifySendChatContent

// optional .Protocol.ChatChannel channel = 1;
inline bool NotifySendChatContent::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifySendChatContent::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifySendChatContent::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifySendChatContent::clear_channel() {
  channel_ = 1;
  clear_has_channel();
}
inline ::Protocol::ChatChannel NotifySendChatContent::channel() const {
  return static_cast< ::Protocol::ChatChannel >(channel_);
}
inline void NotifySendChatContent::set_channel(::Protocol::ChatChannel value) {
  assert(::Protocol::ChatChannel_IsValid(value));
  set_has_channel();
  channel_ = value;
}

// optional string content = 2;
inline bool NotifySendChatContent::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifySendChatContent::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifySendChatContent::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifySendChatContent::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& NotifySendChatContent::content() const {
  return *content_;
}
inline void NotifySendChatContent::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void NotifySendChatContent::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void NotifySendChatContent::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifySendChatContent::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* NotifySendChatContent::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifySendChatContent::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sender = 3;
inline bool NotifySendChatContent::has_sender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifySendChatContent::set_has_sender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifySendChatContent::clear_has_sender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifySendChatContent::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& NotifySendChatContent::sender() const {
  return *sender_;
}
inline void NotifySendChatContent::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void NotifySendChatContent::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void NotifySendChatContent::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifySendChatContent::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* NotifySendChatContent::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifySendChatContent::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string receiver = 4;
inline bool NotifySendChatContent::has_receiver() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifySendChatContent::set_has_receiver() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifySendChatContent::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifySendChatContent::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& NotifySendChatContent::receiver() const {
  return *receiver_;
}
inline void NotifySendChatContent::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void NotifySendChatContent::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void NotifySendChatContent::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifySendChatContent::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* NotifySendChatContent::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifySendChatContent::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Protocol.ChatReceiveAttachInfo receive_attachs = 5;
inline int NotifySendChatContent::receive_attachs_size() const {
  return receive_attachs_.size();
}
inline void NotifySendChatContent::clear_receive_attachs() {
  receive_attachs_.Clear();
}
inline const ::Protocol::ChatReceiveAttachInfo& NotifySendChatContent::receive_attachs(int index) const {
  return receive_attachs_.Get(index);
}
inline ::Protocol::ChatReceiveAttachInfo* NotifySendChatContent::mutable_receive_attachs(int index) {
  return receive_attachs_.Mutable(index);
}
inline ::Protocol::ChatReceiveAttachInfo* NotifySendChatContent::add_receive_attachs() {
  return receive_attachs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::ChatReceiveAttachInfo >&
NotifySendChatContent::receive_attachs() const {
  return receive_attachs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::ChatReceiveAttachInfo >*
NotifySendChatContent::mutable_receive_attachs() {
  return &receive_attachs_;
}

// -------------------------------------------------------------------

// RequestGetChatAttachDetail

// optional int32 uuid = 1;
inline bool RequestGetChatAttachDetail::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetChatAttachDetail::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetChatAttachDetail::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetChatAttachDetail::clear_uuid() {
  uuid_ = 0;
  clear_has_uuid();
}
inline ::google::protobuf::int32 RequestGetChatAttachDetail::uuid() const {
  return uuid_;
}
inline void RequestGetChatAttachDetail::set_uuid(::google::protobuf::int32 value) {
  set_has_uuid();
  uuid_ = value;
}

// -------------------------------------------------------------------

// ResponseGetChatAttachDetail

// optional .ItemData item = 1;
inline bool ResponseGetChatAttachDetail::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetChatAttachDetail::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetChatAttachDetail::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetChatAttachDetail::clear_item() {
  if (item_ != NULL) item_->::ItemData::Clear();
  clear_has_item();
}
inline const ::ItemData& ResponseGetChatAttachDetail::item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::ItemData* ResponseGetChatAttachDetail::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ItemData;
  return item_;
}
inline ::ItemData* ResponseGetChatAttachDetail::release_item() {
  clear_has_item();
  ::ItemData* temp = item_;
  item_ = NULL;
  return temp;
}
inline void ResponseGetChatAttachDetail::set_allocated_item(::ItemData* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// RequestSetChatChannel

// optional int32 channel = 1;
inline bool RequestSetChatChannel::has_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSetChatChannel::set_has_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSetChatChannel::clear_has_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSetChatChannel::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 RequestSetChatChannel::channel() const {
  return channel_;
}
inline void RequestSetChatChannel::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}

// -------------------------------------------------------------------

// ResponseSetChatChannel

// optional int32 result = 1;
inline bool ResponseSetChatChannel::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSetChatChannel::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSetChatChannel::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSetChatChannel::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseSetChatChannel::result() const {
  return result_;
}
inline void ResponseSetChatChannel::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 channel = 2;
inline bool ResponseSetChatChannel::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseSetChatChannel::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseSetChatChannel::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseSetChatChannel::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ResponseSetChatChannel::channel() const {
  return channel_;
}
inline void ResponseSetChatChannel::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoChatting_2eproto__INCLUDED
