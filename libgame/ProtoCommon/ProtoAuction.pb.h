// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoAuction.proto

#ifndef PROTOBUF_ProtoAuction_2eproto__INCLUDED
#define PROTOBUF_ProtoAuction_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoAuction_2eproto();
void protobuf_AssignDesc_ProtoAuction_2eproto();
void protobuf_ShutdownFile_ProtoAuction_2eproto();

class AuctionMoneyInfo;
class AuctionItemInfo;
class RequestAuctionGetMoneyList;
class ResponseAuctionGetMoneyList;
class RequestAuctionSellMoney;
class ResponseAuctionSellMoney;
class RequestAuctionBuyMoney;
class ResponseAuctionBuyMoney;
class RequestAuctionBackoutMoney;
class ResponseAuctionBackoutMoney;
class RequestAuctionGetSelfMoneyList;
class ResponseAuctionGetSelfMoneyList;
class RequestAuctionGetItemList;
class ResponseAuctionGetItemList;
class RequestAuctionSellItem;
class ResponseAuctionSellItem;
class RequestAuctionGetItemDetail;
class ResponseAuctionGetItemDetail;
class RequestAuctionBuyItem;
class ResponseAuctionBuyItem;
class RequestAuctionBackoutItem;
class ResponseAuctionBackoutItem;
class RequestAuctionGetSelfItemList;
class ResponseAuctionGetSelfItemList;
class NotifyAuctionUpdateParam;

enum AuctionOpCode {
  OP_AUCTION_GET_MONEY_LIST = 1,
  OP_AUCTION_SELL_MONEY = 2,
  OP_AUCTION_BUY_MONEY = 3,
  OP_AUCTION_BACKOUT_MONEY = 4,
  OP_AUCTION_GET_SELF_MONEY_LIST = 5,
  OP_AUCTION_GET_ITEM_LIST = 10,
  OP_AUCTION_SELL_ITEM = 11,
  OP_AUCTION_BUY_ITEM = 12,
  OP_AUCTION_GET_ITEM_DETAIL = 13,
  OP_AUCTION_BACKOUT_ITEM = 14,
  OP_AUCTION_GET_SELF_ITEM_LIST = 15,
  OP_AUCTION_UPDATE_PARAM = 16
};
bool AuctionOpCode_IsValid(int value);
const AuctionOpCode AuctionOpCode_MIN = OP_AUCTION_GET_MONEY_LIST;
const AuctionOpCode AuctionOpCode_MAX = OP_AUCTION_UPDATE_PARAM;
const int AuctionOpCode_ARRAYSIZE = AuctionOpCode_MAX + 1;

enum AuctionSort {
  AUC_SORT_NONE = 0,
  AUC_SORT_ASCE = 1,
  AUC_SORT_DESC = 2
};
bool AuctionSort_IsValid(int value);
const AuctionSort AuctionSort_MIN = AUC_SORT_NONE;
const AuctionSort AuctionSort_MAX = AUC_SORT_DESC;
const int AuctionSort_ARRAYSIZE = AuctionSort_MAX + 1;

// ===================================================================

class AuctionMoneyInfo : public ::google::protobuf::MessageLite {
 public:
  AuctionMoneyInfo();
  virtual ~AuctionMoneyInfo();

  AuctionMoneyInfo(const AuctionMoneyInfo& from);

  inline AuctionMoneyInfo& operator=(const AuctionMoneyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuctionMoneyInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuctionMoneyInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuctionMoneyInfo* other);

  // implements Message ----------------------------------------------

  AuctionMoneyInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuctionMoneyInfo& from);
  void MergeFrom(const AuctionMoneyInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 1;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 1;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // optional int32 require_gold = 2;
  inline bool has_require_gold() const;
  inline void clear_require_gold();
  static const int kRequireGoldFieldNumber = 2;
  inline ::google::protobuf::int32 require_gold() const;
  inline void set_require_gold(::google::protobuf::int32 value);

  // optional int32 total_money = 3;
  inline bool has_total_money() const;
  inline void clear_total_money();
  static const int kTotalMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 total_money() const;
  inline void set_total_money(::google::protobuf::int32 value);

  // optional int32 unit_money = 4;
  inline bool has_unit_money() const;
  inline void clear_unit_money();
  static const int kUnitMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 unit_money() const;
  inline void set_unit_money(::google::protobuf::int32 value);

  // optional int32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.AuctionMoneyInfo)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();
  inline void set_has_require_gold();
  inline void clear_has_require_gold();
  inline void set_has_total_money();
  inline void clear_has_total_money();
  inline void set_has_unit_money();
  inline void clear_has_unit_money();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::int32 auction_id_;
  ::google::protobuf::int32 require_gold_;
  ::google::protobuf::int32 total_money_;
  ::google::protobuf::int32 unit_money_;
  ::google::protobuf::int32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static AuctionMoneyInfo* default_instance_;
};
// -------------------------------------------------------------------

class AuctionItemInfo : public ::google::protobuf::MessageLite {
 public:
  AuctionItemInfo();
  virtual ~AuctionItemInfo();

  AuctionItemInfo(const AuctionItemInfo& from);

  inline AuctionItemInfo& operator=(const AuctionItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AuctionItemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuctionItemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuctionItemInfo* other);

  // implements Message ----------------------------------------------

  AuctionItemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuctionItemInfo& from);
  void MergeFrom(const AuctionItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 1;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 1;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // optional int32 require_money = 2;
  inline bool has_require_money() const;
  inline void clear_require_money();
  static const int kRequireMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 require_money() const;
  inline void set_require_money(::google::protobuf::int32 value);

  // optional int32 item_id = 3;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // optional int32 item_level = 4;
  inline bool has_item_level() const;
  inline void clear_item_level();
  static const int kItemLevelFieldNumber = 4;
  inline ::google::protobuf::int32 item_level() const;
  inline void set_item_level(::google::protobuf::int32 value);

  // optional int32 item_overlay = 5;
  inline bool has_item_overlay() const;
  inline void clear_item_overlay();
  static const int kItemOverlayFieldNumber = 5;
  inline ::google::protobuf::int32 item_overlay() const;
  inline void set_item_overlay(::google::protobuf::int32 value);

  // optional int32 item_star = 6;
  inline bool has_item_star() const;
  inline void clear_item_star();
  static const int kItemStarFieldNumber = 6;
  inline ::google::protobuf::int32 item_star() const;
  inline void set_item_star(::google::protobuf::int32 value);

  // optional int32 time = 7;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 7;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.AuctionItemInfo)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();
  inline void set_has_require_money();
  inline void clear_has_require_money();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_level();
  inline void clear_has_item_level();
  inline void set_has_item_overlay();
  inline void clear_has_item_overlay();
  inline void set_has_item_star();
  inline void clear_has_item_star();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::int32 auction_id_;
  ::google::protobuf::int32 require_money_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 item_level_;
  ::google::protobuf::int32 item_overlay_;
  ::google::protobuf::int32 item_star_;
  ::google::protobuf::int32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static AuctionItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionGetMoneyList : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionGetMoneyList();
  virtual ~RequestAuctionGetMoneyList();

  RequestAuctionGetMoneyList(const RequestAuctionGetMoneyList& from);

  inline RequestAuctionGetMoneyList& operator=(const RequestAuctionGetMoneyList& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionGetMoneyList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionGetMoneyList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionGetMoneyList* other);

  // implements Message ----------------------------------------------

  RequestAuctionGetMoneyList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionGetMoneyList& from);
  void MergeFrom(const RequestAuctionGetMoneyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 page = 1 [default = 1];
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // optional .Protocol.AuctionSort sort_total_money = 2;
  inline bool has_sort_total_money() const;
  inline void clear_sort_total_money();
  static const int kSortTotalMoneyFieldNumber = 2;
  inline ::Protocol::AuctionSort sort_total_money() const;
  inline void set_sort_total_money(::Protocol::AuctionSort value);

  // optional .Protocol.AuctionSort sort_unit_money = 3;
  inline bool has_sort_unit_money() const;
  inline void clear_sort_unit_money();
  static const int kSortUnitMoneyFieldNumber = 3;
  inline ::Protocol::AuctionSort sort_unit_money() const;
  inline void set_sort_unit_money(::Protocol::AuctionSort value);

  // optional .Protocol.AuctionSort sort_require_gold = 4;
  inline bool has_sort_require_gold() const;
  inline void clear_sort_require_gold();
  static const int kSortRequireGoldFieldNumber = 4;
  inline ::Protocol::AuctionSort sort_require_gold() const;
  inline void set_sort_require_gold(::Protocol::AuctionSort value);

  // optional int32 filter_money_min = 5;
  inline bool has_filter_money_min() const;
  inline void clear_filter_money_min();
  static const int kFilterMoneyMinFieldNumber = 5;
  inline ::google::protobuf::int32 filter_money_min() const;
  inline void set_filter_money_min(::google::protobuf::int32 value);

  // optional int32 filter_money_max = 6;
  inline bool has_filter_money_max() const;
  inline void clear_filter_money_max();
  static const int kFilterMoneyMaxFieldNumber = 6;
  inline ::google::protobuf::int32 filter_money_max() const;
  inline void set_filter_money_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionGetMoneyList)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_sort_total_money();
  inline void clear_has_sort_total_money();
  inline void set_has_sort_unit_money();
  inline void clear_has_sort_unit_money();
  inline void set_has_sort_require_gold();
  inline void clear_has_sort_require_gold();
  inline void set_has_filter_money_min();
  inline void clear_has_filter_money_min();
  inline void set_has_filter_money_max();
  inline void clear_has_filter_money_max();

  ::google::protobuf::int32 page_;
  int sort_total_money_;
  int sort_unit_money_;
  int sort_require_gold_;
  ::google::protobuf::int32 filter_money_min_;
  ::google::protobuf::int32 filter_money_max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionGetMoneyList* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionGetMoneyList : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionGetMoneyList();
  virtual ~ResponseAuctionGetMoneyList();

  ResponseAuctionGetMoneyList(const ResponseAuctionGetMoneyList& from);

  inline ResponseAuctionGetMoneyList& operator=(const ResponseAuctionGetMoneyList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionGetMoneyList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionGetMoneyList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionGetMoneyList* other);

  // implements Message ----------------------------------------------

  ResponseAuctionGetMoneyList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionGetMoneyList& from);
  void MergeFrom(const ResponseAuctionGetMoneyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // optional int32 max_page = 2;
  inline bool has_max_page() const;
  inline void clear_max_page();
  static const int kMaxPageFieldNumber = 2;
  inline ::google::protobuf::int32 max_page() const;
  inline void set_max_page(::google::protobuf::int32 value);

  // repeated .Protocol.AuctionMoneyInfo auction_list = 3;
  inline int auction_list_size() const;
  inline void clear_auction_list();
  static const int kAuctionListFieldNumber = 3;
  inline const ::Protocol::AuctionMoneyInfo& auction_list(int index) const;
  inline ::Protocol::AuctionMoneyInfo* mutable_auction_list(int index);
  inline ::Protocol::AuctionMoneyInfo* add_auction_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >&
      auction_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >*
      mutable_auction_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionGetMoneyList)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_max_page();
  inline void clear_has_max_page();

  ::google::protobuf::int32 page_;
  ::google::protobuf::int32 max_page_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo > auction_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionGetMoneyList* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionSellMoney : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionSellMoney();
  virtual ~RequestAuctionSellMoney();

  RequestAuctionSellMoney(const RequestAuctionSellMoney& from);

  inline RequestAuctionSellMoney& operator=(const RequestAuctionSellMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionSellMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionSellMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionSellMoney* other);

  // implements Message ----------------------------------------------

  RequestAuctionSellMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionSellMoney& from);
  void MergeFrom(const RequestAuctionSellMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 money = 1;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 1;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional int32 require_gold = 2;
  inline bool has_require_gold() const;
  inline void clear_require_gold();
  static const int kRequireGoldFieldNumber = 2;
  inline ::google::protobuf::int32 require_gold() const;
  inline void set_require_gold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionSellMoney)
 private:
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_require_gold();
  inline void clear_has_require_gold();

  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 require_gold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionSellMoney* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionSellMoney : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionSellMoney();
  virtual ~ResponseAuctionSellMoney();

  ResponseAuctionSellMoney(const ResponseAuctionSellMoney& from);

  inline ResponseAuctionSellMoney& operator=(const ResponseAuctionSellMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionSellMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionSellMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionSellMoney* other);

  // implements Message ----------------------------------------------

  ResponseAuctionSellMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionSellMoney& from);
  void MergeFrom(const ResponseAuctionSellMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .Protocol.AuctionMoneyInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::Protocol::AuctionMoneyInfo& info() const;
  inline ::Protocol::AuctionMoneyInfo* mutable_info();
  inline ::Protocol::AuctionMoneyInfo* release_info();
  inline void set_allocated_info(::Protocol::AuctionMoneyInfo* info);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionSellMoney)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_info();
  inline void clear_has_info();

  ::Protocol::AuctionMoneyInfo* info_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionSellMoney* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionBuyMoney : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionBuyMoney();
  virtual ~RequestAuctionBuyMoney();

  RequestAuctionBuyMoney(const RequestAuctionBuyMoney& from);

  inline RequestAuctionBuyMoney& operator=(const RequestAuctionBuyMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionBuyMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionBuyMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionBuyMoney* other);

  // implements Message ----------------------------------------------

  RequestAuctionBuyMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionBuyMoney& from);
  void MergeFrom(const RequestAuctionBuyMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 1;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 1;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionBuyMoney)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();

  ::google::protobuf::int32 auction_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionBuyMoney* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionBuyMoney : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionBuyMoney();
  virtual ~ResponseAuctionBuyMoney();

  ResponseAuctionBuyMoney(const ResponseAuctionBuyMoney& from);

  inline ResponseAuctionBuyMoney& operator=(const ResponseAuctionBuyMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionBuyMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionBuyMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionBuyMoney* other);

  // implements Message ----------------------------------------------

  ResponseAuctionBuyMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionBuyMoney& from);
  void MergeFrom(const ResponseAuctionBuyMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionBuyMoney)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionBuyMoney* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionBackoutMoney : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionBackoutMoney();
  virtual ~RequestAuctionBackoutMoney();

  RequestAuctionBackoutMoney(const RequestAuctionBackoutMoney& from);

  inline RequestAuctionBackoutMoney& operator=(const RequestAuctionBackoutMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionBackoutMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionBackoutMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionBackoutMoney* other);

  // implements Message ----------------------------------------------

  RequestAuctionBackoutMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionBackoutMoney& from);
  void MergeFrom(const RequestAuctionBackoutMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 1;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 1;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionBackoutMoney)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();

  ::google::protobuf::int32 auction_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionBackoutMoney* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionBackoutMoney : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionBackoutMoney();
  virtual ~ResponseAuctionBackoutMoney();

  ResponseAuctionBackoutMoney(const ResponseAuctionBackoutMoney& from);

  inline ResponseAuctionBackoutMoney& operator=(const ResponseAuctionBackoutMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionBackoutMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionBackoutMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionBackoutMoney* other);

  // implements Message ----------------------------------------------

  ResponseAuctionBackoutMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionBackoutMoney& from);
  void MergeFrom(const ResponseAuctionBackoutMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionBackoutMoney)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionBackoutMoney* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionGetSelfMoneyList : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionGetSelfMoneyList();
  virtual ~RequestAuctionGetSelfMoneyList();

  RequestAuctionGetSelfMoneyList(const RequestAuctionGetSelfMoneyList& from);

  inline RequestAuctionGetSelfMoneyList& operator=(const RequestAuctionGetSelfMoneyList& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionGetSelfMoneyList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionGetSelfMoneyList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionGetSelfMoneyList* other);

  // implements Message ----------------------------------------------

  RequestAuctionGetSelfMoneyList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionGetSelfMoneyList& from);
  void MergeFrom(const RequestAuctionGetSelfMoneyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionGetSelfMoneyList)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionGetSelfMoneyList* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionGetSelfMoneyList : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionGetSelfMoneyList();
  virtual ~ResponseAuctionGetSelfMoneyList();

  ResponseAuctionGetSelfMoneyList(const ResponseAuctionGetSelfMoneyList& from);

  inline ResponseAuctionGetSelfMoneyList& operator=(const ResponseAuctionGetSelfMoneyList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionGetSelfMoneyList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionGetSelfMoneyList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionGetSelfMoneyList* other);

  // implements Message ----------------------------------------------

  ResponseAuctionGetSelfMoneyList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionGetSelfMoneyList& from);
  void MergeFrom(const ResponseAuctionGetSelfMoneyList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.AuctionMoneyInfo auction_list = 1;
  inline int auction_list_size() const;
  inline void clear_auction_list();
  static const int kAuctionListFieldNumber = 1;
  inline const ::Protocol::AuctionMoneyInfo& auction_list(int index) const;
  inline ::Protocol::AuctionMoneyInfo* mutable_auction_list(int index);
  inline ::Protocol::AuctionMoneyInfo* add_auction_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >&
      auction_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >*
      mutable_auction_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionGetSelfMoneyList)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo > auction_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionGetSelfMoneyList* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionGetItemList : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionGetItemList();
  virtual ~RequestAuctionGetItemList();

  RequestAuctionGetItemList(const RequestAuctionGetItemList& from);

  inline RequestAuctionGetItemList& operator=(const RequestAuctionGetItemList& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionGetItemList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionGetItemList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionGetItemList* other);

  // implements Message ----------------------------------------------

  RequestAuctionGetItemList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionGetItemList& from);
  void MergeFrom(const RequestAuctionGetItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 page = 1 [default = 1];
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // optional .Protocol.AuctionSort sort_quality = 2;
  inline bool has_sort_quality() const;
  inline void clear_sort_quality();
  static const int kSortQualityFieldNumber = 2;
  inline ::Protocol::AuctionSort sort_quality() const;
  inline void set_sort_quality(::Protocol::AuctionSort value);

  // optional .Protocol.AuctionSort sort_level = 3;
  inline bool has_sort_level() const;
  inline void clear_sort_level();
  static const int kSortLevelFieldNumber = 3;
  inline ::Protocol::AuctionSort sort_level() const;
  inline void set_sort_level(::Protocol::AuctionSort value);

  // optional .Protocol.AuctionSort sort_overlay = 4;
  inline bool has_sort_overlay() const;
  inline void clear_sort_overlay();
  static const int kSortOverlayFieldNumber = 4;
  inline ::Protocol::AuctionSort sort_overlay() const;
  inline void set_sort_overlay(::Protocol::AuctionSort value);

  // optional .Protocol.AuctionSort sort_require_money = 5;
  inline bool has_sort_require_money() const;
  inline void clear_sort_require_money();
  static const int kSortRequireMoneyFieldNumber = 5;
  inline ::Protocol::AuctionSort sort_require_money() const;
  inline void set_sort_require_money(::Protocol::AuctionSort value);

  // optional int32 filter_item_main_type = 6;
  inline bool has_filter_item_main_type() const;
  inline void clear_filter_item_main_type();
  static const int kFilterItemMainTypeFieldNumber = 6;
  inline ::google::protobuf::int32 filter_item_main_type() const;
  inline void set_filter_item_main_type(::google::protobuf::int32 value);

  // optional int32 filter_item_sub_type = 7;
  inline bool has_filter_item_sub_type() const;
  inline void clear_filter_item_sub_type();
  static const int kFilterItemSubTypeFieldNumber = 7;
  inline ::google::protobuf::int32 filter_item_sub_type() const;
  inline void set_filter_item_sub_type(::google::protobuf::int32 value);

  // optional int32 filter_item_level = 8;
  inline bool has_filter_item_level() const;
  inline void clear_filter_item_level();
  static const int kFilterItemLevelFieldNumber = 8;
  inline ::google::protobuf::int32 filter_item_level() const;
  inline void set_filter_item_level(::google::protobuf::int32 value);

  // optional string filter_item_name = 9;
  inline bool has_filter_item_name() const;
  inline void clear_filter_item_name();
  static const int kFilterItemNameFieldNumber = 9;
  inline const ::std::string& filter_item_name() const;
  inline void set_filter_item_name(const ::std::string& value);
  inline void set_filter_item_name(const char* value);
  inline void set_filter_item_name(const char* value, size_t size);
  inline ::std::string* mutable_filter_item_name();
  inline ::std::string* release_filter_item_name();
  inline void set_allocated_filter_item_name(::std::string* filter_item_name);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionGetItemList)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_sort_quality();
  inline void clear_has_sort_quality();
  inline void set_has_sort_level();
  inline void clear_has_sort_level();
  inline void set_has_sort_overlay();
  inline void clear_has_sort_overlay();
  inline void set_has_sort_require_money();
  inline void clear_has_sort_require_money();
  inline void set_has_filter_item_main_type();
  inline void clear_has_filter_item_main_type();
  inline void set_has_filter_item_sub_type();
  inline void clear_has_filter_item_sub_type();
  inline void set_has_filter_item_level();
  inline void clear_has_filter_item_level();
  inline void set_has_filter_item_name();
  inline void clear_has_filter_item_name();

  ::google::protobuf::int32 page_;
  int sort_quality_;
  int sort_level_;
  int sort_overlay_;
  int sort_require_money_;
  ::google::protobuf::int32 filter_item_main_type_;
  ::google::protobuf::int32 filter_item_sub_type_;
  ::google::protobuf::int32 filter_item_level_;
  ::std::string* filter_item_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionGetItemList* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionGetItemList : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionGetItemList();
  virtual ~ResponseAuctionGetItemList();

  ResponseAuctionGetItemList(const ResponseAuctionGetItemList& from);

  inline ResponseAuctionGetItemList& operator=(const ResponseAuctionGetItemList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionGetItemList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionGetItemList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionGetItemList* other);

  // implements Message ----------------------------------------------

  ResponseAuctionGetItemList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionGetItemList& from);
  void MergeFrom(const ResponseAuctionGetItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::int32 page() const;
  inline void set_page(::google::protobuf::int32 value);

  // optional int32 max_page = 2;
  inline bool has_max_page() const;
  inline void clear_max_page();
  static const int kMaxPageFieldNumber = 2;
  inline ::google::protobuf::int32 max_page() const;
  inline void set_max_page(::google::protobuf::int32 value);

  // repeated .Protocol.AuctionItemInfo auction_list = 3;
  inline int auction_list_size() const;
  inline void clear_auction_list();
  static const int kAuctionListFieldNumber = 3;
  inline const ::Protocol::AuctionItemInfo& auction_list(int index) const;
  inline ::Protocol::AuctionItemInfo* mutable_auction_list(int index);
  inline ::Protocol::AuctionItemInfo* add_auction_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >&
      auction_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >*
      mutable_auction_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionGetItemList)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_max_page();
  inline void clear_has_max_page();

  ::google::protobuf::int32 page_;
  ::google::protobuf::int32 max_page_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo > auction_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionGetItemList* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionSellItem : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionSellItem();
  virtual ~RequestAuctionSellItem();

  RequestAuctionSellItem(const RequestAuctionSellItem& from);

  inline RequestAuctionSellItem& operator=(const RequestAuctionSellItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionSellItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionSellItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionSellItem* other);

  // implements Message ----------------------------------------------

  RequestAuctionSellItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionSellItem& from);
  void MergeFrom(const RequestAuctionSellItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLocNum loc_num = 1;
  inline bool has_loc_num() const;
  inline void clear_loc_num();
  static const int kLocNumFieldNumber = 1;
  inline const ::ItemLocNum& loc_num() const;
  inline ::ItemLocNum* mutable_loc_num();
  inline ::ItemLocNum* release_loc_num();
  inline void set_allocated_loc_num(::ItemLocNum* loc_num);

  // optional int32 require_money = 2;
  inline bool has_require_money() const;
  inline void clear_require_money();
  static const int kRequireMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 require_money() const;
  inline void set_require_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionSellItem)
 private:
  inline void set_has_loc_num();
  inline void clear_has_loc_num();
  inline void set_has_require_money();
  inline void clear_has_require_money();

  ::ItemLocNum* loc_num_;
  ::google::protobuf::int32 require_money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionSellItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionSellItem : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionSellItem();
  virtual ~ResponseAuctionSellItem();

  ResponseAuctionSellItem(const ResponseAuctionSellItem& from);

  inline ResponseAuctionSellItem& operator=(const ResponseAuctionSellItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionSellItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionSellItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionSellItem* other);

  // implements Message ----------------------------------------------

  ResponseAuctionSellItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionSellItem& from);
  void MergeFrom(const ResponseAuctionSellItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .Protocol.AuctionItemInfo info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::Protocol::AuctionItemInfo& info() const;
  inline ::Protocol::AuctionItemInfo* mutable_info();
  inline ::Protocol::AuctionItemInfo* release_info();
  inline void set_allocated_info(::Protocol::AuctionItemInfo* info);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionSellItem)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_info();
  inline void clear_has_info();

  ::Protocol::AuctionItemInfo* info_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionSellItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionGetItemDetail : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionGetItemDetail();
  virtual ~RequestAuctionGetItemDetail();

  RequestAuctionGetItemDetail(const RequestAuctionGetItemDetail& from);

  inline RequestAuctionGetItemDetail& operator=(const RequestAuctionGetItemDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionGetItemDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionGetItemDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionGetItemDetail* other);

  // implements Message ----------------------------------------------

  RequestAuctionGetItemDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionGetItemDetail& from);
  void MergeFrom(const RequestAuctionGetItemDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 2;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 2;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionGetItemDetail)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();

  ::google::protobuf::int32 auction_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionGetItemDetail* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionGetItemDetail : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionGetItemDetail();
  virtual ~ResponseAuctionGetItemDetail();

  ResponseAuctionGetItemDetail(const ResponseAuctionGetItemDetail& from);

  inline ResponseAuctionGetItemDetail& operator=(const ResponseAuctionGetItemDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionGetItemDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionGetItemDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionGetItemDetail* other);

  // implements Message ----------------------------------------------

  ResponseAuctionGetItemDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionGetItemDetail& from);
  void MergeFrom(const ResponseAuctionGetItemDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 1;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 1;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // optional .ItemData item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::ItemData& item() const;
  inline ::ItemData* mutable_item();
  inline ::ItemData* release_item();
  inline void set_allocated_item(::ItemData* item);

  // optional string seller = 3;
  inline bool has_seller() const;
  inline void clear_seller();
  static const int kSellerFieldNumber = 3;
  inline const ::std::string& seller() const;
  inline void set_seller(const ::std::string& value);
  inline void set_seller(const char* value);
  inline void set_seller(const char* value, size_t size);
  inline ::std::string* mutable_seller();
  inline ::std::string* release_seller();
  inline void set_allocated_seller(::std::string* seller);

  // optional int32 require_money = 4;
  inline bool has_require_money() const;
  inline void clear_require_money();
  static const int kRequireMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 require_money() const;
  inline void set_require_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionGetItemDetail)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();
  inline void set_has_item();
  inline void clear_has_item();
  inline void set_has_seller();
  inline void clear_has_seller();
  inline void set_has_require_money();
  inline void clear_has_require_money();

  ::ItemData* item_;
  ::google::protobuf::int32 auction_id_;
  ::google::protobuf::int32 require_money_;
  ::std::string* seller_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionGetItemDetail* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionBuyItem : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionBuyItem();
  virtual ~RequestAuctionBuyItem();

  RequestAuctionBuyItem(const RequestAuctionBuyItem& from);

  inline RequestAuctionBuyItem& operator=(const RequestAuctionBuyItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionBuyItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionBuyItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionBuyItem* other);

  // implements Message ----------------------------------------------

  RequestAuctionBuyItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionBuyItem& from);
  void MergeFrom(const RequestAuctionBuyItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 1;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 1;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionBuyItem)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();

  ::google::protobuf::int32 auction_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionBuyItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionBuyItem : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionBuyItem();
  virtual ~ResponseAuctionBuyItem();

  ResponseAuctionBuyItem(const ResponseAuctionBuyItem& from);

  inline ResponseAuctionBuyItem& operator=(const ResponseAuctionBuyItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionBuyItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionBuyItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionBuyItem* other);

  // implements Message ----------------------------------------------

  ResponseAuctionBuyItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionBuyItem& from);
  void MergeFrom(const ResponseAuctionBuyItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionBuyItem)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionBuyItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionBackoutItem : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionBackoutItem();
  virtual ~RequestAuctionBackoutItem();

  RequestAuctionBackoutItem(const RequestAuctionBackoutItem& from);

  inline RequestAuctionBackoutItem& operator=(const RequestAuctionBackoutItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionBackoutItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionBackoutItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionBackoutItem* other);

  // implements Message ----------------------------------------------

  RequestAuctionBackoutItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionBackoutItem& from);
  void MergeFrom(const RequestAuctionBackoutItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 auction_id = 1;
  inline bool has_auction_id() const;
  inline void clear_auction_id();
  static const int kAuctionIdFieldNumber = 1;
  inline ::google::protobuf::int32 auction_id() const;
  inline void set_auction_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionBackoutItem)
 private:
  inline void set_has_auction_id();
  inline void clear_has_auction_id();

  ::google::protobuf::int32 auction_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionBackoutItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionBackoutItem : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionBackoutItem();
  virtual ~ResponseAuctionBackoutItem();

  ResponseAuctionBackoutItem(const ResponseAuctionBackoutItem& from);

  inline ResponseAuctionBackoutItem& operator=(const ResponseAuctionBackoutItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionBackoutItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionBackoutItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionBackoutItem* other);

  // implements Message ----------------------------------------------

  ResponseAuctionBackoutItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionBackoutItem& from);
  void MergeFrom(const ResponseAuctionBackoutItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionBackoutItem)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionBackoutItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestAuctionGetSelfItemList : public ::google::protobuf::MessageLite {
 public:
  RequestAuctionGetSelfItemList();
  virtual ~RequestAuctionGetSelfItemList();

  RequestAuctionGetSelfItemList(const RequestAuctionGetSelfItemList& from);

  inline RequestAuctionGetSelfItemList& operator=(const RequestAuctionGetSelfItemList& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAuctionGetSelfItemList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAuctionGetSelfItemList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAuctionGetSelfItemList* other);

  // implements Message ----------------------------------------------

  RequestAuctionGetSelfItemList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAuctionGetSelfItemList& from);
  void MergeFrom(const RequestAuctionGetSelfItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAuctionGetSelfItemList)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static RequestAuctionGetSelfItemList* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAuctionGetSelfItemList : public ::google::protobuf::MessageLite {
 public:
  ResponseAuctionGetSelfItemList();
  virtual ~ResponseAuctionGetSelfItemList();

  ResponseAuctionGetSelfItemList(const ResponseAuctionGetSelfItemList& from);

  inline ResponseAuctionGetSelfItemList& operator=(const ResponseAuctionGetSelfItemList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAuctionGetSelfItemList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAuctionGetSelfItemList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAuctionGetSelfItemList* other);

  // implements Message ----------------------------------------------

  ResponseAuctionGetSelfItemList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAuctionGetSelfItemList& from);
  void MergeFrom(const ResponseAuctionGetSelfItemList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.AuctionItemInfo auction_list = 1;
  inline int auction_list_size() const;
  inline void clear_auction_list();
  static const int kAuctionListFieldNumber = 1;
  inline const ::Protocol::AuctionItemInfo& auction_list(int index) const;
  inline ::Protocol::AuctionItemInfo* mutable_auction_list(int index);
  inline ::Protocol::AuctionItemInfo* add_auction_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >&
      auction_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >*
      mutable_auction_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAuctionGetSelfItemList)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo > auction_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static ResponseAuctionGetSelfItemList* default_instance_;
};
// -------------------------------------------------------------------

class NotifyAuctionUpdateParam : public ::google::protobuf::MessageLite {
 public:
  NotifyAuctionUpdateParam();
  virtual ~NotifyAuctionUpdateParam();

  NotifyAuctionUpdateParam(const NotifyAuctionUpdateParam& from);

  inline NotifyAuctionUpdateParam& operator=(const NotifyAuctionUpdateParam& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyAuctionUpdateParam& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyAuctionUpdateParam* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyAuctionUpdateParam* other);

  // implements Message ----------------------------------------------

  NotifyAuctionUpdateParam* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyAuctionUpdateParam& from);
  void MergeFrom(const NotifyAuctionUpdateParam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sell_item_cost = 1;
  inline bool has_sell_item_cost() const;
  inline void clear_sell_item_cost();
  static const int kSellItemCostFieldNumber = 1;
  inline ::google::protobuf::int32 sell_item_cost() const;
  inline void set_sell_item_cost(::google::protobuf::int32 value);

  // optional int32 sell_money_tax = 2;
  inline bool has_sell_money_tax() const;
  inline void clear_sell_money_tax();
  static const int kSellMoneyTaxFieldNumber = 2;
  inline ::google::protobuf::int32 sell_money_tax() const;
  inline void set_sell_money_tax(::google::protobuf::int32 value);

  // optional int32 sell_item_tax = 3;
  inline bool has_sell_item_tax() const;
  inline void clear_sell_item_tax();
  static const int kSellItemTaxFieldNumber = 3;
  inline ::google::protobuf::int32 sell_item_tax() const;
  inline void set_sell_item_tax(::google::protobuf::int32 value);

  // optional int32 sell_money_max = 4;
  inline bool has_sell_money_max() const;
  inline void clear_sell_money_max();
  static const int kSellMoneyMaxFieldNumber = 4;
  inline ::google::protobuf::int32 sell_money_max() const;
  inline void set_sell_money_max(::google::protobuf::int32 value);

  // optional int32 sell_item_max = 5;
  inline bool has_sell_item_max() const;
  inline void clear_sell_item_max();
  static const int kSellItemMaxFieldNumber = 5;
  inline ::google::protobuf::int32 sell_item_max() const;
  inline void set_sell_item_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyAuctionUpdateParam)
 private:
  inline void set_has_sell_item_cost();
  inline void clear_has_sell_item_cost();
  inline void set_has_sell_money_tax();
  inline void clear_has_sell_money_tax();
  inline void set_has_sell_item_tax();
  inline void clear_has_sell_item_tax();
  inline void set_has_sell_money_max();
  inline void clear_has_sell_money_max();
  inline void set_has_sell_item_max();
  inline void clear_has_sell_item_max();

  ::google::protobuf::int32 sell_item_cost_;
  ::google::protobuf::int32 sell_money_tax_;
  ::google::protobuf::int32 sell_item_tax_;
  ::google::protobuf::int32 sell_money_max_;
  ::google::protobuf::int32 sell_item_max_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoAuction_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoAuction_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoAuction_2eproto();
  friend void protobuf_ShutdownFile_ProtoAuction_2eproto();

  void InitAsDefaultInstance();
  static NotifyAuctionUpdateParam* default_instance_;
};
// ===================================================================


// ===================================================================

// AuctionMoneyInfo

// optional int32 auction_id = 1;
inline bool AuctionMoneyInfo::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuctionMoneyInfo::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuctionMoneyInfo::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuctionMoneyInfo::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 AuctionMoneyInfo::auction_id() const {
  return auction_id_;
}
inline void AuctionMoneyInfo::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// optional int32 require_gold = 2;
inline bool AuctionMoneyInfo::has_require_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuctionMoneyInfo::set_has_require_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuctionMoneyInfo::clear_has_require_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuctionMoneyInfo::clear_require_gold() {
  require_gold_ = 0;
  clear_has_require_gold();
}
inline ::google::protobuf::int32 AuctionMoneyInfo::require_gold() const {
  return require_gold_;
}
inline void AuctionMoneyInfo::set_require_gold(::google::protobuf::int32 value) {
  set_has_require_gold();
  require_gold_ = value;
}

// optional int32 total_money = 3;
inline bool AuctionMoneyInfo::has_total_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuctionMoneyInfo::set_has_total_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuctionMoneyInfo::clear_has_total_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuctionMoneyInfo::clear_total_money() {
  total_money_ = 0;
  clear_has_total_money();
}
inline ::google::protobuf::int32 AuctionMoneyInfo::total_money() const {
  return total_money_;
}
inline void AuctionMoneyInfo::set_total_money(::google::protobuf::int32 value) {
  set_has_total_money();
  total_money_ = value;
}

// optional int32 unit_money = 4;
inline bool AuctionMoneyInfo::has_unit_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuctionMoneyInfo::set_has_unit_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuctionMoneyInfo::clear_has_unit_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuctionMoneyInfo::clear_unit_money() {
  unit_money_ = 0;
  clear_has_unit_money();
}
inline ::google::protobuf::int32 AuctionMoneyInfo::unit_money() const {
  return unit_money_;
}
inline void AuctionMoneyInfo::set_unit_money(::google::protobuf::int32 value) {
  set_has_unit_money();
  unit_money_ = value;
}

// optional int32 time = 5;
inline bool AuctionMoneyInfo::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuctionMoneyInfo::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuctionMoneyInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuctionMoneyInfo::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 AuctionMoneyInfo::time() const {
  return time_;
}
inline void AuctionMoneyInfo::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// AuctionItemInfo

// optional int32 auction_id = 1;
inline bool AuctionItemInfo::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuctionItemInfo::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuctionItemInfo::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuctionItemInfo::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 AuctionItemInfo::auction_id() const {
  return auction_id_;
}
inline void AuctionItemInfo::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// optional int32 require_money = 2;
inline bool AuctionItemInfo::has_require_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuctionItemInfo::set_has_require_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuctionItemInfo::clear_has_require_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuctionItemInfo::clear_require_money() {
  require_money_ = 0;
  clear_has_require_money();
}
inline ::google::protobuf::int32 AuctionItemInfo::require_money() const {
  return require_money_;
}
inline void AuctionItemInfo::set_require_money(::google::protobuf::int32 value) {
  set_has_require_money();
  require_money_ = value;
}

// optional int32 item_id = 3;
inline bool AuctionItemInfo::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AuctionItemInfo::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AuctionItemInfo::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AuctionItemInfo::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 AuctionItemInfo::item_id() const {
  return item_id_;
}
inline void AuctionItemInfo::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional int32 item_level = 4;
inline bool AuctionItemInfo::has_item_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuctionItemInfo::set_has_item_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuctionItemInfo::clear_has_item_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuctionItemInfo::clear_item_level() {
  item_level_ = 0;
  clear_has_item_level();
}
inline ::google::protobuf::int32 AuctionItemInfo::item_level() const {
  return item_level_;
}
inline void AuctionItemInfo::set_item_level(::google::protobuf::int32 value) {
  set_has_item_level();
  item_level_ = value;
}

// optional int32 item_overlay = 5;
inline bool AuctionItemInfo::has_item_overlay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AuctionItemInfo::set_has_item_overlay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AuctionItemInfo::clear_has_item_overlay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AuctionItemInfo::clear_item_overlay() {
  item_overlay_ = 0;
  clear_has_item_overlay();
}
inline ::google::protobuf::int32 AuctionItemInfo::item_overlay() const {
  return item_overlay_;
}
inline void AuctionItemInfo::set_item_overlay(::google::protobuf::int32 value) {
  set_has_item_overlay();
  item_overlay_ = value;
}

// optional int32 item_star = 6;
inline bool AuctionItemInfo::has_item_star() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AuctionItemInfo::set_has_item_star() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AuctionItemInfo::clear_has_item_star() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AuctionItemInfo::clear_item_star() {
  item_star_ = 0;
  clear_has_item_star();
}
inline ::google::protobuf::int32 AuctionItemInfo::item_star() const {
  return item_star_;
}
inline void AuctionItemInfo::set_item_star(::google::protobuf::int32 value) {
  set_has_item_star();
  item_star_ = value;
}

// optional int32 time = 7;
inline bool AuctionItemInfo::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AuctionItemInfo::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AuctionItemInfo::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AuctionItemInfo::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 AuctionItemInfo::time() const {
  return time_;
}
inline void AuctionItemInfo::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// RequestAuctionGetMoneyList

// optional int32 page = 1 [default = 1];
inline bool RequestAuctionGetMoneyList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionGetMoneyList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionGetMoneyList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionGetMoneyList::clear_page() {
  page_ = 1;
  clear_has_page();
}
inline ::google::protobuf::int32 RequestAuctionGetMoneyList::page() const {
  return page_;
}
inline void RequestAuctionGetMoneyList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional .Protocol.AuctionSort sort_total_money = 2;
inline bool RequestAuctionGetMoneyList::has_sort_total_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestAuctionGetMoneyList::set_has_sort_total_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestAuctionGetMoneyList::clear_has_sort_total_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestAuctionGetMoneyList::clear_sort_total_money() {
  sort_total_money_ = 0;
  clear_has_sort_total_money();
}
inline ::Protocol::AuctionSort RequestAuctionGetMoneyList::sort_total_money() const {
  return static_cast< ::Protocol::AuctionSort >(sort_total_money_);
}
inline void RequestAuctionGetMoneyList::set_sort_total_money(::Protocol::AuctionSort value) {
  assert(::Protocol::AuctionSort_IsValid(value));
  set_has_sort_total_money();
  sort_total_money_ = value;
}

// optional .Protocol.AuctionSort sort_unit_money = 3;
inline bool RequestAuctionGetMoneyList::has_sort_unit_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestAuctionGetMoneyList::set_has_sort_unit_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestAuctionGetMoneyList::clear_has_sort_unit_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestAuctionGetMoneyList::clear_sort_unit_money() {
  sort_unit_money_ = 0;
  clear_has_sort_unit_money();
}
inline ::Protocol::AuctionSort RequestAuctionGetMoneyList::sort_unit_money() const {
  return static_cast< ::Protocol::AuctionSort >(sort_unit_money_);
}
inline void RequestAuctionGetMoneyList::set_sort_unit_money(::Protocol::AuctionSort value) {
  assert(::Protocol::AuctionSort_IsValid(value));
  set_has_sort_unit_money();
  sort_unit_money_ = value;
}

// optional .Protocol.AuctionSort sort_require_gold = 4;
inline bool RequestAuctionGetMoneyList::has_sort_require_gold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestAuctionGetMoneyList::set_has_sort_require_gold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestAuctionGetMoneyList::clear_has_sort_require_gold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestAuctionGetMoneyList::clear_sort_require_gold() {
  sort_require_gold_ = 0;
  clear_has_sort_require_gold();
}
inline ::Protocol::AuctionSort RequestAuctionGetMoneyList::sort_require_gold() const {
  return static_cast< ::Protocol::AuctionSort >(sort_require_gold_);
}
inline void RequestAuctionGetMoneyList::set_sort_require_gold(::Protocol::AuctionSort value) {
  assert(::Protocol::AuctionSort_IsValid(value));
  set_has_sort_require_gold();
  sort_require_gold_ = value;
}

// optional int32 filter_money_min = 5;
inline bool RequestAuctionGetMoneyList::has_filter_money_min() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestAuctionGetMoneyList::set_has_filter_money_min() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestAuctionGetMoneyList::clear_has_filter_money_min() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestAuctionGetMoneyList::clear_filter_money_min() {
  filter_money_min_ = 0;
  clear_has_filter_money_min();
}
inline ::google::protobuf::int32 RequestAuctionGetMoneyList::filter_money_min() const {
  return filter_money_min_;
}
inline void RequestAuctionGetMoneyList::set_filter_money_min(::google::protobuf::int32 value) {
  set_has_filter_money_min();
  filter_money_min_ = value;
}

// optional int32 filter_money_max = 6;
inline bool RequestAuctionGetMoneyList::has_filter_money_max() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestAuctionGetMoneyList::set_has_filter_money_max() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestAuctionGetMoneyList::clear_has_filter_money_max() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestAuctionGetMoneyList::clear_filter_money_max() {
  filter_money_max_ = 0;
  clear_has_filter_money_max();
}
inline ::google::protobuf::int32 RequestAuctionGetMoneyList::filter_money_max() const {
  return filter_money_max_;
}
inline void RequestAuctionGetMoneyList::set_filter_money_max(::google::protobuf::int32 value) {
  set_has_filter_money_max();
  filter_money_max_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionGetMoneyList

// optional int32 page = 1;
inline bool ResponseAuctionGetMoneyList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionGetMoneyList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionGetMoneyList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionGetMoneyList::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ResponseAuctionGetMoneyList::page() const {
  return page_;
}
inline void ResponseAuctionGetMoneyList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional int32 max_page = 2;
inline bool ResponseAuctionGetMoneyList::has_max_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseAuctionGetMoneyList::set_has_max_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseAuctionGetMoneyList::clear_has_max_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseAuctionGetMoneyList::clear_max_page() {
  max_page_ = 0;
  clear_has_max_page();
}
inline ::google::protobuf::int32 ResponseAuctionGetMoneyList::max_page() const {
  return max_page_;
}
inline void ResponseAuctionGetMoneyList::set_max_page(::google::protobuf::int32 value) {
  set_has_max_page();
  max_page_ = value;
}

// repeated .Protocol.AuctionMoneyInfo auction_list = 3;
inline int ResponseAuctionGetMoneyList::auction_list_size() const {
  return auction_list_.size();
}
inline void ResponseAuctionGetMoneyList::clear_auction_list() {
  auction_list_.Clear();
}
inline const ::Protocol::AuctionMoneyInfo& ResponseAuctionGetMoneyList::auction_list(int index) const {
  return auction_list_.Get(index);
}
inline ::Protocol::AuctionMoneyInfo* ResponseAuctionGetMoneyList::mutable_auction_list(int index) {
  return auction_list_.Mutable(index);
}
inline ::Protocol::AuctionMoneyInfo* ResponseAuctionGetMoneyList::add_auction_list() {
  return auction_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >&
ResponseAuctionGetMoneyList::auction_list() const {
  return auction_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >*
ResponseAuctionGetMoneyList::mutable_auction_list() {
  return &auction_list_;
}

// -------------------------------------------------------------------

// RequestAuctionSellMoney

// optional int32 money = 1;
inline bool RequestAuctionSellMoney::has_money() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionSellMoney::set_has_money() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionSellMoney::clear_has_money() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionSellMoney::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 RequestAuctionSellMoney::money() const {
  return money_;
}
inline void RequestAuctionSellMoney::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 require_gold = 2;
inline bool RequestAuctionSellMoney::has_require_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestAuctionSellMoney::set_has_require_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestAuctionSellMoney::clear_has_require_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestAuctionSellMoney::clear_require_gold() {
  require_gold_ = 0;
  clear_has_require_gold();
}
inline ::google::protobuf::int32 RequestAuctionSellMoney::require_gold() const {
  return require_gold_;
}
inline void RequestAuctionSellMoney::set_require_gold(::google::protobuf::int32 value) {
  set_has_require_gold();
  require_gold_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionSellMoney

// optional int32 result = 1;
inline bool ResponseAuctionSellMoney::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionSellMoney::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionSellMoney::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionSellMoney::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseAuctionSellMoney::result() const {
  return result_;
}
inline void ResponseAuctionSellMoney::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .Protocol.AuctionMoneyInfo info = 2;
inline bool ResponseAuctionSellMoney::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseAuctionSellMoney::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseAuctionSellMoney::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseAuctionSellMoney::clear_info() {
  if (info_ != NULL) info_->::Protocol::AuctionMoneyInfo::Clear();
  clear_has_info();
}
inline const ::Protocol::AuctionMoneyInfo& ResponseAuctionSellMoney::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::Protocol::AuctionMoneyInfo* ResponseAuctionSellMoney::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::Protocol::AuctionMoneyInfo;
  return info_;
}
inline ::Protocol::AuctionMoneyInfo* ResponseAuctionSellMoney::release_info() {
  clear_has_info();
  ::Protocol::AuctionMoneyInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void ResponseAuctionSellMoney::set_allocated_info(::Protocol::AuctionMoneyInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// RequestAuctionBuyMoney

// optional int32 auction_id = 1;
inline bool RequestAuctionBuyMoney::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionBuyMoney::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionBuyMoney::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionBuyMoney::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 RequestAuctionBuyMoney::auction_id() const {
  return auction_id_;
}
inline void RequestAuctionBuyMoney::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionBuyMoney

// optional int32 result = 1;
inline bool ResponseAuctionBuyMoney::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionBuyMoney::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionBuyMoney::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionBuyMoney::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseAuctionBuyMoney::result() const {
  return result_;
}
inline void ResponseAuctionBuyMoney::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestAuctionBackoutMoney

// optional int32 auction_id = 1;
inline bool RequestAuctionBackoutMoney::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionBackoutMoney::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionBackoutMoney::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionBackoutMoney::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 RequestAuctionBackoutMoney::auction_id() const {
  return auction_id_;
}
inline void RequestAuctionBackoutMoney::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionBackoutMoney

// optional int32 result = 1;
inline bool ResponseAuctionBackoutMoney::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionBackoutMoney::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionBackoutMoney::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionBackoutMoney::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseAuctionBackoutMoney::result() const {
  return result_;
}
inline void ResponseAuctionBackoutMoney::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestAuctionGetSelfMoneyList

// optional int32 reserve = 1;
inline bool RequestAuctionGetSelfMoneyList::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionGetSelfMoneyList::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionGetSelfMoneyList::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionGetSelfMoneyList::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestAuctionGetSelfMoneyList::reserve() const {
  return reserve_;
}
inline void RequestAuctionGetSelfMoneyList::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionGetSelfMoneyList

// repeated .Protocol.AuctionMoneyInfo auction_list = 1;
inline int ResponseAuctionGetSelfMoneyList::auction_list_size() const {
  return auction_list_.size();
}
inline void ResponseAuctionGetSelfMoneyList::clear_auction_list() {
  auction_list_.Clear();
}
inline const ::Protocol::AuctionMoneyInfo& ResponseAuctionGetSelfMoneyList::auction_list(int index) const {
  return auction_list_.Get(index);
}
inline ::Protocol::AuctionMoneyInfo* ResponseAuctionGetSelfMoneyList::mutable_auction_list(int index) {
  return auction_list_.Mutable(index);
}
inline ::Protocol::AuctionMoneyInfo* ResponseAuctionGetSelfMoneyList::add_auction_list() {
  return auction_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >&
ResponseAuctionGetSelfMoneyList::auction_list() const {
  return auction_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionMoneyInfo >*
ResponseAuctionGetSelfMoneyList::mutable_auction_list() {
  return &auction_list_;
}

// -------------------------------------------------------------------

// RequestAuctionGetItemList

// optional int32 page = 1 [default = 1];
inline bool RequestAuctionGetItemList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionGetItemList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionGetItemList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionGetItemList::clear_page() {
  page_ = 1;
  clear_has_page();
}
inline ::google::protobuf::int32 RequestAuctionGetItemList::page() const {
  return page_;
}
inline void RequestAuctionGetItemList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional .Protocol.AuctionSort sort_quality = 2;
inline bool RequestAuctionGetItemList::has_sort_quality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestAuctionGetItemList::set_has_sort_quality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestAuctionGetItemList::clear_has_sort_quality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestAuctionGetItemList::clear_sort_quality() {
  sort_quality_ = 0;
  clear_has_sort_quality();
}
inline ::Protocol::AuctionSort RequestAuctionGetItemList::sort_quality() const {
  return static_cast< ::Protocol::AuctionSort >(sort_quality_);
}
inline void RequestAuctionGetItemList::set_sort_quality(::Protocol::AuctionSort value) {
  assert(::Protocol::AuctionSort_IsValid(value));
  set_has_sort_quality();
  sort_quality_ = value;
}

// optional .Protocol.AuctionSort sort_level = 3;
inline bool RequestAuctionGetItemList::has_sort_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestAuctionGetItemList::set_has_sort_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestAuctionGetItemList::clear_has_sort_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestAuctionGetItemList::clear_sort_level() {
  sort_level_ = 0;
  clear_has_sort_level();
}
inline ::Protocol::AuctionSort RequestAuctionGetItemList::sort_level() const {
  return static_cast< ::Protocol::AuctionSort >(sort_level_);
}
inline void RequestAuctionGetItemList::set_sort_level(::Protocol::AuctionSort value) {
  assert(::Protocol::AuctionSort_IsValid(value));
  set_has_sort_level();
  sort_level_ = value;
}

// optional .Protocol.AuctionSort sort_overlay = 4;
inline bool RequestAuctionGetItemList::has_sort_overlay() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestAuctionGetItemList::set_has_sort_overlay() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestAuctionGetItemList::clear_has_sort_overlay() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestAuctionGetItemList::clear_sort_overlay() {
  sort_overlay_ = 0;
  clear_has_sort_overlay();
}
inline ::Protocol::AuctionSort RequestAuctionGetItemList::sort_overlay() const {
  return static_cast< ::Protocol::AuctionSort >(sort_overlay_);
}
inline void RequestAuctionGetItemList::set_sort_overlay(::Protocol::AuctionSort value) {
  assert(::Protocol::AuctionSort_IsValid(value));
  set_has_sort_overlay();
  sort_overlay_ = value;
}

// optional .Protocol.AuctionSort sort_require_money = 5;
inline bool RequestAuctionGetItemList::has_sort_require_money() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestAuctionGetItemList::set_has_sort_require_money() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestAuctionGetItemList::clear_has_sort_require_money() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestAuctionGetItemList::clear_sort_require_money() {
  sort_require_money_ = 0;
  clear_has_sort_require_money();
}
inline ::Protocol::AuctionSort RequestAuctionGetItemList::sort_require_money() const {
  return static_cast< ::Protocol::AuctionSort >(sort_require_money_);
}
inline void RequestAuctionGetItemList::set_sort_require_money(::Protocol::AuctionSort value) {
  assert(::Protocol::AuctionSort_IsValid(value));
  set_has_sort_require_money();
  sort_require_money_ = value;
}

// optional int32 filter_item_main_type = 6;
inline bool RequestAuctionGetItemList::has_filter_item_main_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestAuctionGetItemList::set_has_filter_item_main_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestAuctionGetItemList::clear_has_filter_item_main_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestAuctionGetItemList::clear_filter_item_main_type() {
  filter_item_main_type_ = 0;
  clear_has_filter_item_main_type();
}
inline ::google::protobuf::int32 RequestAuctionGetItemList::filter_item_main_type() const {
  return filter_item_main_type_;
}
inline void RequestAuctionGetItemList::set_filter_item_main_type(::google::protobuf::int32 value) {
  set_has_filter_item_main_type();
  filter_item_main_type_ = value;
}

// optional int32 filter_item_sub_type = 7;
inline bool RequestAuctionGetItemList::has_filter_item_sub_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestAuctionGetItemList::set_has_filter_item_sub_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestAuctionGetItemList::clear_has_filter_item_sub_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestAuctionGetItemList::clear_filter_item_sub_type() {
  filter_item_sub_type_ = 0;
  clear_has_filter_item_sub_type();
}
inline ::google::protobuf::int32 RequestAuctionGetItemList::filter_item_sub_type() const {
  return filter_item_sub_type_;
}
inline void RequestAuctionGetItemList::set_filter_item_sub_type(::google::protobuf::int32 value) {
  set_has_filter_item_sub_type();
  filter_item_sub_type_ = value;
}

// optional int32 filter_item_level = 8;
inline bool RequestAuctionGetItemList::has_filter_item_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestAuctionGetItemList::set_has_filter_item_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestAuctionGetItemList::clear_has_filter_item_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestAuctionGetItemList::clear_filter_item_level() {
  filter_item_level_ = 0;
  clear_has_filter_item_level();
}
inline ::google::protobuf::int32 RequestAuctionGetItemList::filter_item_level() const {
  return filter_item_level_;
}
inline void RequestAuctionGetItemList::set_filter_item_level(::google::protobuf::int32 value) {
  set_has_filter_item_level();
  filter_item_level_ = value;
}

// optional string filter_item_name = 9;
inline bool RequestAuctionGetItemList::has_filter_item_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestAuctionGetItemList::set_has_filter_item_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestAuctionGetItemList::clear_has_filter_item_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestAuctionGetItemList::clear_filter_item_name() {
  if (filter_item_name_ != &::google::protobuf::internal::kEmptyString) {
    filter_item_name_->clear();
  }
  clear_has_filter_item_name();
}
inline const ::std::string& RequestAuctionGetItemList::filter_item_name() const {
  return *filter_item_name_;
}
inline void RequestAuctionGetItemList::set_filter_item_name(const ::std::string& value) {
  set_has_filter_item_name();
  if (filter_item_name_ == &::google::protobuf::internal::kEmptyString) {
    filter_item_name_ = new ::std::string;
  }
  filter_item_name_->assign(value);
}
inline void RequestAuctionGetItemList::set_filter_item_name(const char* value) {
  set_has_filter_item_name();
  if (filter_item_name_ == &::google::protobuf::internal::kEmptyString) {
    filter_item_name_ = new ::std::string;
  }
  filter_item_name_->assign(value);
}
inline void RequestAuctionGetItemList::set_filter_item_name(const char* value, size_t size) {
  set_has_filter_item_name();
  if (filter_item_name_ == &::google::protobuf::internal::kEmptyString) {
    filter_item_name_ = new ::std::string;
  }
  filter_item_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestAuctionGetItemList::mutable_filter_item_name() {
  set_has_filter_item_name();
  if (filter_item_name_ == &::google::protobuf::internal::kEmptyString) {
    filter_item_name_ = new ::std::string;
  }
  return filter_item_name_;
}
inline ::std::string* RequestAuctionGetItemList::release_filter_item_name() {
  clear_has_filter_item_name();
  if (filter_item_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filter_item_name_;
    filter_item_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestAuctionGetItemList::set_allocated_filter_item_name(::std::string* filter_item_name) {
  if (filter_item_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_item_name_;
  }
  if (filter_item_name) {
    set_has_filter_item_name();
    filter_item_name_ = filter_item_name;
  } else {
    clear_has_filter_item_name();
    filter_item_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResponseAuctionGetItemList

// optional int32 page = 1;
inline bool ResponseAuctionGetItemList::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionGetItemList::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionGetItemList::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionGetItemList::clear_page() {
  page_ = 0;
  clear_has_page();
}
inline ::google::protobuf::int32 ResponseAuctionGetItemList::page() const {
  return page_;
}
inline void ResponseAuctionGetItemList::set_page(::google::protobuf::int32 value) {
  set_has_page();
  page_ = value;
}

// optional int32 max_page = 2;
inline bool ResponseAuctionGetItemList::has_max_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseAuctionGetItemList::set_has_max_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseAuctionGetItemList::clear_has_max_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseAuctionGetItemList::clear_max_page() {
  max_page_ = 0;
  clear_has_max_page();
}
inline ::google::protobuf::int32 ResponseAuctionGetItemList::max_page() const {
  return max_page_;
}
inline void ResponseAuctionGetItemList::set_max_page(::google::protobuf::int32 value) {
  set_has_max_page();
  max_page_ = value;
}

// repeated .Protocol.AuctionItemInfo auction_list = 3;
inline int ResponseAuctionGetItemList::auction_list_size() const {
  return auction_list_.size();
}
inline void ResponseAuctionGetItemList::clear_auction_list() {
  auction_list_.Clear();
}
inline const ::Protocol::AuctionItemInfo& ResponseAuctionGetItemList::auction_list(int index) const {
  return auction_list_.Get(index);
}
inline ::Protocol::AuctionItemInfo* ResponseAuctionGetItemList::mutable_auction_list(int index) {
  return auction_list_.Mutable(index);
}
inline ::Protocol::AuctionItemInfo* ResponseAuctionGetItemList::add_auction_list() {
  return auction_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >&
ResponseAuctionGetItemList::auction_list() const {
  return auction_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >*
ResponseAuctionGetItemList::mutable_auction_list() {
  return &auction_list_;
}

// -------------------------------------------------------------------

// RequestAuctionSellItem

// optional .ItemLocNum loc_num = 1;
inline bool RequestAuctionSellItem::has_loc_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionSellItem::set_has_loc_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionSellItem::clear_has_loc_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionSellItem::clear_loc_num() {
  if (loc_num_ != NULL) loc_num_->::ItemLocNum::Clear();
  clear_has_loc_num();
}
inline const ::ItemLocNum& RequestAuctionSellItem::loc_num() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_num_ != NULL ? *loc_num_ : *default_instance().loc_num_;
#else
  return loc_num_ != NULL ? *loc_num_ : *default_instance_->loc_num_;
#endif
}
inline ::ItemLocNum* RequestAuctionSellItem::mutable_loc_num() {
  set_has_loc_num();
  if (loc_num_ == NULL) loc_num_ = new ::ItemLocNum;
  return loc_num_;
}
inline ::ItemLocNum* RequestAuctionSellItem::release_loc_num() {
  clear_has_loc_num();
  ::ItemLocNum* temp = loc_num_;
  loc_num_ = NULL;
  return temp;
}
inline void RequestAuctionSellItem::set_allocated_loc_num(::ItemLocNum* loc_num) {
  delete loc_num_;
  loc_num_ = loc_num;
  if (loc_num) {
    set_has_loc_num();
  } else {
    clear_has_loc_num();
  }
}

// optional int32 require_money = 2;
inline bool RequestAuctionSellItem::has_require_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestAuctionSellItem::set_has_require_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestAuctionSellItem::clear_has_require_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestAuctionSellItem::clear_require_money() {
  require_money_ = 0;
  clear_has_require_money();
}
inline ::google::protobuf::int32 RequestAuctionSellItem::require_money() const {
  return require_money_;
}
inline void RequestAuctionSellItem::set_require_money(::google::protobuf::int32 value) {
  set_has_require_money();
  require_money_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionSellItem

// optional int32 result = 1;
inline bool ResponseAuctionSellItem::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionSellItem::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionSellItem::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionSellItem::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseAuctionSellItem::result() const {
  return result_;
}
inline void ResponseAuctionSellItem::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .Protocol.AuctionItemInfo info = 2;
inline bool ResponseAuctionSellItem::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseAuctionSellItem::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseAuctionSellItem::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseAuctionSellItem::clear_info() {
  if (info_ != NULL) info_->::Protocol::AuctionItemInfo::Clear();
  clear_has_info();
}
inline const ::Protocol::AuctionItemInfo& ResponseAuctionSellItem::info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return info_ != NULL ? *info_ : *default_instance().info_;
#else
  return info_ != NULL ? *info_ : *default_instance_->info_;
#endif
}
inline ::Protocol::AuctionItemInfo* ResponseAuctionSellItem::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::Protocol::AuctionItemInfo;
  return info_;
}
inline ::Protocol::AuctionItemInfo* ResponseAuctionSellItem::release_info() {
  clear_has_info();
  ::Protocol::AuctionItemInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline void ResponseAuctionSellItem::set_allocated_info(::Protocol::AuctionItemInfo* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// RequestAuctionGetItemDetail

// optional int32 auction_id = 2;
inline bool RequestAuctionGetItemDetail::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionGetItemDetail::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionGetItemDetail::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionGetItemDetail::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 RequestAuctionGetItemDetail::auction_id() const {
  return auction_id_;
}
inline void RequestAuctionGetItemDetail::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionGetItemDetail

// optional int32 auction_id = 1;
inline bool ResponseAuctionGetItemDetail::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionGetItemDetail::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionGetItemDetail::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionGetItemDetail::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 ResponseAuctionGetItemDetail::auction_id() const {
  return auction_id_;
}
inline void ResponseAuctionGetItemDetail::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// optional .ItemData item = 2;
inline bool ResponseAuctionGetItemDetail::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseAuctionGetItemDetail::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseAuctionGetItemDetail::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseAuctionGetItemDetail::clear_item() {
  if (item_ != NULL) item_->::ItemData::Clear();
  clear_has_item();
}
inline const ::ItemData& ResponseAuctionGetItemDetail::item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::ItemData* ResponseAuctionGetItemDetail::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ItemData;
  return item_;
}
inline ::ItemData* ResponseAuctionGetItemDetail::release_item() {
  clear_has_item();
  ::ItemData* temp = item_;
  item_ = NULL;
  return temp;
}
inline void ResponseAuctionGetItemDetail::set_allocated_item(::ItemData* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// optional string seller = 3;
inline bool ResponseAuctionGetItemDetail::has_seller() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseAuctionGetItemDetail::set_has_seller() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseAuctionGetItemDetail::clear_has_seller() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseAuctionGetItemDetail::clear_seller() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    seller_->clear();
  }
  clear_has_seller();
}
inline const ::std::string& ResponseAuctionGetItemDetail::seller() const {
  return *seller_;
}
inline void ResponseAuctionGetItemDetail::set_seller(const ::std::string& value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void ResponseAuctionGetItemDetail::set_seller(const char* value) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(value);
}
inline void ResponseAuctionGetItemDetail::set_seller(const char* value, size_t size) {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  seller_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseAuctionGetItemDetail::mutable_seller() {
  set_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    seller_ = new ::std::string;
  }
  return seller_;
}
inline ::std::string* ResponseAuctionGetItemDetail::release_seller() {
  clear_has_seller();
  if (seller_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seller_;
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseAuctionGetItemDetail::set_allocated_seller(::std::string* seller) {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  if (seller) {
    set_has_seller();
    seller_ = seller;
  } else {
    clear_has_seller();
    seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 require_money = 4;
inline bool ResponseAuctionGetItemDetail::has_require_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseAuctionGetItemDetail::set_has_require_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseAuctionGetItemDetail::clear_has_require_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseAuctionGetItemDetail::clear_require_money() {
  require_money_ = 0;
  clear_has_require_money();
}
inline ::google::protobuf::int32 ResponseAuctionGetItemDetail::require_money() const {
  return require_money_;
}
inline void ResponseAuctionGetItemDetail::set_require_money(::google::protobuf::int32 value) {
  set_has_require_money();
  require_money_ = value;
}

// -------------------------------------------------------------------

// RequestAuctionBuyItem

// optional int32 auction_id = 1;
inline bool RequestAuctionBuyItem::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionBuyItem::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionBuyItem::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionBuyItem::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 RequestAuctionBuyItem::auction_id() const {
  return auction_id_;
}
inline void RequestAuctionBuyItem::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionBuyItem

// optional int32 result = 1;
inline bool ResponseAuctionBuyItem::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionBuyItem::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionBuyItem::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionBuyItem::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseAuctionBuyItem::result() const {
  return result_;
}
inline void ResponseAuctionBuyItem::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestAuctionBackoutItem

// optional int32 auction_id = 1;
inline bool RequestAuctionBackoutItem::has_auction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionBackoutItem::set_has_auction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionBackoutItem::clear_has_auction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionBackoutItem::clear_auction_id() {
  auction_id_ = 0;
  clear_has_auction_id();
}
inline ::google::protobuf::int32 RequestAuctionBackoutItem::auction_id() const {
  return auction_id_;
}
inline void RequestAuctionBackoutItem::set_auction_id(::google::protobuf::int32 value) {
  set_has_auction_id();
  auction_id_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionBackoutItem

// optional int32 result = 1;
inline bool ResponseAuctionBackoutItem::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAuctionBackoutItem::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAuctionBackoutItem::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAuctionBackoutItem::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseAuctionBackoutItem::result() const {
  return result_;
}
inline void ResponseAuctionBackoutItem::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestAuctionGetSelfItemList

// optional int32 reserve = 1;
inline bool RequestAuctionGetSelfItemList::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAuctionGetSelfItemList::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAuctionGetSelfItemList::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAuctionGetSelfItemList::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestAuctionGetSelfItemList::reserve() const {
  return reserve_;
}
inline void RequestAuctionGetSelfItemList::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// ResponseAuctionGetSelfItemList

// repeated .Protocol.AuctionItemInfo auction_list = 1;
inline int ResponseAuctionGetSelfItemList::auction_list_size() const {
  return auction_list_.size();
}
inline void ResponseAuctionGetSelfItemList::clear_auction_list() {
  auction_list_.Clear();
}
inline const ::Protocol::AuctionItemInfo& ResponseAuctionGetSelfItemList::auction_list(int index) const {
  return auction_list_.Get(index);
}
inline ::Protocol::AuctionItemInfo* ResponseAuctionGetSelfItemList::mutable_auction_list(int index) {
  return auction_list_.Mutable(index);
}
inline ::Protocol::AuctionItemInfo* ResponseAuctionGetSelfItemList::add_auction_list() {
  return auction_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >&
ResponseAuctionGetSelfItemList::auction_list() const {
  return auction_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::AuctionItemInfo >*
ResponseAuctionGetSelfItemList::mutable_auction_list() {
  return &auction_list_;
}

// -------------------------------------------------------------------

// NotifyAuctionUpdateParam

// optional int32 sell_item_cost = 1;
inline bool NotifyAuctionUpdateParam::has_sell_item_cost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyAuctionUpdateParam::set_has_sell_item_cost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyAuctionUpdateParam::clear_has_sell_item_cost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyAuctionUpdateParam::clear_sell_item_cost() {
  sell_item_cost_ = 0;
  clear_has_sell_item_cost();
}
inline ::google::protobuf::int32 NotifyAuctionUpdateParam::sell_item_cost() const {
  return sell_item_cost_;
}
inline void NotifyAuctionUpdateParam::set_sell_item_cost(::google::protobuf::int32 value) {
  set_has_sell_item_cost();
  sell_item_cost_ = value;
}

// optional int32 sell_money_tax = 2;
inline bool NotifyAuctionUpdateParam::has_sell_money_tax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyAuctionUpdateParam::set_has_sell_money_tax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyAuctionUpdateParam::clear_has_sell_money_tax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyAuctionUpdateParam::clear_sell_money_tax() {
  sell_money_tax_ = 0;
  clear_has_sell_money_tax();
}
inline ::google::protobuf::int32 NotifyAuctionUpdateParam::sell_money_tax() const {
  return sell_money_tax_;
}
inline void NotifyAuctionUpdateParam::set_sell_money_tax(::google::protobuf::int32 value) {
  set_has_sell_money_tax();
  sell_money_tax_ = value;
}

// optional int32 sell_item_tax = 3;
inline bool NotifyAuctionUpdateParam::has_sell_item_tax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyAuctionUpdateParam::set_has_sell_item_tax() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyAuctionUpdateParam::clear_has_sell_item_tax() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyAuctionUpdateParam::clear_sell_item_tax() {
  sell_item_tax_ = 0;
  clear_has_sell_item_tax();
}
inline ::google::protobuf::int32 NotifyAuctionUpdateParam::sell_item_tax() const {
  return sell_item_tax_;
}
inline void NotifyAuctionUpdateParam::set_sell_item_tax(::google::protobuf::int32 value) {
  set_has_sell_item_tax();
  sell_item_tax_ = value;
}

// optional int32 sell_money_max = 4;
inline bool NotifyAuctionUpdateParam::has_sell_money_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifyAuctionUpdateParam::set_has_sell_money_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifyAuctionUpdateParam::clear_has_sell_money_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifyAuctionUpdateParam::clear_sell_money_max() {
  sell_money_max_ = 0;
  clear_has_sell_money_max();
}
inline ::google::protobuf::int32 NotifyAuctionUpdateParam::sell_money_max() const {
  return sell_money_max_;
}
inline void NotifyAuctionUpdateParam::set_sell_money_max(::google::protobuf::int32 value) {
  set_has_sell_money_max();
  sell_money_max_ = value;
}

// optional int32 sell_item_max = 5;
inline bool NotifyAuctionUpdateParam::has_sell_item_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NotifyAuctionUpdateParam::set_has_sell_item_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NotifyAuctionUpdateParam::clear_has_sell_item_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NotifyAuctionUpdateParam::clear_sell_item_max() {
  sell_item_max_ = 0;
  clear_has_sell_item_max();
}
inline ::google::protobuf::int32 NotifyAuctionUpdateParam::sell_item_max() const {
  return sell_item_max_;
}
inline void NotifyAuctionUpdateParam::set_sell_item_max(::google::protobuf::int32 value) {
  set_has_sell_item_max();
  sell_item_max_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoAuction_2eproto__INCLUDED
