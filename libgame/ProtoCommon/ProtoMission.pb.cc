// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoMission.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoMission.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace Protocol {

void protobuf_ShutdownFile_ProtoMission_2eproto() {
  delete RequestAcceptMission::default_instance_;
  delete ResponseAcceptMission::default_instance_;
  delete RequestCompleteMission::default_instance_;
  delete ResponseCompleteMission::default_instance_;
  delete RequestCancelMission::default_instance_;
  delete ResponseCancelMission::default_instance_;
  delete RequestUpdateMission::default_instance_;
  delete NotifyUpdateMission::default_instance_;
  delete RequestChangeMission::default_instance_;
  delete NotifyChangeMission::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoMission_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoMission_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoGameData_2eproto();
  RequestAcceptMission::default_instance_ = new RequestAcceptMission();
  ResponseAcceptMission::default_instance_ = new ResponseAcceptMission();
  RequestCompleteMission::default_instance_ = new RequestCompleteMission();
  ResponseCompleteMission::default_instance_ = new ResponseCompleteMission();
  RequestCancelMission::default_instance_ = new RequestCancelMission();
  ResponseCancelMission::default_instance_ = new ResponseCancelMission();
  RequestUpdateMission::default_instance_ = new RequestUpdateMission();
  NotifyUpdateMission::default_instance_ = new NotifyUpdateMission();
  RequestChangeMission::default_instance_ = new RequestChangeMission();
  NotifyChangeMission::default_instance_ = new NotifyChangeMission();
  RequestAcceptMission::default_instance_->InitAsDefaultInstance();
  ResponseAcceptMission::default_instance_->InitAsDefaultInstance();
  RequestCompleteMission::default_instance_->InitAsDefaultInstance();
  ResponseCompleteMission::default_instance_->InitAsDefaultInstance();
  RequestCancelMission::default_instance_->InitAsDefaultInstance();
  ResponseCancelMission::default_instance_->InitAsDefaultInstance();
  RequestUpdateMission::default_instance_->InitAsDefaultInstance();
  NotifyUpdateMission::default_instance_->InitAsDefaultInstance();
  RequestChangeMission::default_instance_->InitAsDefaultInstance();
  NotifyChangeMission::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoMission_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoMission_2eproto_once_);
void protobuf_AddDesc_ProtoMission_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoMission_2eproto_once_,
                 &protobuf_AddDesc_ProtoMission_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoMission_2eproto {
  StaticDescriptorInitializer_ProtoMission_2eproto() {
    protobuf_AddDesc_ProtoMission_2eproto();
  }
} static_descriptor_initializer_ProtoMission_2eproto_;
#endif
bool MissionOpCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAcceptMission::kMissionIdFieldNumber;
#endif  // !_MSC_VER

RequestAcceptMission::RequestAcceptMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAcceptMission::InitAsDefaultInstance() {
}

RequestAcceptMission::RequestAcceptMission(const RequestAcceptMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAcceptMission::SharedCtor() {
  _cached_size_ = 0;
  mission_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAcceptMission::~RequestAcceptMission() {
  SharedDtor();
}

void RequestAcceptMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAcceptMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAcceptMission& RequestAcceptMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

RequestAcceptMission* RequestAcceptMission::default_instance_ = NULL;

RequestAcceptMission* RequestAcceptMission::New() const {
  return new RequestAcceptMission;
}

void RequestAcceptMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAcceptMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_id_)));
          set_has_mission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAcceptMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_id = 1;
  if (has_mission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_id(), output);
  }

}

int RequestAcceptMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_id = 1;
    if (has_mission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAcceptMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAcceptMission*>(&from));
}

void RequestAcceptMission::MergeFrom(const RequestAcceptMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_id()) {
      set_mission_id(from.mission_id());
    }
  }
}

void RequestAcceptMission::CopyFrom(const RequestAcceptMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAcceptMission::IsInitialized() const {

  return true;
}

void RequestAcceptMission::Swap(RequestAcceptMission* other) {
  if (other != this) {
    std::swap(mission_id_, other->mission_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAcceptMission::GetTypeName() const {
  return "Protocol.RequestAcceptMission";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAcceptMission::kMissionIdFieldNumber;
const int ResponseAcceptMission::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseAcceptMission::ResponseAcceptMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAcceptMission::InitAsDefaultInstance() {
}

ResponseAcceptMission::ResponseAcceptMission(const ResponseAcceptMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAcceptMission::SharedCtor() {
  _cached_size_ = 0;
  mission_id_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAcceptMission::~ResponseAcceptMission() {
  SharedDtor();
}

void ResponseAcceptMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAcceptMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAcceptMission& ResponseAcceptMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

ResponseAcceptMission* ResponseAcceptMission::default_instance_ = NULL;

ResponseAcceptMission* ResponseAcceptMission::New() const {
  return new ResponseAcceptMission;
}

void ResponseAcceptMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_id_ = 0;
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAcceptMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_id_)));
          set_has_mission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // optional int32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAcceptMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_id = 1;
  if (has_mission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_id(), output);
  }

  // optional int32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->result(), output);
  }

}

int ResponseAcceptMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_id = 1;
    if (has_mission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_id());
    }

    // optional int32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAcceptMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAcceptMission*>(&from));
}

void ResponseAcceptMission::MergeFrom(const ResponseAcceptMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_id()) {
      set_mission_id(from.mission_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseAcceptMission::CopyFrom(const ResponseAcceptMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAcceptMission::IsInitialized() const {

  return true;
}

void ResponseAcceptMission::Swap(ResponseAcceptMission* other) {
  if (other != this) {
    std::swap(mission_id_, other->mission_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAcceptMission::GetTypeName() const {
  return "Protocol.ResponseAcceptMission";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCompleteMission::kMissionIdFieldNumber;
#endif  // !_MSC_VER

RequestCompleteMission::RequestCompleteMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestCompleteMission::InitAsDefaultInstance() {
}

RequestCompleteMission::RequestCompleteMission(const RequestCompleteMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestCompleteMission::SharedCtor() {
  _cached_size_ = 0;
  mission_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCompleteMission::~RequestCompleteMission() {
  SharedDtor();
}

void RequestCompleteMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCompleteMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCompleteMission& RequestCompleteMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

RequestCompleteMission* RequestCompleteMission::default_instance_ = NULL;

RequestCompleteMission* RequestCompleteMission::New() const {
  return new RequestCompleteMission;
}

void RequestCompleteMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestCompleteMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_id_)));
          set_has_mission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestCompleteMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_id = 1;
  if (has_mission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_id(), output);
  }

}

int RequestCompleteMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_id = 1;
    if (has_mission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCompleteMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCompleteMission*>(&from));
}

void RequestCompleteMission::MergeFrom(const RequestCompleteMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_id()) {
      set_mission_id(from.mission_id());
    }
  }
}

void RequestCompleteMission::CopyFrom(const RequestCompleteMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCompleteMission::IsInitialized() const {

  return true;
}

void RequestCompleteMission::Swap(RequestCompleteMission* other) {
  if (other != this) {
    std::swap(mission_id_, other->mission_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCompleteMission::GetTypeName() const {
  return "Protocol.RequestCompleteMission";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseCompleteMission::kMissionIdFieldNumber;
const int ResponseCompleteMission::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseCompleteMission::ResponseCompleteMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseCompleteMission::InitAsDefaultInstance() {
}

ResponseCompleteMission::ResponseCompleteMission(const ResponseCompleteMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseCompleteMission::SharedCtor() {
  _cached_size_ = 0;
  mission_id_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseCompleteMission::~ResponseCompleteMission() {
  SharedDtor();
}

void ResponseCompleteMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseCompleteMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseCompleteMission& ResponseCompleteMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

ResponseCompleteMission* ResponseCompleteMission::default_instance_ = NULL;

ResponseCompleteMission* ResponseCompleteMission::New() const {
  return new ResponseCompleteMission;
}

void ResponseCompleteMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_id_ = 0;
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseCompleteMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_id_)));
          set_has_mission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // optional int32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseCompleteMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_id = 1;
  if (has_mission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_id(), output);
  }

  // optional int32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->result(), output);
  }

}

int ResponseCompleteMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_id = 1;
    if (has_mission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_id());
    }

    // optional int32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseCompleteMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseCompleteMission*>(&from));
}

void ResponseCompleteMission::MergeFrom(const ResponseCompleteMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_id()) {
      set_mission_id(from.mission_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseCompleteMission::CopyFrom(const ResponseCompleteMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseCompleteMission::IsInitialized() const {

  return true;
}

void ResponseCompleteMission::Swap(ResponseCompleteMission* other) {
  if (other != this) {
    std::swap(mission_id_, other->mission_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseCompleteMission::GetTypeName() const {
  return "Protocol.ResponseCompleteMission";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCancelMission::kMissionIdFieldNumber;
#endif  // !_MSC_VER

RequestCancelMission::RequestCancelMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestCancelMission::InitAsDefaultInstance() {
}

RequestCancelMission::RequestCancelMission(const RequestCancelMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestCancelMission::SharedCtor() {
  _cached_size_ = 0;
  mission_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCancelMission::~RequestCancelMission() {
  SharedDtor();
}

void RequestCancelMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCancelMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCancelMission& RequestCancelMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

RequestCancelMission* RequestCancelMission::default_instance_ = NULL;

RequestCancelMission* RequestCancelMission::New() const {
  return new RequestCancelMission;
}

void RequestCancelMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestCancelMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_id_)));
          set_has_mission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestCancelMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_id = 1;
  if (has_mission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_id(), output);
  }

}

int RequestCancelMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_id = 1;
    if (has_mission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCancelMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCancelMission*>(&from));
}

void RequestCancelMission::MergeFrom(const RequestCancelMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_id()) {
      set_mission_id(from.mission_id());
    }
  }
}

void RequestCancelMission::CopyFrom(const RequestCancelMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCancelMission::IsInitialized() const {

  return true;
}

void RequestCancelMission::Swap(RequestCancelMission* other) {
  if (other != this) {
    std::swap(mission_id_, other->mission_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCancelMission::GetTypeName() const {
  return "Protocol.RequestCancelMission";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseCancelMission::kMissionIdFieldNumber;
const int ResponseCancelMission::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseCancelMission::ResponseCancelMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseCancelMission::InitAsDefaultInstance() {
}

ResponseCancelMission::ResponseCancelMission(const ResponseCancelMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseCancelMission::SharedCtor() {
  _cached_size_ = 0;
  mission_id_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseCancelMission::~ResponseCancelMission() {
  SharedDtor();
}

void ResponseCancelMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseCancelMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseCancelMission& ResponseCancelMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

ResponseCancelMission* ResponseCancelMission::default_instance_ = NULL;

ResponseCancelMission* ResponseCancelMission::New() const {
  return new ResponseCancelMission;
}

void ResponseCancelMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_id_ = 0;
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseCancelMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_id_)));
          set_has_mission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // optional int32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseCancelMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_id = 1;
  if (has_mission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_id(), output);
  }

  // optional int32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->result(), output);
  }

}

int ResponseCancelMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_id = 1;
    if (has_mission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_id());
    }

    // optional int32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseCancelMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseCancelMission*>(&from));
}

void ResponseCancelMission::MergeFrom(const ResponseCancelMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_id()) {
      set_mission_id(from.mission_id());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseCancelMission::CopyFrom(const ResponseCancelMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseCancelMission::IsInitialized() const {

  return true;
}

void ResponseCancelMission::Swap(ResponseCancelMission* other) {
  if (other != this) {
    std::swap(mission_id_, other->mission_id_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseCancelMission::GetTypeName() const {
  return "Protocol.ResponseCancelMission";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdateMission::kMissionIdFieldNumber;
#endif  // !_MSC_VER

RequestUpdateMission::RequestUpdateMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestUpdateMission::InitAsDefaultInstance() {
}

RequestUpdateMission::RequestUpdateMission(const RequestUpdateMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestUpdateMission::SharedCtor() {
  _cached_size_ = 0;
  mission_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateMission::~RequestUpdateMission() {
  SharedDtor();
}

void RequestUpdateMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdateMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateMission& RequestUpdateMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateMission* RequestUpdateMission::default_instance_ = NULL;

RequestUpdateMission* RequestUpdateMission::New() const {
  return new RequestUpdateMission;
}

void RequestUpdateMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestUpdateMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_id_)));
          set_has_mission_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestUpdateMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_id = 1;
  if (has_mission_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_id(), output);
  }

}

int RequestUpdateMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_id = 1;
    if (has_mission_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateMission*>(&from));
}

void RequestUpdateMission::MergeFrom(const RequestUpdateMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_id()) {
      set_mission_id(from.mission_id());
    }
  }
}

void RequestUpdateMission::CopyFrom(const RequestUpdateMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateMission::IsInitialized() const {

  return true;
}

void RequestUpdateMission::Swap(RequestUpdateMission* other) {
  if (other != this) {
    std::swap(mission_id_, other->mission_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateMission::GetTypeName() const {
  return "Protocol.RequestUpdateMission";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyUpdateMission::kDataFieldNumber;
#endif  // !_MSC_VER

NotifyUpdateMission::NotifyUpdateMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyUpdateMission::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::MissionData*>(
      ::MissionData::internal_default_instance());
#else
  data_ = const_cast< ::MissionData*>(&::MissionData::default_instance());
#endif
}

NotifyUpdateMission::NotifyUpdateMission(const NotifyUpdateMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyUpdateMission::SharedCtor() {
  _cached_size_ = 0;
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyUpdateMission::~NotifyUpdateMission() {
  SharedDtor();
}

void NotifyUpdateMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void NotifyUpdateMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyUpdateMission& NotifyUpdateMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

NotifyUpdateMission* NotifyUpdateMission::default_instance_ = NULL;

NotifyUpdateMission* NotifyUpdateMission::New() const {
  return new NotifyUpdateMission;
}

void NotifyUpdateMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_data()) {
      if (data_ != NULL) data_->::MissionData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyUpdateMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MissionData data = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyUpdateMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .MissionData data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->data(), output);
  }

}

int NotifyUpdateMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MissionData data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyUpdateMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyUpdateMission*>(&from));
}

void NotifyUpdateMission::MergeFrom(const NotifyUpdateMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      mutable_data()->::MissionData::MergeFrom(from.data());
    }
  }
}

void NotifyUpdateMission::CopyFrom(const NotifyUpdateMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyUpdateMission::IsInitialized() const {

  return true;
}

void NotifyUpdateMission::Swap(NotifyUpdateMission* other) {
  if (other != this) {
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyUpdateMission::GetTypeName() const {
  return "Protocol.NotifyUpdateMission";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestChangeMission::kMissionTypeFieldNumber;
#endif  // !_MSC_VER

RequestChangeMission::RequestChangeMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestChangeMission::InitAsDefaultInstance() {
}

RequestChangeMission::RequestChangeMission(const RequestChangeMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestChangeMission::SharedCtor() {
  _cached_size_ = 0;
  mission_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestChangeMission::~RequestChangeMission() {
  SharedDtor();
}

void RequestChangeMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestChangeMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestChangeMission& RequestChangeMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

RequestChangeMission* RequestChangeMission::default_instance_ = NULL;

RequestChangeMission* RequestChangeMission::New() const {
  return new RequestChangeMission;
}

void RequestChangeMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    mission_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestChangeMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 mission_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mission_type_)));
          set_has_mission_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestChangeMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 mission_type = 1;
  if (has_mission_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mission_type(), output);
  }

}

int RequestChangeMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 mission_type = 1;
    if (has_mission_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mission_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestChangeMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestChangeMission*>(&from));
}

void RequestChangeMission::MergeFrom(const RequestChangeMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mission_type()) {
      set_mission_type(from.mission_type());
    }
  }
}

void RequestChangeMission::CopyFrom(const RequestChangeMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestChangeMission::IsInitialized() const {

  return true;
}

void RequestChangeMission::Swap(RequestChangeMission* other) {
  if (other != this) {
    std::swap(mission_type_, other->mission_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestChangeMission::GetTypeName() const {
  return "Protocol.RequestChangeMission";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyChangeMission::kRequireMoneyFieldNumber;
const int NotifyChangeMission::kDataFieldNumber;
#endif  // !_MSC_VER

NotifyChangeMission::NotifyChangeMission()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyChangeMission::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_ = const_cast< ::MissionData*>(
      ::MissionData::internal_default_instance());
#else
  data_ = const_cast< ::MissionData*>(&::MissionData::default_instance());
#endif
}

NotifyChangeMission::NotifyChangeMission(const NotifyChangeMission& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyChangeMission::SharedCtor() {
  _cached_size_ = 0;
  require_money_ = 0;
  data_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyChangeMission::~NotifyChangeMission() {
  SharedDtor();
}

void NotifyChangeMission::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_;
  }
}

void NotifyChangeMission::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyChangeMission& NotifyChangeMission::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMission_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMission_2eproto();
#endif
  return *default_instance_;
}

NotifyChangeMission* NotifyChangeMission::default_instance_ = NULL;

NotifyChangeMission* NotifyChangeMission::New() const {
  return new NotifyChangeMission;
}

void NotifyChangeMission::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    require_money_ = 0;
    if (has_data()) {
      if (data_ != NULL) data_->::MissionData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyChangeMission::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 require_money = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &require_money_)));
          set_has_require_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // optional .MissionData data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyChangeMission::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 require_money = 1;
  if (has_require_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->require_money(), output);
  }

  // optional .MissionData data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data(), output);
  }

}

int NotifyChangeMission::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 require_money = 1;
    if (has_require_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->require_money());
    }

    // optional .MissionData data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->data());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyChangeMission::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyChangeMission*>(&from));
}

void NotifyChangeMission::MergeFrom(const NotifyChangeMission& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_require_money()) {
      set_require_money(from.require_money());
    }
    if (from.has_data()) {
      mutable_data()->::MissionData::MergeFrom(from.data());
    }
  }
}

void NotifyChangeMission::CopyFrom(const NotifyChangeMission& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyChangeMission::IsInitialized() const {

  return true;
}

void NotifyChangeMission::Swap(NotifyChangeMission* other) {
  if (other != this) {
    std::swap(require_money_, other->require_money_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyChangeMission::GetTypeName() const {
  return "Protocol.NotifyChangeMission";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)
