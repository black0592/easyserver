// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoItem.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoItem.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace Protocol {

void protobuf_ShutdownFile_ProtoItem_2eproto() {
  delete DropItemInfo::default_instance_;
  delete NotifyCreateDropItem::default_instance_;
  delete NotifyMonsterDropItem::default_instance_;
  delete RequestCharDropItem::default_instance_;
  delete NotifyCharDropItem::default_instance_;
  delete NotifyRemoveItemFromMap::default_instance_;
  delete RequestPickupItem::default_instance_;
  delete NotifyPickupItem::default_instance_;
  delete RequestEquipItem::default_instance_;
  delete ResponseEquipItem::default_instance_;
  delete NotifyAddItem::default_instance_;
  delete NotifyRemoveItem::default_instance_;
  delete NotifyReplaceItem::default_instance_;
  delete NotifyRefreshPackage::default_instance_;
  delete RequestUseItem::default_instance_;
  delete ResponseUseItem::default_instance_;
  delete RequestGetBuyPackagePrice::default_instance_;
  delete ResponseGetBuyPackagePrice::default_instance_;
  delete RequestBuyPackageSize::default_instance_;
  delete ResponseBuyPackageSize::default_instance_;
  delete RequestSortPackage::default_instance_;
  delete StoreItem::default_instance_;
  delete RequestGetStoreItem::default_instance_;
  delete ResponseGetStoreItem::default_instance_;
  delete RequestBuyStoreItem::default_instance_;
  delete ResponseBuyStoreItem::default_instance_;
  delete SellItemInfo::default_instance_;
  delete RequestSellItem::default_instance_;
  delete ResponseSellItem::default_instance_;
  delete RequestGetSafeItems::default_instance_;
  delete RequestDepositMoney::default_instance_;
  delete RequestWithdrawMoney::default_instance_;
  delete RequestDepositItem::default_instance_;
  delete RequestWithdrawItem::default_instance_;
  delete CashShopItem::default_instance_;
  delete RequestGetCashShopItem::default_instance_;
  delete ResponseGetCashShopItem::default_instance_;
  delete RequestBuyCashShopItem::default_instance_;
  delete ResponseBuyCashShopItem::default_instance_;
  delete RequestRemoteOpenEquipRepair::default_instance_;
  delete RequestGetEquipRepairMoney::default_instance_;
  delete ResponseGetEquipRepairMoney::default_instance_;
  delete RequestEquipRepair::default_instance_;
  delete ResponseEquipRepair::default_instance_;
  delete RequestEquipGetResetExpiredCost::default_instance_;
  delete ResponseEquipGetResetExpiredCost::default_instance_;
  delete RequestEquipResetExpiredTime::default_instance_;
  delete ResponseEquipResetExpiredTime::default_instance_;
  delete RequestBuybackGetItem::default_instance_;
  delete RequestBuybackBuyItem::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoItem_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoItem_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoGameData_2eproto();
  DropItemInfo::default_instance_ = new DropItemInfo();
  NotifyCreateDropItem::default_instance_ = new NotifyCreateDropItem();
  NotifyMonsterDropItem::default_instance_ = new NotifyMonsterDropItem();
  RequestCharDropItem::default_instance_ = new RequestCharDropItem();
  NotifyCharDropItem::default_instance_ = new NotifyCharDropItem();
  NotifyRemoveItemFromMap::default_instance_ = new NotifyRemoveItemFromMap();
  RequestPickupItem::default_instance_ = new RequestPickupItem();
  NotifyPickupItem::default_instance_ = new NotifyPickupItem();
  RequestEquipItem::default_instance_ = new RequestEquipItem();
  ResponseEquipItem::default_instance_ = new ResponseEquipItem();
  NotifyAddItem::default_instance_ = new NotifyAddItem();
  NotifyRemoveItem::default_instance_ = new NotifyRemoveItem();
  NotifyReplaceItem::default_instance_ = new NotifyReplaceItem();
  NotifyRefreshPackage::default_instance_ = new NotifyRefreshPackage();
  RequestUseItem::default_instance_ = new RequestUseItem();
  ResponseUseItem::default_instance_ = new ResponseUseItem();
  RequestGetBuyPackagePrice::default_instance_ = new RequestGetBuyPackagePrice();
  ResponseGetBuyPackagePrice::default_instance_ = new ResponseGetBuyPackagePrice();
  RequestBuyPackageSize::default_instance_ = new RequestBuyPackageSize();
  ResponseBuyPackageSize::default_instance_ = new ResponseBuyPackageSize();
  RequestSortPackage::default_instance_ = new RequestSortPackage();
  StoreItem::default_instance_ = new StoreItem();
  RequestGetStoreItem::default_instance_ = new RequestGetStoreItem();
  ResponseGetStoreItem::default_instance_ = new ResponseGetStoreItem();
  RequestBuyStoreItem::default_instance_ = new RequestBuyStoreItem();
  ResponseBuyStoreItem::default_instance_ = new ResponseBuyStoreItem();
  SellItemInfo::default_instance_ = new SellItemInfo();
  RequestSellItem::default_instance_ = new RequestSellItem();
  ResponseSellItem::default_instance_ = new ResponseSellItem();
  RequestGetSafeItems::default_instance_ = new RequestGetSafeItems();
  RequestDepositMoney::default_instance_ = new RequestDepositMoney();
  RequestWithdrawMoney::default_instance_ = new RequestWithdrawMoney();
  RequestDepositItem::default_instance_ = new RequestDepositItem();
  RequestWithdrawItem::default_instance_ = new RequestWithdrawItem();
  CashShopItem::default_instance_ = new CashShopItem();
  RequestGetCashShopItem::default_instance_ = new RequestGetCashShopItem();
  ResponseGetCashShopItem::default_instance_ = new ResponseGetCashShopItem();
  RequestBuyCashShopItem::default_instance_ = new RequestBuyCashShopItem();
  ResponseBuyCashShopItem::default_instance_ = new ResponseBuyCashShopItem();
  RequestRemoteOpenEquipRepair::default_instance_ = new RequestRemoteOpenEquipRepair();
  RequestGetEquipRepairMoney::default_instance_ = new RequestGetEquipRepairMoney();
  ResponseGetEquipRepairMoney::default_instance_ = new ResponseGetEquipRepairMoney();
  RequestEquipRepair::default_instance_ = new RequestEquipRepair();
  ResponseEquipRepair::default_instance_ = new ResponseEquipRepair();
  RequestEquipGetResetExpiredCost::default_instance_ = new RequestEquipGetResetExpiredCost();
  ResponseEquipGetResetExpiredCost::default_instance_ = new ResponseEquipGetResetExpiredCost();
  RequestEquipResetExpiredTime::default_instance_ = new RequestEquipResetExpiredTime();
  ResponseEquipResetExpiredTime::default_instance_ = new ResponseEquipResetExpiredTime();
  RequestBuybackGetItem::default_instance_ = new RequestBuybackGetItem();
  RequestBuybackBuyItem::default_instance_ = new RequestBuybackBuyItem();
  DropItemInfo::default_instance_->InitAsDefaultInstance();
  NotifyCreateDropItem::default_instance_->InitAsDefaultInstance();
  NotifyMonsterDropItem::default_instance_->InitAsDefaultInstance();
  RequestCharDropItem::default_instance_->InitAsDefaultInstance();
  NotifyCharDropItem::default_instance_->InitAsDefaultInstance();
  NotifyRemoveItemFromMap::default_instance_->InitAsDefaultInstance();
  RequestPickupItem::default_instance_->InitAsDefaultInstance();
  NotifyPickupItem::default_instance_->InitAsDefaultInstance();
  RequestEquipItem::default_instance_->InitAsDefaultInstance();
  ResponseEquipItem::default_instance_->InitAsDefaultInstance();
  NotifyAddItem::default_instance_->InitAsDefaultInstance();
  NotifyRemoveItem::default_instance_->InitAsDefaultInstance();
  NotifyReplaceItem::default_instance_->InitAsDefaultInstance();
  NotifyRefreshPackage::default_instance_->InitAsDefaultInstance();
  RequestUseItem::default_instance_->InitAsDefaultInstance();
  ResponseUseItem::default_instance_->InitAsDefaultInstance();
  RequestGetBuyPackagePrice::default_instance_->InitAsDefaultInstance();
  ResponseGetBuyPackagePrice::default_instance_->InitAsDefaultInstance();
  RequestBuyPackageSize::default_instance_->InitAsDefaultInstance();
  ResponseBuyPackageSize::default_instance_->InitAsDefaultInstance();
  RequestSortPackage::default_instance_->InitAsDefaultInstance();
  StoreItem::default_instance_->InitAsDefaultInstance();
  RequestGetStoreItem::default_instance_->InitAsDefaultInstance();
  ResponseGetStoreItem::default_instance_->InitAsDefaultInstance();
  RequestBuyStoreItem::default_instance_->InitAsDefaultInstance();
  ResponseBuyStoreItem::default_instance_->InitAsDefaultInstance();
  SellItemInfo::default_instance_->InitAsDefaultInstance();
  RequestSellItem::default_instance_->InitAsDefaultInstance();
  ResponseSellItem::default_instance_->InitAsDefaultInstance();
  RequestGetSafeItems::default_instance_->InitAsDefaultInstance();
  RequestDepositMoney::default_instance_->InitAsDefaultInstance();
  RequestWithdrawMoney::default_instance_->InitAsDefaultInstance();
  RequestDepositItem::default_instance_->InitAsDefaultInstance();
  RequestWithdrawItem::default_instance_->InitAsDefaultInstance();
  CashShopItem::default_instance_->InitAsDefaultInstance();
  RequestGetCashShopItem::default_instance_->InitAsDefaultInstance();
  ResponseGetCashShopItem::default_instance_->InitAsDefaultInstance();
  RequestBuyCashShopItem::default_instance_->InitAsDefaultInstance();
  ResponseBuyCashShopItem::default_instance_->InitAsDefaultInstance();
  RequestRemoteOpenEquipRepair::default_instance_->InitAsDefaultInstance();
  RequestGetEquipRepairMoney::default_instance_->InitAsDefaultInstance();
  ResponseGetEquipRepairMoney::default_instance_->InitAsDefaultInstance();
  RequestEquipRepair::default_instance_->InitAsDefaultInstance();
  ResponseEquipRepair::default_instance_->InitAsDefaultInstance();
  RequestEquipGetResetExpiredCost::default_instance_->InitAsDefaultInstance();
  ResponseEquipGetResetExpiredCost::default_instance_->InitAsDefaultInstance();
  RequestEquipResetExpiredTime::default_instance_->InitAsDefaultInstance();
  ResponseEquipResetExpiredTime::default_instance_->InitAsDefaultInstance();
  RequestBuybackGetItem::default_instance_->InitAsDefaultInstance();
  RequestBuybackBuyItem::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoItem_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoItem_2eproto_once_);
void protobuf_AddDesc_ProtoItem_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoItem_2eproto_once_,
                 &protobuf_AddDesc_ProtoItem_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoItem_2eproto {
  StaticDescriptorInitializer_ProtoItem_2eproto() {
    protobuf_AddDesc_ProtoItem_2eproto();
  }
} static_descriptor_initializer_ProtoItem_2eproto_;
#endif
bool ItemOpCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 30:
    case 31:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
      return true;
    default:
      return false;
  }
}

bool StoreCurrencyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool EquipRepairType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int DropItemInfo::kOwnerIdFieldNumber;
const int DropItemInfo::kItemIdFieldNumber;
const int DropItemInfo::kItemNumFieldNumber;
const int DropItemInfo::kMapXFieldNumber;
const int DropItemInfo::kMapYFieldNumber;
const int DropItemInfo::kColorFieldNumber;
const int DropItemInfo::kQualityFieldNumber;
#endif  // !_MSC_VER

DropItemInfo::DropItemInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void DropItemInfo::InitAsDefaultInstance() {
}

DropItemInfo::DropItemInfo(const DropItemInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void DropItemInfo::SharedCtor() {
  _cached_size_ = 0;
  owner_id_ = 0;
  item_id_ = 0;
  item_num_ = 1;
  map_x_ = 0;
  map_y_ = 0;
  color_ = 0;
  quality_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DropItemInfo::~DropItemInfo() {
  SharedDtor();
}

void DropItemInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DropItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DropItemInfo& DropItemInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

DropItemInfo* DropItemInfo::default_instance_ = NULL;

DropItemInfo* DropItemInfo::New() const {
  return new DropItemInfo;
}

void DropItemInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    owner_id_ = 0;
    item_id_ = 0;
    item_num_ = 1;
    map_x_ = 0;
    map_y_ = 0;
    color_ = 0;
    quality_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool DropItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 owner_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &owner_id_)));
          set_has_owner_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_id;
        break;
      }

      // optional int32 item_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_num;
        break;
      }

      // optional int32 item_num = 3 [default = 1];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_map_x;
        break;
      }

      // optional int32 map_x = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_x_)));
          set_has_map_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_map_y;
        break;
      }

      // optional int32 map_y = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_y_)));
          set_has_map_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_color;
        break;
      }

      // optional int32 color = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &color_)));
          set_has_color();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_quality;
        break;
      }

      // optional int32 quality = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_quality:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &quality_)));
          set_has_quality();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DropItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 owner_id = 1;
  if (has_owner_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->owner_id(), output);
  }

  // optional int32 item_id = 2;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->item_id(), output);
  }

  // optional int32 item_num = 3 [default = 1];
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->item_num(), output);
  }

  // optional int32 map_x = 4;
  if (has_map_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->map_x(), output);
  }

  // optional int32 map_y = 5;
  if (has_map_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->map_y(), output);
  }

  // optional int32 color = 6;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->color(), output);
  }

  // optional int32 quality = 7;
  if (has_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->quality(), output);
  }

}

int DropItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 owner_id = 1;
    if (has_owner_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->owner_id());
    }

    // optional int32 item_id = 2;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_id());
    }

    // optional int32 item_num = 3 [default = 1];
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_num());
    }

    // optional int32 map_x = 4;
    if (has_map_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_x());
    }

    // optional int32 map_y = 5;
    if (has_map_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_y());
    }

    // optional int32 color = 6;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->color());
    }

    // optional int32 quality = 7;
    if (has_quality()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->quality());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DropItemInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DropItemInfo*>(&from));
}

void DropItemInfo::MergeFrom(const DropItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_owner_id()) {
      set_owner_id(from.owner_id());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
    if (from.has_map_x()) {
      set_map_x(from.map_x());
    }
    if (from.has_map_y()) {
      set_map_y(from.map_y());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_quality()) {
      set_quality(from.quality());
    }
  }
}

void DropItemInfo::CopyFrom(const DropItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DropItemInfo::IsInitialized() const {

  return true;
}

void DropItemInfo::Swap(DropItemInfo* other) {
  if (other != this) {
    std::swap(owner_id_, other->owner_id_);
    std::swap(item_id_, other->item_id_);
    std::swap(item_num_, other->item_num_);
    std::swap(map_x_, other->map_x_);
    std::swap(map_y_, other->map_y_);
    std::swap(color_, other->color_);
    std::swap(quality_, other->quality_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DropItemInfo::GetTypeName() const {
  return "Protocol.DropItemInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCreateDropItem::kItemListFieldNumber;
#endif  // !_MSC_VER

NotifyCreateDropItem::NotifyCreateDropItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCreateDropItem::InitAsDefaultInstance() {
}

NotifyCreateDropItem::NotifyCreateDropItem(const NotifyCreateDropItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCreateDropItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCreateDropItem::~NotifyCreateDropItem() {
  SharedDtor();
}

void NotifyCreateDropItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCreateDropItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCreateDropItem& NotifyCreateDropItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyCreateDropItem* NotifyCreateDropItem::default_instance_ = NULL;

NotifyCreateDropItem* NotifyCreateDropItem::New() const {
  return new NotifyCreateDropItem;
}

void NotifyCreateDropItem::Clear() {
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCreateDropItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.DropItemInfo item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCreateDropItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.DropItemInfo item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

}

int NotifyCreateDropItem::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.DropItemInfo item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCreateDropItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCreateDropItem*>(&from));
}

void NotifyCreateDropItem::MergeFrom(const NotifyCreateDropItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
}

void NotifyCreateDropItem::CopyFrom(const NotifyCreateDropItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCreateDropItem::IsInitialized() const {

  return true;
}

void NotifyCreateDropItem::Swap(NotifyCreateDropItem* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCreateDropItem::GetTypeName() const {
  return "Protocol.NotifyCreateDropItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyMonsterDropItem::kItemListFieldNumber;
#endif  // !_MSC_VER

NotifyMonsterDropItem::NotifyMonsterDropItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyMonsterDropItem::InitAsDefaultInstance() {
}

NotifyMonsterDropItem::NotifyMonsterDropItem(const NotifyMonsterDropItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyMonsterDropItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyMonsterDropItem::~NotifyMonsterDropItem() {
  SharedDtor();
}

void NotifyMonsterDropItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyMonsterDropItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyMonsterDropItem& NotifyMonsterDropItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyMonsterDropItem* NotifyMonsterDropItem::default_instance_ = NULL;

NotifyMonsterDropItem* NotifyMonsterDropItem::New() const {
  return new NotifyMonsterDropItem;
}

void NotifyMonsterDropItem::Clear() {
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyMonsterDropItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.DropItemInfo item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyMonsterDropItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.DropItemInfo item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

}

int NotifyMonsterDropItem::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.DropItemInfo item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyMonsterDropItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyMonsterDropItem*>(&from));
}

void NotifyMonsterDropItem::MergeFrom(const NotifyMonsterDropItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
}

void NotifyMonsterDropItem::CopyFrom(const NotifyMonsterDropItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyMonsterDropItem::IsInitialized() const {

  return true;
}

void NotifyMonsterDropItem::Swap(NotifyMonsterDropItem* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyMonsterDropItem::GetTypeName() const {
  return "Protocol.NotifyMonsterDropItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCharDropItem::kSrcLocFieldNumber;
const int RequestCharDropItem::kItemNumFieldNumber;
const int RequestCharDropItem::kMapXFieldNumber;
const int RequestCharDropItem::kMapYFieldNumber;
#endif  // !_MSC_VER

RequestCharDropItem::RequestCharDropItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestCharDropItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  src_loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  src_loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

RequestCharDropItem::RequestCharDropItem(const RequestCharDropItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestCharDropItem::SharedCtor() {
  _cached_size_ = 0;
  src_loc_ = NULL;
  item_num_ = 0;
  map_x_ = 0;
  map_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCharDropItem::~RequestCharDropItem() {
  SharedDtor();
}

void RequestCharDropItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete src_loc_;
  }
}

void RequestCharDropItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCharDropItem& RequestCharDropItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestCharDropItem* RequestCharDropItem::default_instance_ = NULL;

RequestCharDropItem* RequestCharDropItem::New() const {
  return new RequestCharDropItem;
}

void RequestCharDropItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_src_loc()) {
      if (src_loc_ != NULL) src_loc_->::ItemLoc::Clear();
    }
    item_num_ = 0;
    map_x_ = 0;
    map_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestCharDropItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc src_loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_src_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_item_num;
        break;
      }

      // optional int32 item_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_num_)));
          set_has_item_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_map_x;
        break;
      }

      // optional int32 map_x = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_x_)));
          set_has_map_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_map_y;
        break;
      }

      // optional int32 map_y = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_y_)));
          set_has_map_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestCharDropItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc src_loc = 1;
  if (has_src_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->src_loc(), output);
  }

  // optional int32 item_num = 2;
  if (has_item_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->item_num(), output);
  }

  // optional int32 map_x = 3;
  if (has_map_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->map_x(), output);
  }

  // optional int32 map_y = 4;
  if (has_map_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->map_y(), output);
  }

}

int RequestCharDropItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc src_loc = 1;
    if (has_src_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->src_loc());
    }

    // optional int32 item_num = 2;
    if (has_item_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_num());
    }

    // optional int32 map_x = 3;
    if (has_map_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_x());
    }

    // optional int32 map_y = 4;
    if (has_map_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCharDropItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCharDropItem*>(&from));
}

void RequestCharDropItem::MergeFrom(const RequestCharDropItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_src_loc()) {
      mutable_src_loc()->::ItemLoc::MergeFrom(from.src_loc());
    }
    if (from.has_item_num()) {
      set_item_num(from.item_num());
    }
    if (from.has_map_x()) {
      set_map_x(from.map_x());
    }
    if (from.has_map_y()) {
      set_map_y(from.map_y());
    }
  }
}

void RequestCharDropItem::CopyFrom(const RequestCharDropItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCharDropItem::IsInitialized() const {

  return true;
}

void RequestCharDropItem::Swap(RequestCharDropItem* other) {
  if (other != this) {
    std::swap(src_loc_, other->src_loc_);
    std::swap(item_num_, other->item_num_);
    std::swap(map_x_, other->map_x_);
    std::swap(map_y_, other->map_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCharDropItem::GetTypeName() const {
  return "Protocol.RequestCharDropItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCharDropItem::kItemFieldNumber;
#endif  // !_MSC_VER

NotifyCharDropItem::NotifyCharDropItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCharDropItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::Protocol::DropItemInfo*>(
      ::Protocol::DropItemInfo::internal_default_instance());
#else
  item_ = const_cast< ::Protocol::DropItemInfo*>(&::Protocol::DropItemInfo::default_instance());
#endif
}

NotifyCharDropItem::NotifyCharDropItem(const NotifyCharDropItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCharDropItem::SharedCtor() {
  _cached_size_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCharDropItem::~NotifyCharDropItem() {
  SharedDtor();
}

void NotifyCharDropItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete item_;
  }
}

void NotifyCharDropItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCharDropItem& NotifyCharDropItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyCharDropItem* NotifyCharDropItem::default_instance_ = NULL;

NotifyCharDropItem* NotifyCharDropItem::New() const {
  return new NotifyCharDropItem;
}

void NotifyCharDropItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_item()) {
      if (item_ != NULL) item_->::Protocol::DropItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCharDropItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.DropItemInfo item = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCharDropItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.DropItemInfo item = 1;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item(), output);
  }

}

int NotifyCharDropItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.DropItemInfo item = 1;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCharDropItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCharDropItem*>(&from));
}

void NotifyCharDropItem::MergeFrom(const NotifyCharDropItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item()) {
      mutable_item()->::Protocol::DropItemInfo::MergeFrom(from.item());
    }
  }
}

void NotifyCharDropItem::CopyFrom(const NotifyCharDropItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCharDropItem::IsInitialized() const {

  return true;
}

void NotifyCharDropItem::Swap(NotifyCharDropItem* other) {
  if (other != this) {
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCharDropItem::GetTypeName() const {
  return "Protocol.NotifyCharDropItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyRemoveItemFromMap::kMapXFieldNumber;
const int NotifyRemoveItemFromMap::kMapYFieldNumber;
#endif  // !_MSC_VER

NotifyRemoveItemFromMap::NotifyRemoveItemFromMap()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyRemoveItemFromMap::InitAsDefaultInstance() {
}

NotifyRemoveItemFromMap::NotifyRemoveItemFromMap(const NotifyRemoveItemFromMap& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyRemoveItemFromMap::SharedCtor() {
  _cached_size_ = 0;
  map_x_ = 0;
  map_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRemoveItemFromMap::~NotifyRemoveItemFromMap() {
  SharedDtor();
}

void NotifyRemoveItemFromMap::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRemoveItemFromMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRemoveItemFromMap& NotifyRemoveItemFromMap::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyRemoveItemFromMap* NotifyRemoveItemFromMap::default_instance_ = NULL;

NotifyRemoveItemFromMap* NotifyRemoveItemFromMap::New() const {
  return new NotifyRemoveItemFromMap;
}

void NotifyRemoveItemFromMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_x_ = 0;
    map_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyRemoveItemFromMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 map_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_x_)));
          set_has_map_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_map_y;
        break;
      }

      // optional int32 map_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_y_)));
          set_has_map_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyRemoveItemFromMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 map_x = 1;
  if (has_map_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->map_x(), output);
  }

  // optional int32 map_y = 2;
  if (has_map_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->map_y(), output);
  }

}

int NotifyRemoveItemFromMap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 map_x = 1;
    if (has_map_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_x());
    }

    // optional int32 map_y = 2;
    if (has_map_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRemoveItemFromMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRemoveItemFromMap*>(&from));
}

void NotifyRemoveItemFromMap::MergeFrom(const NotifyRemoveItemFromMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_x()) {
      set_map_x(from.map_x());
    }
    if (from.has_map_y()) {
      set_map_y(from.map_y());
    }
  }
}

void NotifyRemoveItemFromMap::CopyFrom(const NotifyRemoveItemFromMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRemoveItemFromMap::IsInitialized() const {

  return true;
}

void NotifyRemoveItemFromMap::Swap(NotifyRemoveItemFromMap* other) {
  if (other != this) {
    std::swap(map_x_, other->map_x_);
    std::swap(map_y_, other->map_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRemoveItemFromMap::GetTypeName() const {
  return "Protocol.NotifyRemoveItemFromMap";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestPickupItem::kMapXFieldNumber;
const int RequestPickupItem::kMapYFieldNumber;
#endif  // !_MSC_VER

RequestPickupItem::RequestPickupItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestPickupItem::InitAsDefaultInstance() {
}

RequestPickupItem::RequestPickupItem(const RequestPickupItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestPickupItem::SharedCtor() {
  _cached_size_ = 0;
  map_x_ = 0;
  map_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestPickupItem::~RequestPickupItem() {
  SharedDtor();
}

void RequestPickupItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestPickupItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestPickupItem& RequestPickupItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestPickupItem* RequestPickupItem::default_instance_ = NULL;

RequestPickupItem* RequestPickupItem::New() const {
  return new RequestPickupItem;
}

void RequestPickupItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_x_ = 0;
    map_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestPickupItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 map_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_x_)));
          set_has_map_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_map_y;
        break;
      }

      // optional int32 map_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_y_)));
          set_has_map_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestPickupItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 map_x = 1;
  if (has_map_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->map_x(), output);
  }

  // optional int32 map_y = 2;
  if (has_map_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->map_y(), output);
  }

}

int RequestPickupItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 map_x = 1;
    if (has_map_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_x());
    }

    // optional int32 map_y = 2;
    if (has_map_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestPickupItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestPickupItem*>(&from));
}

void RequestPickupItem::MergeFrom(const RequestPickupItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_x()) {
      set_map_x(from.map_x());
    }
    if (from.has_map_y()) {
      set_map_y(from.map_y());
    }
  }
}

void RequestPickupItem::CopyFrom(const RequestPickupItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestPickupItem::IsInitialized() const {

  return true;
}

void RequestPickupItem::Swap(RequestPickupItem* other) {
  if (other != this) {
    std::swap(map_x_, other->map_x_);
    std::swap(map_y_, other->map_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestPickupItem::GetTypeName() const {
  return "Protocol.RequestPickupItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyPickupItem::kCharIdFieldNumber;
const int NotifyPickupItem::kMapXFieldNumber;
const int NotifyPickupItem::kMapYFieldNumber;
const int NotifyPickupItem::kItemIdFieldNumber;
#endif  // !_MSC_VER

NotifyPickupItem::NotifyPickupItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyPickupItem::InitAsDefaultInstance() {
}

NotifyPickupItem::NotifyPickupItem(const NotifyPickupItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyPickupItem::SharedCtor() {
  _cached_size_ = 0;
  char_id_ = 0;
  map_x_ = 0;
  map_y_ = 0;
  item_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyPickupItem::~NotifyPickupItem() {
  SharedDtor();
}

void NotifyPickupItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyPickupItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyPickupItem& NotifyPickupItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyPickupItem* NotifyPickupItem::default_instance_ = NULL;

NotifyPickupItem* NotifyPickupItem::New() const {
  return new NotifyPickupItem;
}

void NotifyPickupItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    char_id_ = 0;
    map_x_ = 0;
    map_y_ = 0;
    item_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyPickupItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 char_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &char_id_)));
          set_has_char_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_map_x;
        break;
      }

      // optional int32 map_x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_x_)));
          set_has_map_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_map_y;
        break;
      }

      // optional int32 map_y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_y_)));
          set_has_map_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_id;
        break;
      }

      // optional int32 item_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyPickupItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 char_id = 1;
  if (has_char_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->char_id(), output);
  }

  // optional int32 map_x = 2;
  if (has_map_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->map_x(), output);
  }

  // optional int32 map_y = 3;
  if (has_map_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->map_y(), output);
  }

  // optional int32 item_id = 4;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->item_id(), output);
  }

}

int NotifyPickupItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 char_id = 1;
    if (has_char_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->char_id());
    }

    // optional int32 map_x = 2;
    if (has_map_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_x());
    }

    // optional int32 map_y = 3;
    if (has_map_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_y());
    }

    // optional int32 item_id = 4;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyPickupItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyPickupItem*>(&from));
}

void NotifyPickupItem::MergeFrom(const NotifyPickupItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_char_id()) {
      set_char_id(from.char_id());
    }
    if (from.has_map_x()) {
      set_map_x(from.map_x());
    }
    if (from.has_map_y()) {
      set_map_y(from.map_y());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
  }
}

void NotifyPickupItem::CopyFrom(const NotifyPickupItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyPickupItem::IsInitialized() const {

  return true;
}

void NotifyPickupItem::Swap(NotifyPickupItem* other) {
  if (other != this) {
    std::swap(char_id_, other->char_id_);
    std::swap(map_x_, other->map_x_);
    std::swap(map_y_, other->map_y_);
    std::swap(item_id_, other->item_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyPickupItem::GetTypeName() const {
  return "Protocol.NotifyPickupItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestEquipItem::kSrcLocFieldNumber;
#endif  // !_MSC_VER

RequestEquipItem::RequestEquipItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestEquipItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  src_loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  src_loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

RequestEquipItem::RequestEquipItem(const RequestEquipItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestEquipItem::SharedCtor() {
  _cached_size_ = 0;
  src_loc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestEquipItem::~RequestEquipItem() {
  SharedDtor();
}

void RequestEquipItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete src_loc_;
  }
}

void RequestEquipItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestEquipItem& RequestEquipItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestEquipItem* RequestEquipItem::default_instance_ = NULL;

RequestEquipItem* RequestEquipItem::New() const {
  return new RequestEquipItem;
}

void RequestEquipItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_src_loc()) {
      if (src_loc_ != NULL) src_loc_->::ItemLoc::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestEquipItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc src_loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_src_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestEquipItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc src_loc = 1;
  if (has_src_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->src_loc(), output);
  }

}

int RequestEquipItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc src_loc = 1;
    if (has_src_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->src_loc());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestEquipItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestEquipItem*>(&from));
}

void RequestEquipItem::MergeFrom(const RequestEquipItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_src_loc()) {
      mutable_src_loc()->::ItemLoc::MergeFrom(from.src_loc());
    }
  }
}

void RequestEquipItem::CopyFrom(const RequestEquipItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestEquipItem::IsInitialized() const {

  return true;
}

void RequestEquipItem::Swap(RequestEquipItem* other) {
  if (other != this) {
    std::swap(src_loc_, other->src_loc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestEquipItem::GetTypeName() const {
  return "Protocol.RequestEquipItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseEquipItem::kSrcLocFieldNumber;
const int ResponseEquipItem::kDestLocFieldNumber;
#endif  // !_MSC_VER

ResponseEquipItem::ResponseEquipItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseEquipItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  src_loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  src_loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dest_loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  dest_loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

ResponseEquipItem::ResponseEquipItem(const ResponseEquipItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseEquipItem::SharedCtor() {
  _cached_size_ = 0;
  src_loc_ = NULL;
  dest_loc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseEquipItem::~ResponseEquipItem() {
  SharedDtor();
}

void ResponseEquipItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete src_loc_;
    delete dest_loc_;
  }
}

void ResponseEquipItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseEquipItem& ResponseEquipItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseEquipItem* ResponseEquipItem::default_instance_ = NULL;

ResponseEquipItem* ResponseEquipItem::New() const {
  return new ResponseEquipItem;
}

void ResponseEquipItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_src_loc()) {
      if (src_loc_ != NULL) src_loc_->::ItemLoc::Clear();
    }
    if (has_dest_loc()) {
      if (dest_loc_ != NULL) dest_loc_->::ItemLoc::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseEquipItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc src_loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_src_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_dest_loc;
        break;
      }

      // optional .ItemLoc dest_loc = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_dest_loc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dest_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseEquipItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc src_loc = 1;
  if (has_src_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->src_loc(), output);
  }

  // optional .ItemLoc dest_loc = 2;
  if (has_dest_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->dest_loc(), output);
  }

}

int ResponseEquipItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc src_loc = 1;
    if (has_src_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->src_loc());
    }

    // optional .ItemLoc dest_loc = 2;
    if (has_dest_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->dest_loc());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseEquipItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseEquipItem*>(&from));
}

void ResponseEquipItem::MergeFrom(const ResponseEquipItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_src_loc()) {
      mutable_src_loc()->::ItemLoc::MergeFrom(from.src_loc());
    }
    if (from.has_dest_loc()) {
      mutable_dest_loc()->::ItemLoc::MergeFrom(from.dest_loc());
    }
  }
}

void ResponseEquipItem::CopyFrom(const ResponseEquipItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseEquipItem::IsInitialized() const {

  return true;
}

void ResponseEquipItem::Swap(ResponseEquipItem* other) {
  if (other != this) {
    std::swap(src_loc_, other->src_loc_);
    std::swap(dest_loc_, other->dest_loc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseEquipItem::GetTypeName() const {
  return "Protocol.ResponseEquipItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyAddItem::kItemListFieldNumber;
#endif  // !_MSC_VER

NotifyAddItem::NotifyAddItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyAddItem::InitAsDefaultInstance() {
}

NotifyAddItem::NotifyAddItem(const NotifyAddItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyAddItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyAddItem::~NotifyAddItem() {
  SharedDtor();
}

void NotifyAddItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyAddItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyAddItem& NotifyAddItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyAddItem* NotifyAddItem::default_instance_ = NULL;

NotifyAddItem* NotifyAddItem::New() const {
  return new NotifyAddItem;
}

void NotifyAddItem::Clear() {
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyAddItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ItemLocData item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyAddItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ItemLocData item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

}

int NotifyAddItem::ByteSize() const {
  int total_size = 0;

  // repeated .ItemLocData item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyAddItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyAddItem*>(&from));
}

void NotifyAddItem::MergeFrom(const NotifyAddItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
}

void NotifyAddItem::CopyFrom(const NotifyAddItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyAddItem::IsInitialized() const {

  return true;
}

void NotifyAddItem::Swap(NotifyAddItem* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyAddItem::GetTypeName() const {
  return "Protocol.NotifyAddItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyRemoveItem::kLocListFieldNumber;
#endif  // !_MSC_VER

NotifyRemoveItem::NotifyRemoveItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyRemoveItem::InitAsDefaultInstance() {
}

NotifyRemoveItem::NotifyRemoveItem(const NotifyRemoveItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyRemoveItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRemoveItem::~NotifyRemoveItem() {
  SharedDtor();
}

void NotifyRemoveItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRemoveItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRemoveItem& NotifyRemoveItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyRemoveItem* NotifyRemoveItem::default_instance_ = NULL;

NotifyRemoveItem* NotifyRemoveItem::New() const {
  return new NotifyRemoveItem;
}

void NotifyRemoveItem::Clear() {
  loc_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyRemoveItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ItemLoc loc_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loc_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_loc_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_loc_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyRemoveItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ItemLoc loc_list = 1;
  for (int i = 0; i < this->loc_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc_list(i), output);
  }

}

int NotifyRemoveItem::ByteSize() const {
  int total_size = 0;

  // repeated .ItemLoc loc_list = 1;
  total_size += 1 * this->loc_list_size();
  for (int i = 0; i < this->loc_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->loc_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRemoveItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRemoveItem*>(&from));
}

void NotifyRemoveItem::MergeFrom(const NotifyRemoveItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  loc_list_.MergeFrom(from.loc_list_);
}

void NotifyRemoveItem::CopyFrom(const NotifyRemoveItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRemoveItem::IsInitialized() const {

  return true;
}

void NotifyRemoveItem::Swap(NotifyRemoveItem* other) {
  if (other != this) {
    loc_list_.Swap(&other->loc_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRemoveItem::GetTypeName() const {
  return "Protocol.NotifyRemoveItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyReplaceItem::kItemListFieldNumber;
const int NotifyReplaceItem::kIsNewItemFieldNumber;
#endif  // !_MSC_VER

NotifyReplaceItem::NotifyReplaceItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyReplaceItem::InitAsDefaultInstance() {
}

NotifyReplaceItem::NotifyReplaceItem(const NotifyReplaceItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyReplaceItem::SharedCtor() {
  _cached_size_ = 0;
  is_new_item_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyReplaceItem::~NotifyReplaceItem() {
  SharedDtor();
}

void NotifyReplaceItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyReplaceItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyReplaceItem& NotifyReplaceItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyReplaceItem* NotifyReplaceItem::default_instance_ = NULL;

NotifyReplaceItem* NotifyReplaceItem::New() const {
  return new NotifyReplaceItem;
}

void NotifyReplaceItem::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    is_new_item_ = true;
  }
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyReplaceItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ItemLocData item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectTag(16)) goto parse_is_new_item;
        break;
      }

      // optional bool is_new_item = 2 [default = true];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_new_item:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_new_item_)));
          set_has_is_new_item();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyReplaceItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ItemLocData item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

  // optional bool is_new_item = 2 [default = true];
  if (has_is_new_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_new_item(), output);
  }

}

int NotifyReplaceItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bool is_new_item = 2 [default = true];
    if (has_is_new_item()) {
      total_size += 1 + 1;
    }

  }
  // repeated .ItemLocData item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyReplaceItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyReplaceItem*>(&from));
}

void NotifyReplaceItem::MergeFrom(const NotifyReplaceItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_is_new_item()) {
      set_is_new_item(from.is_new_item());
    }
  }
}

void NotifyReplaceItem::CopyFrom(const NotifyReplaceItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyReplaceItem::IsInitialized() const {

  return true;
}

void NotifyReplaceItem::Swap(NotifyReplaceItem* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(is_new_item_, other->is_new_item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyReplaceItem::GetTypeName() const {
  return "Protocol.NotifyReplaceItem";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyRefreshPackage::kPkgFieldNumber;
const int NotifyRefreshPackage::kItemListFieldNumber;
#endif  // !_MSC_VER

NotifyRefreshPackage::NotifyRefreshPackage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyRefreshPackage::InitAsDefaultInstance() {
}

NotifyRefreshPackage::NotifyRefreshPackage(const NotifyRefreshPackage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyRefreshPackage::SharedCtor() {
  _cached_size_ = 0;
  pkg_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRefreshPackage::~NotifyRefreshPackage() {
  SharedDtor();
}

void NotifyRefreshPackage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRefreshPackage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRefreshPackage& NotifyRefreshPackage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

NotifyRefreshPackage* NotifyRefreshPackage::default_instance_ = NULL;

NotifyRefreshPackage* NotifyRefreshPackage::New() const {
  return new NotifyRefreshPackage;
}

void NotifyRefreshPackage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pkg_ = 0;
  }
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyRefreshPackage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 pkg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pkg_)));
          set_has_pkg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_item_list;
        break;
      }

      // repeated .ItemData item_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyRefreshPackage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 pkg = 1;
  if (has_pkg()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->pkg(), output);
  }

  // repeated .ItemData item_list = 2;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->item_list(i), output);
  }

}

int NotifyRefreshPackage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 pkg = 1;
    if (has_pkg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pkg());
    }

  }
  // repeated .ItemData item_list = 2;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRefreshPackage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRefreshPackage*>(&from));
}

void NotifyRefreshPackage::MergeFrom(const NotifyRefreshPackage& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pkg()) {
      set_pkg(from.pkg());
    }
  }
}

void NotifyRefreshPackage::CopyFrom(const NotifyRefreshPackage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRefreshPackage::IsInitialized() const {

  return true;
}

void NotifyRefreshPackage::Swap(NotifyRefreshPackage* other) {
  if (other != this) {
    std::swap(pkg_, other->pkg_);
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRefreshPackage::GetTypeName() const {
  return "Protocol.NotifyRefreshPackage";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUseItem::kLocFieldNumber;
#endif  // !_MSC_VER

RequestUseItem::RequestUseItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestUseItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

RequestUseItem::RequestUseItem(const RequestUseItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestUseItem::SharedCtor() {
  _cached_size_ = 0;
  loc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUseItem::~RequestUseItem() {
  SharedDtor();
}

void RequestUseItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_;
  }
}

void RequestUseItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUseItem& RequestUseItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestUseItem* RequestUseItem::default_instance_ = NULL;

RequestUseItem* RequestUseItem::New() const {
  return new RequestUseItem;
}

void RequestUseItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc()) {
      if (loc_ != NULL) loc_->::ItemLoc::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestUseItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestUseItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc loc = 1;
  if (has_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc(), output);
  }

}

int RequestUseItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc loc = 1;
    if (has_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUseItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUseItem*>(&from));
}

void RequestUseItem::MergeFrom(const RequestUseItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc()) {
      mutable_loc()->::ItemLoc::MergeFrom(from.loc());
    }
  }
}

void RequestUseItem::CopyFrom(const RequestUseItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUseItem::IsInitialized() const {

  return true;
}

void RequestUseItem::Swap(RequestUseItem* other) {
  if (other != this) {
    std::swap(loc_, other->loc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUseItem::GetTypeName() const {
  return "Protocol.RequestUseItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseUseItem::kLocFieldNumber;
#endif  // !_MSC_VER

ResponseUseItem::ResponseUseItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseUseItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

ResponseUseItem::ResponseUseItem(const ResponseUseItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseUseItem::SharedCtor() {
  _cached_size_ = 0;
  loc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseUseItem::~ResponseUseItem() {
  SharedDtor();
}

void ResponseUseItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_;
  }
}

void ResponseUseItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseUseItem& ResponseUseItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseUseItem* ResponseUseItem::default_instance_ = NULL;

ResponseUseItem* ResponseUseItem::New() const {
  return new ResponseUseItem;
}

void ResponseUseItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc()) {
      if (loc_ != NULL) loc_->::ItemLoc::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseUseItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseUseItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc loc = 1;
  if (has_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc(), output);
  }

}

int ResponseUseItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc loc = 1;
    if (has_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseUseItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseUseItem*>(&from));
}

void ResponseUseItem::MergeFrom(const ResponseUseItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc()) {
      mutable_loc()->::ItemLoc::MergeFrom(from.loc());
    }
  }
}

void ResponseUseItem::CopyFrom(const ResponseUseItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseUseItem::IsInitialized() const {

  return true;
}

void ResponseUseItem::Swap(ResponseUseItem* other) {
  if (other != this) {
    std::swap(loc_, other->loc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseUseItem::GetTypeName() const {
  return "Protocol.ResponseUseItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBuyPackagePrice::kPkgFieldNumber;
const int RequestGetBuyPackagePrice::kBuyNumFieldNumber;
#endif  // !_MSC_VER

RequestGetBuyPackagePrice::RequestGetBuyPackagePrice()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetBuyPackagePrice::InitAsDefaultInstance() {
}

RequestGetBuyPackagePrice::RequestGetBuyPackagePrice(const RequestGetBuyPackagePrice& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetBuyPackagePrice::SharedCtor() {
  _cached_size_ = 0;
  pkg_ = 0;
  buy_num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBuyPackagePrice::~RequestGetBuyPackagePrice() {
  SharedDtor();
}

void RequestGetBuyPackagePrice::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBuyPackagePrice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBuyPackagePrice& RequestGetBuyPackagePrice::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestGetBuyPackagePrice* RequestGetBuyPackagePrice::default_instance_ = NULL;

RequestGetBuyPackagePrice* RequestGetBuyPackagePrice::New() const {
  return new RequestGetBuyPackagePrice;
}

void RequestGetBuyPackagePrice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pkg_ = 0;
    buy_num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetBuyPackagePrice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 pkg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pkg_)));
          set_has_pkg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_buy_num;
        break;
      }

      // optional int32 buy_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buy_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &buy_num_)));
          set_has_buy_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetBuyPackagePrice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 pkg = 1;
  if (has_pkg()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->pkg(), output);
  }

  // optional int32 buy_num = 2;
  if (has_buy_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->buy_num(), output);
  }

}

int RequestGetBuyPackagePrice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 pkg = 1;
    if (has_pkg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pkg());
    }

    // optional int32 buy_num = 2;
    if (has_buy_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->buy_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBuyPackagePrice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBuyPackagePrice*>(&from));
}

void RequestGetBuyPackagePrice::MergeFrom(const RequestGetBuyPackagePrice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pkg()) {
      set_pkg(from.pkg());
    }
    if (from.has_buy_num()) {
      set_buy_num(from.buy_num());
    }
  }
}

void RequestGetBuyPackagePrice::CopyFrom(const RequestGetBuyPackagePrice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBuyPackagePrice::IsInitialized() const {

  return true;
}

void RequestGetBuyPackagePrice::Swap(RequestGetBuyPackagePrice* other) {
  if (other != this) {
    std::swap(pkg_, other->pkg_);
    std::swap(buy_num_, other->buy_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBuyPackagePrice::GetTypeName() const {
  return "Protocol.RequestGetBuyPackagePrice";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetBuyPackagePrice::kPkgFieldNumber;
const int ResponseGetBuyPackagePrice::kBuyNumFieldNumber;
const int ResponseGetBuyPackagePrice::kPriceFieldNumber;
#endif  // !_MSC_VER

ResponseGetBuyPackagePrice::ResponseGetBuyPackagePrice()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetBuyPackagePrice::InitAsDefaultInstance() {
}

ResponseGetBuyPackagePrice::ResponseGetBuyPackagePrice(const ResponseGetBuyPackagePrice& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetBuyPackagePrice::SharedCtor() {
  _cached_size_ = 0;
  pkg_ = 0;
  buy_num_ = 0;
  price_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetBuyPackagePrice::~ResponseGetBuyPackagePrice() {
  SharedDtor();
}

void ResponseGetBuyPackagePrice::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetBuyPackagePrice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetBuyPackagePrice& ResponseGetBuyPackagePrice::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseGetBuyPackagePrice* ResponseGetBuyPackagePrice::default_instance_ = NULL;

ResponseGetBuyPackagePrice* ResponseGetBuyPackagePrice::New() const {
  return new ResponseGetBuyPackagePrice;
}

void ResponseGetBuyPackagePrice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pkg_ = 0;
    buy_num_ = 0;
    price_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetBuyPackagePrice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 pkg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pkg_)));
          set_has_pkg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_buy_num;
        break;
      }

      // optional int32 buy_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buy_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &buy_num_)));
          set_has_buy_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_price;
        break;
      }

      // optional int32 price = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetBuyPackagePrice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 pkg = 1;
  if (has_pkg()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->pkg(), output);
  }

  // optional int32 buy_num = 2;
  if (has_buy_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->buy_num(), output);
  }

  // optional int32 price = 3;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->price(), output);
  }

}

int ResponseGetBuyPackagePrice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 pkg = 1;
    if (has_pkg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pkg());
    }

    // optional int32 buy_num = 2;
    if (has_buy_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->buy_num());
    }

    // optional int32 price = 3;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetBuyPackagePrice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetBuyPackagePrice*>(&from));
}

void ResponseGetBuyPackagePrice::MergeFrom(const ResponseGetBuyPackagePrice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pkg()) {
      set_pkg(from.pkg());
    }
    if (from.has_buy_num()) {
      set_buy_num(from.buy_num());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
  }
}

void ResponseGetBuyPackagePrice::CopyFrom(const ResponseGetBuyPackagePrice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetBuyPackagePrice::IsInitialized() const {

  return true;
}

void ResponseGetBuyPackagePrice::Swap(ResponseGetBuyPackagePrice* other) {
  if (other != this) {
    std::swap(pkg_, other->pkg_);
    std::swap(buy_num_, other->buy_num_);
    std::swap(price_, other->price_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetBuyPackagePrice::GetTypeName() const {
  return "Protocol.ResponseGetBuyPackagePrice";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestBuyPackageSize::kPkgFieldNumber;
const int RequestBuyPackageSize::kBuyNumFieldNumber;
#endif  // !_MSC_VER

RequestBuyPackageSize::RequestBuyPackageSize()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestBuyPackageSize::InitAsDefaultInstance() {
}

RequestBuyPackageSize::RequestBuyPackageSize(const RequestBuyPackageSize& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestBuyPackageSize::SharedCtor() {
  _cached_size_ = 0;
  pkg_ = 0;
  buy_num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBuyPackageSize::~RequestBuyPackageSize() {
  SharedDtor();
}

void RequestBuyPackageSize::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBuyPackageSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBuyPackageSize& RequestBuyPackageSize::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestBuyPackageSize* RequestBuyPackageSize::default_instance_ = NULL;

RequestBuyPackageSize* RequestBuyPackageSize::New() const {
  return new RequestBuyPackageSize;
}

void RequestBuyPackageSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pkg_ = 0;
    buy_num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestBuyPackageSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 pkg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pkg_)));
          set_has_pkg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_buy_num;
        break;
      }

      // optional int32 buy_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buy_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &buy_num_)));
          set_has_buy_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestBuyPackageSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 pkg = 1;
  if (has_pkg()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->pkg(), output);
  }

  // optional int32 buy_num = 2;
  if (has_buy_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->buy_num(), output);
  }

}

int RequestBuyPackageSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 pkg = 1;
    if (has_pkg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pkg());
    }

    // optional int32 buy_num = 2;
    if (has_buy_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->buy_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBuyPackageSize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBuyPackageSize*>(&from));
}

void RequestBuyPackageSize::MergeFrom(const RequestBuyPackageSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pkg()) {
      set_pkg(from.pkg());
    }
    if (from.has_buy_num()) {
      set_buy_num(from.buy_num());
    }
  }
}

void RequestBuyPackageSize::CopyFrom(const RequestBuyPackageSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBuyPackageSize::IsInitialized() const {

  return true;
}

void RequestBuyPackageSize::Swap(RequestBuyPackageSize* other) {
  if (other != this) {
    std::swap(pkg_, other->pkg_);
    std::swap(buy_num_, other->buy_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBuyPackageSize::GetTypeName() const {
  return "Protocol.RequestBuyPackageSize";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseBuyPackageSize::kResultFieldNumber;
const int ResponseBuyPackageSize::kPkgFieldNumber;
const int ResponseBuyPackageSize::kCurNumFieldNumber;
#endif  // !_MSC_VER

ResponseBuyPackageSize::ResponseBuyPackageSize()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseBuyPackageSize::InitAsDefaultInstance() {
}

ResponseBuyPackageSize::ResponseBuyPackageSize(const ResponseBuyPackageSize& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseBuyPackageSize::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  pkg_ = 0;
  cur_num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseBuyPackageSize::~ResponseBuyPackageSize() {
  SharedDtor();
}

void ResponseBuyPackageSize::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseBuyPackageSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseBuyPackageSize& ResponseBuyPackageSize::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseBuyPackageSize* ResponseBuyPackageSize::default_instance_ = NULL;

ResponseBuyPackageSize* ResponseBuyPackageSize::New() const {
  return new ResponseBuyPackageSize;
}

void ResponseBuyPackageSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    pkg_ = 0;
    cur_num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseBuyPackageSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pkg;
        break;
      }

      // optional int32 pkg = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pkg:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pkg_)));
          set_has_pkg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_cur_num;
        break;
      }

      // optional int32 cur_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cur_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cur_num_)));
          set_has_cur_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseBuyPackageSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional int32 pkg = 2;
  if (has_pkg()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->pkg(), output);
  }

  // optional int32 cur_num = 3;
  if (has_cur_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->cur_num(), output);
  }

}

int ResponseBuyPackageSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional int32 pkg = 2;
    if (has_pkg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pkg());
    }

    // optional int32 cur_num = 3;
    if (has_cur_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cur_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseBuyPackageSize::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseBuyPackageSize*>(&from));
}

void ResponseBuyPackageSize::MergeFrom(const ResponseBuyPackageSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_pkg()) {
      set_pkg(from.pkg());
    }
    if (from.has_cur_num()) {
      set_cur_num(from.cur_num());
    }
  }
}

void ResponseBuyPackageSize::CopyFrom(const ResponseBuyPackageSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseBuyPackageSize::IsInitialized() const {

  return true;
}

void ResponseBuyPackageSize::Swap(ResponseBuyPackageSize* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(pkg_, other->pkg_);
    std::swap(cur_num_, other->cur_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseBuyPackageSize::GetTypeName() const {
  return "Protocol.ResponseBuyPackageSize";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSortPackage::kPkgFieldNumber;
#endif  // !_MSC_VER

RequestSortPackage::RequestSortPackage()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestSortPackage::InitAsDefaultInstance() {
}

RequestSortPackage::RequestSortPackage(const RequestSortPackage& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestSortPackage::SharedCtor() {
  _cached_size_ = 0;
  pkg_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSortPackage::~RequestSortPackage() {
  SharedDtor();
}

void RequestSortPackage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSortPackage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSortPackage& RequestSortPackage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestSortPackage* RequestSortPackage::default_instance_ = NULL;

RequestSortPackage* RequestSortPackage::New() const {
  return new RequestSortPackage;
}

void RequestSortPackage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pkg_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestSortPackage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 pkg = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pkg_)));
          set_has_pkg();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestSortPackage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 pkg = 1;
  if (has_pkg()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->pkg(), output);
  }

}

int RequestSortPackage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 pkg = 1;
    if (has_pkg()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pkg());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSortPackage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSortPackage*>(&from));
}

void RequestSortPackage::MergeFrom(const RequestSortPackage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pkg()) {
      set_pkg(from.pkg());
    }
  }
}

void RequestSortPackage::CopyFrom(const RequestSortPackage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSortPackage::IsInitialized() const {

  return true;
}

void RequestSortPackage::Swap(RequestSortPackage* other) {
  if (other != this) {
    std::swap(pkg_, other->pkg_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSortPackage::GetTypeName() const {
  return "Protocol.RequestSortPackage";
}


// ===================================================================

#ifndef _MSC_VER
const int StoreItem::kItemidFieldNumber;
const int StoreItem::kPriceFieldNumber;
#endif  // !_MSC_VER

StoreItem::StoreItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StoreItem::InitAsDefaultInstance() {
}

StoreItem::StoreItem(const StoreItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StoreItem::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  price_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StoreItem::~StoreItem() {
  SharedDtor();
}

void StoreItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StoreItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StoreItem& StoreItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

StoreItem* StoreItem::default_instance_ = NULL;

StoreItem* StoreItem::New() const {
  return new StoreItem;
}

void StoreItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0;
    price_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StoreItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 itemid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_price;
        break;
      }

      // optional int32 price = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &price_)));
          set_has_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StoreItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 itemid = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 price = 2;
  if (has_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->price(), output);
  }

}

int StoreItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 itemid = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 price = 2;
    if (has_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->price());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StoreItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StoreItem*>(&from));
}

void StoreItem::MergeFrom(const StoreItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_price()) {
      set_price(from.price());
    }
  }
}

void StoreItem::CopyFrom(const StoreItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StoreItem::IsInitialized() const {

  return true;
}

void StoreItem::Swap(StoreItem* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(price_, other->price_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StoreItem::GetTypeName() const {
  return "Protocol.StoreItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetStoreItem::kNpcidFieldNumber;
#endif  // !_MSC_VER

RequestGetStoreItem::RequestGetStoreItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetStoreItem::InitAsDefaultInstance() {
}

RequestGetStoreItem::RequestGetStoreItem(const RequestGetStoreItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetStoreItem::SharedCtor() {
  _cached_size_ = 0;
  npcid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetStoreItem::~RequestGetStoreItem() {
  SharedDtor();
}

void RequestGetStoreItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetStoreItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetStoreItem& RequestGetStoreItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestGetStoreItem* RequestGetStoreItem::default_instance_ = NULL;

RequestGetStoreItem* RequestGetStoreItem::New() const {
  return new RequestGetStoreItem;
}

void RequestGetStoreItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    npcid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetStoreItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 npcid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &npcid_)));
          set_has_npcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetStoreItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 npcid = 1;
  if (has_npcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->npcid(), output);
  }

}

int RequestGetStoreItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 npcid = 1;
    if (has_npcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->npcid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetStoreItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetStoreItem*>(&from));
}

void RequestGetStoreItem::MergeFrom(const RequestGetStoreItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_npcid()) {
      set_npcid(from.npcid());
    }
  }
}

void RequestGetStoreItem::CopyFrom(const RequestGetStoreItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetStoreItem::IsInitialized() const {

  return true;
}

void RequestGetStoreItem::Swap(RequestGetStoreItem* other) {
  if (other != this) {
    std::swap(npcid_, other->npcid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetStoreItem::GetTypeName() const {
  return "Protocol.RequestGetStoreItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetStoreItem::kTypeFieldNumber;
const int ResponseGetStoreItem::kItemListFieldNumber;
#endif  // !_MSC_VER

ResponseGetStoreItem::ResponseGetStoreItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetStoreItem::InitAsDefaultInstance() {
}

ResponseGetStoreItem::ResponseGetStoreItem(const ResponseGetStoreItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetStoreItem::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetStoreItem::~ResponseGetStoreItem() {
  SharedDtor();
}

void ResponseGetStoreItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetStoreItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetStoreItem& ResponseGetStoreItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseGetStoreItem* ResponseGetStoreItem::default_instance_ = NULL;

ResponseGetStoreItem* ResponseGetStoreItem::New() const {
  return new ResponseGetStoreItem;
}

void ResponseGetStoreItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
  }
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetStoreItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.StoreCurrencyType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::StoreCurrencyType_IsValid(value)) {
            set_type(static_cast< ::Protocol::StoreCurrencyType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_item_list;
        break;
      }

      // repeated .Protocol.StoreItem item_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetStoreItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.StoreCurrencyType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // repeated .Protocol.StoreItem item_list = 2;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->item_list(i), output);
  }

}

int ResponseGetStoreItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.StoreCurrencyType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  // repeated .Protocol.StoreItem item_list = 2;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetStoreItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetStoreItem*>(&from));
}

void ResponseGetStoreItem::MergeFrom(const ResponseGetStoreItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ResponseGetStoreItem::CopyFrom(const ResponseGetStoreItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetStoreItem::IsInitialized() const {

  return true;
}

void ResponseGetStoreItem::Swap(ResponseGetStoreItem* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetStoreItem::GetTypeName() const {
  return "Protocol.ResponseGetStoreItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestBuyStoreItem::kItemidFieldNumber;
const int RequestBuyStoreItem::kNumFieldNumber;
const int RequestBuyStoreItem::kMoneyFieldNumber;
#endif  // !_MSC_VER

RequestBuyStoreItem::RequestBuyStoreItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestBuyStoreItem::InitAsDefaultInstance() {
}

RequestBuyStoreItem::RequestBuyStoreItem(const RequestBuyStoreItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestBuyStoreItem::SharedCtor() {
  _cached_size_ = 0;
  itemid_ = 0;
  num_ = 0;
  money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBuyStoreItem::~RequestBuyStoreItem() {
  SharedDtor();
}

void RequestBuyStoreItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBuyStoreItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBuyStoreItem& RequestBuyStoreItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestBuyStoreItem* RequestBuyStoreItem::default_instance_ = NULL;

RequestBuyStoreItem* RequestBuyStoreItem::New() const {
  return new RequestBuyStoreItem;
}

void RequestBuyStoreItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    itemid_ = 0;
    num_ = 0;
    money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestBuyStoreItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 itemid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // optional int32 num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_money;
        break;
      }

      // optional int32 money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestBuyStoreItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 itemid = 1;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->itemid(), output);
  }

  // optional int32 num = 2;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

  // optional int32 money = 3;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->money(), output);
  }

}

int RequestBuyStoreItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 itemid = 1;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 num = 2;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional int32 money = 3;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBuyStoreItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBuyStoreItem*>(&from));
}

void RequestBuyStoreItem::MergeFrom(const RequestBuyStoreItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void RequestBuyStoreItem::CopyFrom(const RequestBuyStoreItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBuyStoreItem::IsInitialized() const {

  return true;
}

void RequestBuyStoreItem::Swap(RequestBuyStoreItem* other) {
  if (other != this) {
    std::swap(itemid_, other->itemid_);
    std::swap(num_, other->num_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBuyStoreItem::GetTypeName() const {
  return "Protocol.RequestBuyStoreItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseBuyStoreItem::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseBuyStoreItem::ResponseBuyStoreItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseBuyStoreItem::InitAsDefaultInstance() {
}

ResponseBuyStoreItem::ResponseBuyStoreItem(const ResponseBuyStoreItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseBuyStoreItem::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseBuyStoreItem::~ResponseBuyStoreItem() {
  SharedDtor();
}

void ResponseBuyStoreItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseBuyStoreItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseBuyStoreItem& ResponseBuyStoreItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseBuyStoreItem* ResponseBuyStoreItem::default_instance_ = NULL;

ResponseBuyStoreItem* ResponseBuyStoreItem::New() const {
  return new ResponseBuyStoreItem;
}

void ResponseBuyStoreItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseBuyStoreItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseBuyStoreItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseBuyStoreItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseBuyStoreItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseBuyStoreItem*>(&from));
}

void ResponseBuyStoreItem::MergeFrom(const ResponseBuyStoreItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseBuyStoreItem::CopyFrom(const ResponseBuyStoreItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseBuyStoreItem::IsInitialized() const {

  return true;
}

void ResponseBuyStoreItem::Swap(ResponseBuyStoreItem* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseBuyStoreItem::GetTypeName() const {
  return "Protocol.ResponseBuyStoreItem";
}


// ===================================================================

#ifndef _MSC_VER
const int SellItemInfo::kLocFieldNumber;
const int SellItemInfo::kNumFieldNumber;
#endif  // !_MSC_VER

SellItemInfo::SellItemInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void SellItemInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

SellItemInfo::SellItemInfo(const SellItemInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void SellItemInfo::SharedCtor() {
  _cached_size_ = 0;
  loc_ = NULL;
  num_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SellItemInfo::~SellItemInfo() {
  SharedDtor();
}

void SellItemInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_;
  }
}

void SellItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SellItemInfo& SellItemInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

SellItemInfo* SellItemInfo::default_instance_ = NULL;

SellItemInfo* SellItemInfo::New() const {
  return new SellItemInfo;
}

void SellItemInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc()) {
      if (loc_ != NULL) loc_->::ItemLoc::Clear();
    }
    num_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool SellItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // optional int32 num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SellItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc loc = 1;
  if (has_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc(), output);
  }

  // optional int32 num = 2;
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

}

int SellItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc loc = 1;
    if (has_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc());
    }

    // optional int32 num = 2;
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SellItemInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SellItemInfo*>(&from));
}

void SellItemInfo::MergeFrom(const SellItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc()) {
      mutable_loc()->::ItemLoc::MergeFrom(from.loc());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
  }
}

void SellItemInfo::CopyFrom(const SellItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SellItemInfo::IsInitialized() const {

  return true;
}

void SellItemInfo::Swap(SellItemInfo* other) {
  if (other != this) {
    std::swap(loc_, other->loc_);
    std::swap(num_, other->num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string SellItemInfo::GetTypeName() const {
  return "Protocol.SellItemInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestSellItem::kItemListFieldNumber;
const int RequestSellItem::kMoneyFieldNumber;
#endif  // !_MSC_VER

RequestSellItem::RequestSellItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestSellItem::InitAsDefaultInstance() {
}

RequestSellItem::RequestSellItem(const RequestSellItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestSellItem::SharedCtor() {
  _cached_size_ = 0;
  money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestSellItem::~RequestSellItem() {
  SharedDtor();
}

void RequestSellItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestSellItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestSellItem& RequestSellItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestSellItem* RequestSellItem::default_instance_ = NULL;

RequestSellItem* RequestSellItem::New() const {
  return new RequestSellItem;
}

void RequestSellItem::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    money_ = 0;
  }
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestSellItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.SellItemInfo item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectTag(16)) goto parse_money;
        break;
      }

      // optional int32 money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestSellItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.SellItemInfo item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

  // optional int32 money = 2;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->money(), output);
  }

}

int RequestSellItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 money = 2;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  // repeated .Protocol.SellItemInfo item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestSellItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestSellItem*>(&from));
}

void RequestSellItem::MergeFrom(const RequestSellItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void RequestSellItem::CopyFrom(const RequestSellItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestSellItem::IsInitialized() const {

  return true;
}

void RequestSellItem::Swap(RequestSellItem* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestSellItem::GetTypeName() const {
  return "Protocol.RequestSellItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseSellItem::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseSellItem::ResponseSellItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseSellItem::InitAsDefaultInstance() {
}

ResponseSellItem::ResponseSellItem(const ResponseSellItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseSellItem::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseSellItem::~ResponseSellItem() {
  SharedDtor();
}

void ResponseSellItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseSellItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseSellItem& ResponseSellItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseSellItem* ResponseSellItem::default_instance_ = NULL;

ResponseSellItem* ResponseSellItem::New() const {
  return new ResponseSellItem;
}

void ResponseSellItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseSellItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseSellItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseSellItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseSellItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseSellItem*>(&from));
}

void ResponseSellItem::MergeFrom(const ResponseSellItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseSellItem::CopyFrom(const ResponseSellItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseSellItem::IsInitialized() const {

  return true;
}

void ResponseSellItem::Swap(ResponseSellItem* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseSellItem::GetTypeName() const {
  return "Protocol.ResponseSellItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetSafeItems::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestGetSafeItems::RequestGetSafeItems()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetSafeItems::InitAsDefaultInstance() {
}

RequestGetSafeItems::RequestGetSafeItems(const RequestGetSafeItems& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetSafeItems::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetSafeItems::~RequestGetSafeItems() {
  SharedDtor();
}

void RequestGetSafeItems::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetSafeItems::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetSafeItems& RequestGetSafeItems::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestGetSafeItems* RequestGetSafeItems::default_instance_ = NULL;

RequestGetSafeItems* RequestGetSafeItems::New() const {
  return new RequestGetSafeItems;
}

void RequestGetSafeItems::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetSafeItems::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetSafeItems::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestGetSafeItems::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetSafeItems::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetSafeItems*>(&from));
}

void RequestGetSafeItems::MergeFrom(const RequestGetSafeItems& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestGetSafeItems::CopyFrom(const RequestGetSafeItems& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetSafeItems::IsInitialized() const {

  return true;
}

void RequestGetSafeItems::Swap(RequestGetSafeItems* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetSafeItems::GetTypeName() const {
  return "Protocol.RequestGetSafeItems";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestDepositMoney::kMoneyFieldNumber;
#endif  // !_MSC_VER

RequestDepositMoney::RequestDepositMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestDepositMoney::InitAsDefaultInstance() {
}

RequestDepositMoney::RequestDepositMoney(const RequestDepositMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestDepositMoney::SharedCtor() {
  _cached_size_ = 0;
  money_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestDepositMoney::~RequestDepositMoney() {
  SharedDtor();
}

void RequestDepositMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestDepositMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestDepositMoney& RequestDepositMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestDepositMoney* RequestDepositMoney::default_instance_ = NULL;

RequestDepositMoney* RequestDepositMoney::New() const {
  return new RequestDepositMoney;
}

void RequestDepositMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    money_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestDepositMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 money = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestDepositMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 money = 1;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->money(), output);
  }

}

int RequestDepositMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 money = 1;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestDepositMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestDepositMoney*>(&from));
}

void RequestDepositMoney::MergeFrom(const RequestDepositMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void RequestDepositMoney::CopyFrom(const RequestDepositMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDepositMoney::IsInitialized() const {

  return true;
}

void RequestDepositMoney::Swap(RequestDepositMoney* other) {
  if (other != this) {
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestDepositMoney::GetTypeName() const {
  return "Protocol.RequestDepositMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestWithdrawMoney::kMoneyFieldNumber;
#endif  // !_MSC_VER

RequestWithdrawMoney::RequestWithdrawMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestWithdrawMoney::InitAsDefaultInstance() {
}

RequestWithdrawMoney::RequestWithdrawMoney(const RequestWithdrawMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestWithdrawMoney::SharedCtor() {
  _cached_size_ = 0;
  money_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestWithdrawMoney::~RequestWithdrawMoney() {
  SharedDtor();
}

void RequestWithdrawMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestWithdrawMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestWithdrawMoney& RequestWithdrawMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestWithdrawMoney* RequestWithdrawMoney::default_instance_ = NULL;

RequestWithdrawMoney* RequestWithdrawMoney::New() const {
  return new RequestWithdrawMoney;
}

void RequestWithdrawMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    money_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestWithdrawMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 money = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestWithdrawMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint64 money = 1;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->money(), output);
  }

}

int RequestWithdrawMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint64 money = 1;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestWithdrawMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestWithdrawMoney*>(&from));
}

void RequestWithdrawMoney::MergeFrom(const RequestWithdrawMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void RequestWithdrawMoney::CopyFrom(const RequestWithdrawMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestWithdrawMoney::IsInitialized() const {

  return true;
}

void RequestWithdrawMoney::Swap(RequestWithdrawMoney* other) {
  if (other != this) {
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestWithdrawMoney::GetTypeName() const {
  return "Protocol.RequestWithdrawMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestDepositItem::kLocListFieldNumber;
#endif  // !_MSC_VER

RequestDepositItem::RequestDepositItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestDepositItem::InitAsDefaultInstance() {
}

RequestDepositItem::RequestDepositItem(const RequestDepositItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestDepositItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestDepositItem::~RequestDepositItem() {
  SharedDtor();
}

void RequestDepositItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestDepositItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestDepositItem& RequestDepositItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestDepositItem* RequestDepositItem::default_instance_ = NULL;

RequestDepositItem* RequestDepositItem::New() const {
  return new RequestDepositItem;
}

void RequestDepositItem::Clear() {
  loc_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestDepositItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ItemLocNum loc_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loc_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_loc_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_loc_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestDepositItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ItemLocNum loc_list = 1;
  for (int i = 0; i < this->loc_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc_list(i), output);
  }

}

int RequestDepositItem::ByteSize() const {
  int total_size = 0;

  // repeated .ItemLocNum loc_list = 1;
  total_size += 1 * this->loc_list_size();
  for (int i = 0; i < this->loc_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->loc_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestDepositItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestDepositItem*>(&from));
}

void RequestDepositItem::MergeFrom(const RequestDepositItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  loc_list_.MergeFrom(from.loc_list_);
}

void RequestDepositItem::CopyFrom(const RequestDepositItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDepositItem::IsInitialized() const {

  return true;
}

void RequestDepositItem::Swap(RequestDepositItem* other) {
  if (other != this) {
    loc_list_.Swap(&other->loc_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestDepositItem::GetTypeName() const {
  return "Protocol.RequestDepositItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestWithdrawItem::kLocListFieldNumber;
#endif  // !_MSC_VER

RequestWithdrawItem::RequestWithdrawItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestWithdrawItem::InitAsDefaultInstance() {
}

RequestWithdrawItem::RequestWithdrawItem(const RequestWithdrawItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestWithdrawItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestWithdrawItem::~RequestWithdrawItem() {
  SharedDtor();
}

void RequestWithdrawItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestWithdrawItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestWithdrawItem& RequestWithdrawItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestWithdrawItem* RequestWithdrawItem::default_instance_ = NULL;

RequestWithdrawItem* RequestWithdrawItem::New() const {
  return new RequestWithdrawItem;
}

void RequestWithdrawItem::Clear() {
  loc_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestWithdrawItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ItemLocNum loc_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loc_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_loc_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_loc_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestWithdrawItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ItemLocNum loc_list = 1;
  for (int i = 0; i < this->loc_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc_list(i), output);
  }

}

int RequestWithdrawItem::ByteSize() const {
  int total_size = 0;

  // repeated .ItemLocNum loc_list = 1;
  total_size += 1 * this->loc_list_size();
  for (int i = 0; i < this->loc_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->loc_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestWithdrawItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestWithdrawItem*>(&from));
}

void RequestWithdrawItem::MergeFrom(const RequestWithdrawItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  loc_list_.MergeFrom(from.loc_list_);
}

void RequestWithdrawItem::CopyFrom(const RequestWithdrawItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestWithdrawItem::IsInitialized() const {

  return true;
}

void RequestWithdrawItem::Swap(RequestWithdrawItem* other) {
  if (other != this) {
    loc_list_.Swap(&other->loc_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestWithdrawItem::GetTypeName() const {
  return "Protocol.RequestWithdrawItem";
}


// ===================================================================

#ifndef _MSC_VER
const int CashShopItem::kCashidFieldNumber;
const int CashShopItem::kGroupFieldNumber;
const int CashShopItem::kRecommendFieldNumber;
const int CashShopItem::kItemidFieldNumber;
const int CashShopItem::kItemnumFieldNumber;
const int CashShopItem::kOriginalPriceFieldNumber;
const int CashShopItem::kDiscountPriceFieldNumber;
#endif  // !_MSC_VER

CashShopItem::CashShopItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CashShopItem::InitAsDefaultInstance() {
}

CashShopItem::CashShopItem(const CashShopItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CashShopItem::SharedCtor() {
  _cached_size_ = 0;
  cashid_ = 0;
  group_ = 0;
  recommend_ = 0;
  itemid_ = 0;
  itemnum_ = 1;
  original_price_ = 0;
  discount_price_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CashShopItem::~CashShopItem() {
  SharedDtor();
}

void CashShopItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CashShopItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CashShopItem& CashShopItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

CashShopItem* CashShopItem::default_instance_ = NULL;

CashShopItem* CashShopItem::New() const {
  return new CashShopItem;
}

void CashShopItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cashid_ = 0;
    group_ = 0;
    recommend_ = 0;
    itemid_ = 0;
    itemnum_ = 1;
    original_price_ = 0;
    discount_price_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CashShopItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cashid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cashid_)));
          set_has_cashid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_group;
        break;
      }

      // optional int32 group = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_group:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_)));
          set_has_group();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_recommend;
        break;
      }

      // optional int32 recommend = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_recommend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &recommend_)));
          set_has_recommend();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_itemid;
        break;
      }

      // optional int32 itemid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_itemnum;
        break;
      }

      // optional int32 itemnum = 5 [default = 1];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemnum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemnum_)));
          set_has_itemnum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_original_price;
        break;
      }

      // optional int32 original_price = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_original_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &original_price_)));
          set_has_original_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_discount_price;
        break;
      }

      // optional int32 discount_price = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_discount_price:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &discount_price_)));
          set_has_discount_price();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CashShopItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 cashid = 1;
  if (has_cashid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cashid(), output);
  }

  // optional int32 group = 2;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->group(), output);
  }

  // optional int32 recommend = 3;
  if (has_recommend()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->recommend(), output);
  }

  // optional int32 itemid = 4;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->itemid(), output);
  }

  // optional int32 itemnum = 5 [default = 1];
  if (has_itemnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->itemnum(), output);
  }

  // optional int32 original_price = 6;
  if (has_original_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->original_price(), output);
  }

  // optional int32 discount_price = 7;
  if (has_discount_price()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->discount_price(), output);
  }

}

int CashShopItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 cashid = 1;
    if (has_cashid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cashid());
    }

    // optional int32 group = 2;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group());
    }

    // optional int32 recommend = 3;
    if (has_recommend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->recommend());
    }

    // optional int32 itemid = 4;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }

    // optional int32 itemnum = 5 [default = 1];
    if (has_itemnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemnum());
    }

    // optional int32 original_price = 6;
    if (has_original_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->original_price());
    }

    // optional int32 discount_price = 7;
    if (has_discount_price()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->discount_price());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CashShopItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CashShopItem*>(&from));
}

void CashShopItem::MergeFrom(const CashShopItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cashid()) {
      set_cashid(from.cashid());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_recommend()) {
      set_recommend(from.recommend());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
    if (from.has_itemnum()) {
      set_itemnum(from.itemnum());
    }
    if (from.has_original_price()) {
      set_original_price(from.original_price());
    }
    if (from.has_discount_price()) {
      set_discount_price(from.discount_price());
    }
  }
}

void CashShopItem::CopyFrom(const CashShopItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CashShopItem::IsInitialized() const {

  return true;
}

void CashShopItem::Swap(CashShopItem* other) {
  if (other != this) {
    std::swap(cashid_, other->cashid_);
    std::swap(group_, other->group_);
    std::swap(recommend_, other->recommend_);
    std::swap(itemid_, other->itemid_);
    std::swap(itemnum_, other->itemnum_);
    std::swap(original_price_, other->original_price_);
    std::swap(discount_price_, other->discount_price_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CashShopItem::GetTypeName() const {
  return "Protocol.CashShopItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetCashShopItem::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestGetCashShopItem::RequestGetCashShopItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetCashShopItem::InitAsDefaultInstance() {
}

RequestGetCashShopItem::RequestGetCashShopItem(const RequestGetCashShopItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetCashShopItem::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetCashShopItem::~RequestGetCashShopItem() {
  SharedDtor();
}

void RequestGetCashShopItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetCashShopItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetCashShopItem& RequestGetCashShopItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestGetCashShopItem* RequestGetCashShopItem::default_instance_ = NULL;

RequestGetCashShopItem* RequestGetCashShopItem::New() const {
  return new RequestGetCashShopItem;
}

void RequestGetCashShopItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetCashShopItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetCashShopItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestGetCashShopItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetCashShopItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetCashShopItem*>(&from));
}

void RequestGetCashShopItem::MergeFrom(const RequestGetCashShopItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestGetCashShopItem::CopyFrom(const RequestGetCashShopItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetCashShopItem::IsInitialized() const {

  return true;
}

void RequestGetCashShopItem::Swap(RequestGetCashShopItem* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetCashShopItem::GetTypeName() const {
  return "Protocol.RequestGetCashShopItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetCashShopItem::kItemListFieldNumber;
#endif  // !_MSC_VER

ResponseGetCashShopItem::ResponseGetCashShopItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetCashShopItem::InitAsDefaultInstance() {
}

ResponseGetCashShopItem::ResponseGetCashShopItem(const ResponseGetCashShopItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetCashShopItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetCashShopItem::~ResponseGetCashShopItem() {
  SharedDtor();
}

void ResponseGetCashShopItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetCashShopItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetCashShopItem& ResponseGetCashShopItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseGetCashShopItem* ResponseGetCashShopItem::default_instance_ = NULL;

ResponseGetCashShopItem* ResponseGetCashShopItem::New() const {
  return new ResponseGetCashShopItem;
}

void ResponseGetCashShopItem::Clear() {
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetCashShopItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.CashShopItem item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetCashShopItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.CashShopItem item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

}

int ResponseGetCashShopItem::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.CashShopItem item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetCashShopItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetCashShopItem*>(&from));
}

void ResponseGetCashShopItem::MergeFrom(const ResponseGetCashShopItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
}

void ResponseGetCashShopItem::CopyFrom(const ResponseGetCashShopItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetCashShopItem::IsInitialized() const {

  return true;
}

void ResponseGetCashShopItem::Swap(ResponseGetCashShopItem* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetCashShopItem::GetTypeName() const {
  return "Protocol.ResponseGetCashShopItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestBuyCashShopItem::kCashidFieldNumber;
const int RequestBuyCashShopItem::kNumFieldNumber;
const int RequestBuyCashShopItem::kCharnameFieldNumber;
const int RequestBuyCashShopItem::kGoldFieldNumber;
#endif  // !_MSC_VER

RequestBuyCashShopItem::RequestBuyCashShopItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestBuyCashShopItem::InitAsDefaultInstance() {
}

RequestBuyCashShopItem::RequestBuyCashShopItem(const RequestBuyCashShopItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestBuyCashShopItem::SharedCtor() {
  _cached_size_ = 0;
  cashid_ = 0;
  num_ = 1;
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  gold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBuyCashShopItem::~RequestBuyCashShopItem() {
  SharedDtor();
}

void RequestBuyCashShopItem::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBuyCashShopItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBuyCashShopItem& RequestBuyCashShopItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestBuyCashShopItem* RequestBuyCashShopItem::default_instance_ = NULL;

RequestBuyCashShopItem* RequestBuyCashShopItem::New() const {
  return new RequestBuyCashShopItem;
}

void RequestBuyCashShopItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    cashid_ = 0;
    num_ = 1;
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
    gold_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestBuyCashShopItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 cashid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cashid_)));
          set_has_cashid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num;
        break;
      }

      // optional int32 num = 2 [default = 1];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_)));
          set_has_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_charname;
        break;
      }

      // optional string charname = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_gold;
        break;
      }

      // optional int32 gold = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestBuyCashShopItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 cashid = 1;
  if (has_cashid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->cashid(), output);
  }

  // optional int32 num = 2 [default = 1];
  if (has_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num(), output);
  }

  // optional string charname = 3;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->charname(), output);
  }

  // optional int32 gold = 4;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->gold(), output);
  }

}

int RequestBuyCashShopItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 cashid = 1;
    if (has_cashid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cashid());
    }

    // optional int32 num = 2 [default = 1];
    if (has_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num());
    }

    // optional string charname = 3;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

    // optional int32 gold = 4;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBuyCashShopItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBuyCashShopItem*>(&from));
}

void RequestBuyCashShopItem::MergeFrom(const RequestBuyCashShopItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_cashid()) {
      set_cashid(from.cashid());
    }
    if (from.has_num()) {
      set_num(from.num());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
  }
}

void RequestBuyCashShopItem::CopyFrom(const RequestBuyCashShopItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBuyCashShopItem::IsInitialized() const {

  return true;
}

void RequestBuyCashShopItem::Swap(RequestBuyCashShopItem* other) {
  if (other != this) {
    std::swap(cashid_, other->cashid_);
    std::swap(num_, other->num_);
    std::swap(charname_, other->charname_);
    std::swap(gold_, other->gold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBuyCashShopItem::GetTypeName() const {
  return "Protocol.RequestBuyCashShopItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseBuyCashShopItem::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseBuyCashShopItem::ResponseBuyCashShopItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseBuyCashShopItem::InitAsDefaultInstance() {
}

ResponseBuyCashShopItem::ResponseBuyCashShopItem(const ResponseBuyCashShopItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseBuyCashShopItem::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseBuyCashShopItem::~ResponseBuyCashShopItem() {
  SharedDtor();
}

void ResponseBuyCashShopItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseBuyCashShopItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseBuyCashShopItem& ResponseBuyCashShopItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseBuyCashShopItem* ResponseBuyCashShopItem::default_instance_ = NULL;

ResponseBuyCashShopItem* ResponseBuyCashShopItem::New() const {
  return new ResponseBuyCashShopItem;
}

void ResponseBuyCashShopItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseBuyCashShopItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseBuyCashShopItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseBuyCashShopItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseBuyCashShopItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseBuyCashShopItem*>(&from));
}

void ResponseBuyCashShopItem::MergeFrom(const ResponseBuyCashShopItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseBuyCashShopItem::CopyFrom(const ResponseBuyCashShopItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseBuyCashShopItem::IsInitialized() const {

  return true;
}

void ResponseBuyCashShopItem::Swap(ResponseBuyCashShopItem* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseBuyCashShopItem::GetTypeName() const {
  return "Protocol.ResponseBuyCashShopItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRemoteOpenEquipRepair::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestRemoteOpenEquipRepair::RequestRemoteOpenEquipRepair()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestRemoteOpenEquipRepair::InitAsDefaultInstance() {
}

RequestRemoteOpenEquipRepair::RequestRemoteOpenEquipRepair(const RequestRemoteOpenEquipRepair& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestRemoteOpenEquipRepair::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRemoteOpenEquipRepair::~RequestRemoteOpenEquipRepair() {
  SharedDtor();
}

void RequestRemoteOpenEquipRepair::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRemoteOpenEquipRepair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRemoteOpenEquipRepair& RequestRemoteOpenEquipRepair::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestRemoteOpenEquipRepair* RequestRemoteOpenEquipRepair::default_instance_ = NULL;

RequestRemoteOpenEquipRepair* RequestRemoteOpenEquipRepair::New() const {
  return new RequestRemoteOpenEquipRepair;
}

void RequestRemoteOpenEquipRepair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestRemoteOpenEquipRepair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestRemoteOpenEquipRepair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestRemoteOpenEquipRepair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRemoteOpenEquipRepair::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRemoteOpenEquipRepair*>(&from));
}

void RequestRemoteOpenEquipRepair::MergeFrom(const RequestRemoteOpenEquipRepair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestRemoteOpenEquipRepair::CopyFrom(const RequestRemoteOpenEquipRepair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRemoteOpenEquipRepair::IsInitialized() const {

  return true;
}

void RequestRemoteOpenEquipRepair::Swap(RequestRemoteOpenEquipRepair* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRemoteOpenEquipRepair::GetTypeName() const {
  return "Protocol.RequestRemoteOpenEquipRepair";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetEquipRepairMoney::kRepairTypeFieldNumber;
#endif  // !_MSC_VER

RequestGetEquipRepairMoney::RequestGetEquipRepairMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetEquipRepairMoney::InitAsDefaultInstance() {
}

RequestGetEquipRepairMoney::RequestGetEquipRepairMoney(const RequestGetEquipRepairMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetEquipRepairMoney::SharedCtor() {
  _cached_size_ = 0;
  repair_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetEquipRepairMoney::~RequestGetEquipRepairMoney() {
  SharedDtor();
}

void RequestGetEquipRepairMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetEquipRepairMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetEquipRepairMoney& RequestGetEquipRepairMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestGetEquipRepairMoney* RequestGetEquipRepairMoney::default_instance_ = NULL;

RequestGetEquipRepairMoney* RequestGetEquipRepairMoney::New() const {
  return new RequestGetEquipRepairMoney;
}

void RequestGetEquipRepairMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    repair_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetEquipRepairMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.EquipRepairType repair_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::EquipRepairType_IsValid(value)) {
            set_repair_type(static_cast< ::Protocol::EquipRepairType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetEquipRepairMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.EquipRepairType repair_type = 1;
  if (has_repair_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->repair_type(), output);
  }

}

int RequestGetEquipRepairMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.EquipRepairType repair_type = 1;
    if (has_repair_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->repair_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetEquipRepairMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetEquipRepairMoney*>(&from));
}

void RequestGetEquipRepairMoney::MergeFrom(const RequestGetEquipRepairMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_repair_type()) {
      set_repair_type(from.repair_type());
    }
  }
}

void RequestGetEquipRepairMoney::CopyFrom(const RequestGetEquipRepairMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetEquipRepairMoney::IsInitialized() const {

  return true;
}

void RequestGetEquipRepairMoney::Swap(RequestGetEquipRepairMoney* other) {
  if (other != this) {
    std::swap(repair_type_, other->repair_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetEquipRepairMoney::GetTypeName() const {
  return "Protocol.RequestGetEquipRepairMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetEquipRepairMoney::kRepairTypeFieldNumber;
const int ResponseGetEquipRepairMoney::kMoneyFieldNumber;
#endif  // !_MSC_VER

ResponseGetEquipRepairMoney::ResponseGetEquipRepairMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetEquipRepairMoney::InitAsDefaultInstance() {
}

ResponseGetEquipRepairMoney::ResponseGetEquipRepairMoney(const ResponseGetEquipRepairMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetEquipRepairMoney::SharedCtor() {
  _cached_size_ = 0;
  repair_type_ = 0;
  money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetEquipRepairMoney::~ResponseGetEquipRepairMoney() {
  SharedDtor();
}

void ResponseGetEquipRepairMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetEquipRepairMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetEquipRepairMoney& ResponseGetEquipRepairMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseGetEquipRepairMoney* ResponseGetEquipRepairMoney::default_instance_ = NULL;

ResponseGetEquipRepairMoney* ResponseGetEquipRepairMoney::New() const {
  return new ResponseGetEquipRepairMoney;
}

void ResponseGetEquipRepairMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    repair_type_ = 0;
    money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetEquipRepairMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.EquipRepairType repair_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::EquipRepairType_IsValid(value)) {
            set_repair_type(static_cast< ::Protocol::EquipRepairType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_money;
        break;
      }

      // optional int32 money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetEquipRepairMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.EquipRepairType repair_type = 1;
  if (has_repair_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->repair_type(), output);
  }

  // optional int32 money = 2;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->money(), output);
  }

}

int ResponseGetEquipRepairMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.EquipRepairType repair_type = 1;
    if (has_repair_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->repair_type());
    }

    // optional int32 money = 2;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetEquipRepairMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetEquipRepairMoney*>(&from));
}

void ResponseGetEquipRepairMoney::MergeFrom(const ResponseGetEquipRepairMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_repair_type()) {
      set_repair_type(from.repair_type());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void ResponseGetEquipRepairMoney::CopyFrom(const ResponseGetEquipRepairMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetEquipRepairMoney::IsInitialized() const {

  return true;
}

void ResponseGetEquipRepairMoney::Swap(ResponseGetEquipRepairMoney* other) {
  if (other != this) {
    std::swap(repair_type_, other->repair_type_);
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetEquipRepairMoney::GetTypeName() const {
  return "Protocol.ResponseGetEquipRepairMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestEquipRepair::kRepairTypeFieldNumber;
#endif  // !_MSC_VER

RequestEquipRepair::RequestEquipRepair()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestEquipRepair::InitAsDefaultInstance() {
}

RequestEquipRepair::RequestEquipRepair(const RequestEquipRepair& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestEquipRepair::SharedCtor() {
  _cached_size_ = 0;
  repair_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestEquipRepair::~RequestEquipRepair() {
  SharedDtor();
}

void RequestEquipRepair::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestEquipRepair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestEquipRepair& RequestEquipRepair::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestEquipRepair* RequestEquipRepair::default_instance_ = NULL;

RequestEquipRepair* RequestEquipRepair::New() const {
  return new RequestEquipRepair;
}

void RequestEquipRepair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    repair_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestEquipRepair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.EquipRepairType repair_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::EquipRepairType_IsValid(value)) {
            set_repair_type(static_cast< ::Protocol::EquipRepairType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestEquipRepair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.EquipRepairType repair_type = 1;
  if (has_repair_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->repair_type(), output);
  }

}

int RequestEquipRepair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.EquipRepairType repair_type = 1;
    if (has_repair_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->repair_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestEquipRepair::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestEquipRepair*>(&from));
}

void RequestEquipRepair::MergeFrom(const RequestEquipRepair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_repair_type()) {
      set_repair_type(from.repair_type());
    }
  }
}

void RequestEquipRepair::CopyFrom(const RequestEquipRepair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestEquipRepair::IsInitialized() const {

  return true;
}

void RequestEquipRepair::Swap(RequestEquipRepair* other) {
  if (other != this) {
    std::swap(repair_type_, other->repair_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestEquipRepair::GetTypeName() const {
  return "Protocol.RequestEquipRepair";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseEquipRepair::kResultFieldNumber;
const int ResponseEquipRepair::kRepairTypeFieldNumber;
#endif  // !_MSC_VER

ResponseEquipRepair::ResponseEquipRepair()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseEquipRepair::InitAsDefaultInstance() {
}

ResponseEquipRepair::ResponseEquipRepair(const ResponseEquipRepair& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseEquipRepair::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  repair_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseEquipRepair::~ResponseEquipRepair() {
  SharedDtor();
}

void ResponseEquipRepair::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseEquipRepair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseEquipRepair& ResponseEquipRepair::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseEquipRepair* ResponseEquipRepair::default_instance_ = NULL;

ResponseEquipRepair* ResponseEquipRepair::New() const {
  return new ResponseEquipRepair;
}

void ResponseEquipRepair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    repair_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseEquipRepair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_repair_type;
        break;
      }

      // optional .Protocol.EquipRepairType repair_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_repair_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::EquipRepairType_IsValid(value)) {
            set_repair_type(static_cast< ::Protocol::EquipRepairType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseEquipRepair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .Protocol.EquipRepairType repair_type = 2;
  if (has_repair_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->repair_type(), output);
  }

}

int ResponseEquipRepair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .Protocol.EquipRepairType repair_type = 2;
    if (has_repair_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->repair_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseEquipRepair::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseEquipRepair*>(&from));
}

void ResponseEquipRepair::MergeFrom(const ResponseEquipRepair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_repair_type()) {
      set_repair_type(from.repair_type());
    }
  }
}

void ResponseEquipRepair::CopyFrom(const ResponseEquipRepair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseEquipRepair::IsInitialized() const {

  return true;
}

void ResponseEquipRepair::Swap(ResponseEquipRepair* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(repair_type_, other->repair_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseEquipRepair::GetTypeName() const {
  return "Protocol.ResponseEquipRepair";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestEquipGetResetExpiredCost::kLocFieldNumber;
#endif  // !_MSC_VER

RequestEquipGetResetExpiredCost::RequestEquipGetResetExpiredCost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestEquipGetResetExpiredCost::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

RequestEquipGetResetExpiredCost::RequestEquipGetResetExpiredCost(const RequestEquipGetResetExpiredCost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestEquipGetResetExpiredCost::SharedCtor() {
  _cached_size_ = 0;
  loc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestEquipGetResetExpiredCost::~RequestEquipGetResetExpiredCost() {
  SharedDtor();
}

void RequestEquipGetResetExpiredCost::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_;
  }
}

void RequestEquipGetResetExpiredCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestEquipGetResetExpiredCost& RequestEquipGetResetExpiredCost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestEquipGetResetExpiredCost* RequestEquipGetResetExpiredCost::default_instance_ = NULL;

RequestEquipGetResetExpiredCost* RequestEquipGetResetExpiredCost::New() const {
  return new RequestEquipGetResetExpiredCost;
}

void RequestEquipGetResetExpiredCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc()) {
      if (loc_ != NULL) loc_->::ItemLoc::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestEquipGetResetExpiredCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestEquipGetResetExpiredCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc loc = 1;
  if (has_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc(), output);
  }

}

int RequestEquipGetResetExpiredCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc loc = 1;
    if (has_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestEquipGetResetExpiredCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestEquipGetResetExpiredCost*>(&from));
}

void RequestEquipGetResetExpiredCost::MergeFrom(const RequestEquipGetResetExpiredCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc()) {
      mutable_loc()->::ItemLoc::MergeFrom(from.loc());
    }
  }
}

void RequestEquipGetResetExpiredCost::CopyFrom(const RequestEquipGetResetExpiredCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestEquipGetResetExpiredCost::IsInitialized() const {

  return true;
}

void RequestEquipGetResetExpiredCost::Swap(RequestEquipGetResetExpiredCost* other) {
  if (other != this) {
    std::swap(loc_, other->loc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestEquipGetResetExpiredCost::GetTypeName() const {
  return "Protocol.RequestEquipGetResetExpiredCost";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseEquipGetResetExpiredCost::kLocFieldNumber;
const int ResponseEquipGetResetExpiredCost::kGoldFieldNumber;
#endif  // !_MSC_VER

ResponseEquipGetResetExpiredCost::ResponseEquipGetResetExpiredCost()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseEquipGetResetExpiredCost::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

ResponseEquipGetResetExpiredCost::ResponseEquipGetResetExpiredCost(const ResponseEquipGetResetExpiredCost& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseEquipGetResetExpiredCost::SharedCtor() {
  _cached_size_ = 0;
  loc_ = NULL;
  gold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseEquipGetResetExpiredCost::~ResponseEquipGetResetExpiredCost() {
  SharedDtor();
}

void ResponseEquipGetResetExpiredCost::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_;
  }
}

void ResponseEquipGetResetExpiredCost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseEquipGetResetExpiredCost& ResponseEquipGetResetExpiredCost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseEquipGetResetExpiredCost* ResponseEquipGetResetExpiredCost::default_instance_ = NULL;

ResponseEquipGetResetExpiredCost* ResponseEquipGetResetExpiredCost::New() const {
  return new ResponseEquipGetResetExpiredCost;
}

void ResponseEquipGetResetExpiredCost::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc()) {
      if (loc_ != NULL) loc_->::ItemLoc::Clear();
    }
    gold_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseEquipGetResetExpiredCost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gold;
        break;
      }

      // optional int32 gold = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseEquipGetResetExpiredCost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc loc = 1;
  if (has_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc(), output);
  }

  // optional int32 gold = 2;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->gold(), output);
  }

}

int ResponseEquipGetResetExpiredCost::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc loc = 1;
    if (has_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc());
    }

    // optional int32 gold = 2;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gold());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseEquipGetResetExpiredCost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseEquipGetResetExpiredCost*>(&from));
}

void ResponseEquipGetResetExpiredCost::MergeFrom(const ResponseEquipGetResetExpiredCost& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc()) {
      mutable_loc()->::ItemLoc::MergeFrom(from.loc());
    }
    if (from.has_gold()) {
      set_gold(from.gold());
    }
  }
}

void ResponseEquipGetResetExpiredCost::CopyFrom(const ResponseEquipGetResetExpiredCost& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseEquipGetResetExpiredCost::IsInitialized() const {

  return true;
}

void ResponseEquipGetResetExpiredCost::Swap(ResponseEquipGetResetExpiredCost* other) {
  if (other != this) {
    std::swap(loc_, other->loc_);
    std::swap(gold_, other->gold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseEquipGetResetExpiredCost::GetTypeName() const {
  return "Protocol.ResponseEquipGetResetExpiredCost";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestEquipResetExpiredTime::kLocFieldNumber;
#endif  // !_MSC_VER

RequestEquipResetExpiredTime::RequestEquipResetExpiredTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestEquipResetExpiredTime::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

RequestEquipResetExpiredTime::RequestEquipResetExpiredTime(const RequestEquipResetExpiredTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestEquipResetExpiredTime::SharedCtor() {
  _cached_size_ = 0;
  loc_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestEquipResetExpiredTime::~RequestEquipResetExpiredTime() {
  SharedDtor();
}

void RequestEquipResetExpiredTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_;
  }
}

void RequestEquipResetExpiredTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestEquipResetExpiredTime& RequestEquipResetExpiredTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestEquipResetExpiredTime* RequestEquipResetExpiredTime::default_instance_ = NULL;

RequestEquipResetExpiredTime* RequestEquipResetExpiredTime::New() const {
  return new RequestEquipResetExpiredTime;
}

void RequestEquipResetExpiredTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc()) {
      if (loc_ != NULL) loc_->::ItemLoc::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestEquipResetExpiredTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestEquipResetExpiredTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc loc = 1;
  if (has_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc(), output);
  }

}

int RequestEquipResetExpiredTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc loc = 1;
    if (has_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestEquipResetExpiredTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestEquipResetExpiredTime*>(&from));
}

void RequestEquipResetExpiredTime::MergeFrom(const RequestEquipResetExpiredTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc()) {
      mutable_loc()->::ItemLoc::MergeFrom(from.loc());
    }
  }
}

void RequestEquipResetExpiredTime::CopyFrom(const RequestEquipResetExpiredTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestEquipResetExpiredTime::IsInitialized() const {

  return true;
}

void RequestEquipResetExpiredTime::Swap(RequestEquipResetExpiredTime* other) {
  if (other != this) {
    std::swap(loc_, other->loc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestEquipResetExpiredTime::GetTypeName() const {
  return "Protocol.RequestEquipResetExpiredTime";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseEquipResetExpiredTime::kLocFieldNumber;
const int ResponseEquipResetExpiredTime::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseEquipResetExpiredTime::ResponseEquipResetExpiredTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseEquipResetExpiredTime::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_ = const_cast< ::ItemLoc*>(
      ::ItemLoc::internal_default_instance());
#else
  loc_ = const_cast< ::ItemLoc*>(&::ItemLoc::default_instance());
#endif
}

ResponseEquipResetExpiredTime::ResponseEquipResetExpiredTime(const ResponseEquipResetExpiredTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseEquipResetExpiredTime::SharedCtor() {
  _cached_size_ = 0;
  loc_ = NULL;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseEquipResetExpiredTime::~ResponseEquipResetExpiredTime() {
  SharedDtor();
}

void ResponseEquipResetExpiredTime::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_;
  }
}

void ResponseEquipResetExpiredTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseEquipResetExpiredTime& ResponseEquipResetExpiredTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

ResponseEquipResetExpiredTime* ResponseEquipResetExpiredTime::default_instance_ = NULL;

ResponseEquipResetExpiredTime* ResponseEquipResetExpiredTime::New() const {
  return new ResponseEquipResetExpiredTime;
}

void ResponseEquipResetExpiredTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc()) {
      if (loc_ != NULL) loc_->::ItemLoc::Clear();
    }
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseEquipResetExpiredTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLoc loc = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_result;
        break;
      }

      // optional int32 result = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseEquipResetExpiredTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLoc loc = 1;
  if (has_loc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc(), output);
  }

  // optional int32 result = 2;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->result(), output);
  }

}

int ResponseEquipResetExpiredTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLoc loc = 1;
    if (has_loc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc());
    }

    // optional int32 result = 2;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseEquipResetExpiredTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseEquipResetExpiredTime*>(&from));
}

void ResponseEquipResetExpiredTime::MergeFrom(const ResponseEquipResetExpiredTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc()) {
      mutable_loc()->::ItemLoc::MergeFrom(from.loc());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseEquipResetExpiredTime::CopyFrom(const ResponseEquipResetExpiredTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseEquipResetExpiredTime::IsInitialized() const {

  return true;
}

void ResponseEquipResetExpiredTime::Swap(ResponseEquipResetExpiredTime* other) {
  if (other != this) {
    std::swap(loc_, other->loc_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseEquipResetExpiredTime::GetTypeName() const {
  return "Protocol.ResponseEquipResetExpiredTime";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestBuybackGetItem::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestBuybackGetItem::RequestBuybackGetItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestBuybackGetItem::InitAsDefaultInstance() {
}

RequestBuybackGetItem::RequestBuybackGetItem(const RequestBuybackGetItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestBuybackGetItem::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBuybackGetItem::~RequestBuybackGetItem() {
  SharedDtor();
}

void RequestBuybackGetItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestBuybackGetItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBuybackGetItem& RequestBuybackGetItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestBuybackGetItem* RequestBuybackGetItem::default_instance_ = NULL;

RequestBuybackGetItem* RequestBuybackGetItem::New() const {
  return new RequestBuybackGetItem;
}

void RequestBuybackGetItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestBuybackGetItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestBuybackGetItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestBuybackGetItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBuybackGetItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBuybackGetItem*>(&from));
}

void RequestBuybackGetItem::MergeFrom(const RequestBuybackGetItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestBuybackGetItem::CopyFrom(const RequestBuybackGetItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBuybackGetItem::IsInitialized() const {

  return true;
}

void RequestBuybackGetItem::Swap(RequestBuybackGetItem* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBuybackGetItem::GetTypeName() const {
  return "Protocol.RequestBuybackGetItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestBuybackBuyItem::kLocNumFieldNumber;
#endif  // !_MSC_VER

RequestBuybackBuyItem::RequestBuybackBuyItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestBuybackBuyItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_num_ = const_cast< ::ItemLocNum*>(
      ::ItemLocNum::internal_default_instance());
#else
  loc_num_ = const_cast< ::ItemLocNum*>(&::ItemLocNum::default_instance());
#endif
}

RequestBuybackBuyItem::RequestBuybackBuyItem(const RequestBuybackBuyItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestBuybackBuyItem::SharedCtor() {
  _cached_size_ = 0;
  loc_num_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestBuybackBuyItem::~RequestBuybackBuyItem() {
  SharedDtor();
}

void RequestBuybackBuyItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_num_;
  }
}

void RequestBuybackBuyItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestBuybackBuyItem& RequestBuybackBuyItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoItem_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoItem_2eproto();
#endif
  return *default_instance_;
}

RequestBuybackBuyItem* RequestBuybackBuyItem::default_instance_ = NULL;

RequestBuybackBuyItem* RequestBuybackBuyItem::New() const {
  return new RequestBuybackBuyItem;
}

void RequestBuybackBuyItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc_num()) {
      if (loc_num_ != NULL) loc_num_->::ItemLocNum::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestBuybackBuyItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLocNum loc_num = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc_num()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestBuybackBuyItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLocNum loc_num = 1;
  if (has_loc_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc_num(), output);
  }

}

int RequestBuybackBuyItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLocNum loc_num = 1;
    if (has_loc_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc_num());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestBuybackBuyItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestBuybackBuyItem*>(&from));
}

void RequestBuybackBuyItem::MergeFrom(const RequestBuybackBuyItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc_num()) {
      mutable_loc_num()->::ItemLocNum::MergeFrom(from.loc_num());
    }
  }
}

void RequestBuybackBuyItem::CopyFrom(const RequestBuybackBuyItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestBuybackBuyItem::IsInitialized() const {

  return true;
}

void RequestBuybackBuyItem::Swap(RequestBuybackBuyItem* other) {
  if (other != this) {
    std::swap(loc_num_, other->loc_num_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestBuybackBuyItem::GetTypeName() const {
  return "Protocol.RequestBuybackBuyItem";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)
