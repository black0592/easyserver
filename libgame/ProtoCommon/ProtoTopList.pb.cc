// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoTopList.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoTopList.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace Protocol {

void protobuf_ShutdownFile_ProtoTopList_2eproto() {
  delete TopLevelInfo::default_instance_;
  delete TopGradeInfo::default_instance_;
  delete TopMoneyInfo::default_instance_;
  delete TopGuildGardeInfo::default_instance_;
  delete TopListInfo::default_instance_;
  delete RequestGetTopList::default_instance_;
  delete ResponseGetTopList::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoTopList_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoTopList_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoGameData_2eproto();
  TopLevelInfo::default_instance_ = new TopLevelInfo();
  TopGradeInfo::default_instance_ = new TopGradeInfo();
  TopMoneyInfo::default_instance_ = new TopMoneyInfo();
  TopGuildGardeInfo::default_instance_ = new TopGuildGardeInfo();
  TopListInfo::default_instance_ = new TopListInfo();
  RequestGetTopList::default_instance_ = new RequestGetTopList();
  ResponseGetTopList::default_instance_ = new ResponseGetTopList();
  TopLevelInfo::default_instance_->InitAsDefaultInstance();
  TopGradeInfo::default_instance_->InitAsDefaultInstance();
  TopMoneyInfo::default_instance_->InitAsDefaultInstance();
  TopGuildGardeInfo::default_instance_->InitAsDefaultInstance();
  TopListInfo::default_instance_->InitAsDefaultInstance();
  RequestGetTopList::default_instance_->InitAsDefaultInstance();
  ResponseGetTopList::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoTopList_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoTopList_2eproto_once_);
void protobuf_AddDesc_ProtoTopList_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoTopList_2eproto_once_,
                 &protobuf_AddDesc_ProtoTopList_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoTopList_2eproto {
  StaticDescriptorInitializer_ProtoTopList_2eproto() {
    protobuf_AddDesc_ProtoTopList_2eproto();
  }
} static_descriptor_initializer_ProtoTopList_2eproto_;
#endif
bool TopListOpCode_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

bool TopListType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int TopLevelInfo::kOrderFieldNumber;
const int TopLevelInfo::kCountryFieldNumber;
const int TopLevelInfo::kCharidFieldNumber;
const int TopLevelInfo::kCharnameFieldNumber;
const int TopLevelInfo::kCharraceFieldNumber;
const int TopLevelInfo::kCharlevelFieldNumber;
#endif  // !_MSC_VER

TopLevelInfo::TopLevelInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TopLevelInfo::InitAsDefaultInstance() {
}

TopLevelInfo::TopLevelInfo(const TopLevelInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TopLevelInfo::SharedCtor() {
  _cached_size_ = 0;
  order_ = 0;
  country_ = 0;
  charid_ = 0;
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  charrace_ = 0;
  charlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopLevelInfo::~TopLevelInfo() {
  SharedDtor();
}

void TopLevelInfo::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TopLevelInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TopLevelInfo& TopLevelInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoTopList_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoTopList_2eproto();
#endif
  return *default_instance_;
}

TopLevelInfo* TopLevelInfo::default_instance_ = NULL;

TopLevelInfo* TopLevelInfo::New() const {
  return new TopLevelInfo;
}

void TopLevelInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    order_ = 0;
    country_ = 0;
    charid_ = 0;
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
    charrace_ = 0;
    charlevel_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TopLevelInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 order = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_country;
        break;
      }

      // optional int32 country = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_country:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &country_)));
          set_has_country();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional int32 charid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_charname;
        break;
      }

      // optional string charname = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_charrace;
        break;
      }

      // optional int32 charrace = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charrace:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charrace_)));
          set_has_charrace();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_charlevel;
        break;
      }

      // optional int32 charlevel = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charlevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charlevel_)));
          set_has_charlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TopLevelInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 order = 1;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->order(), output);
  }

  // optional int32 country = 2;
  if (has_country()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->country(), output);
  }

  // optional int32 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->charid(), output);
  }

  // optional string charname = 4;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->charname(), output);
  }

  // optional int32 charrace = 5;
  if (has_charrace()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->charrace(), output);
  }

  // optional int32 charlevel = 6;
  if (has_charlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->charlevel(), output);
  }

}

int TopLevelInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 order = 1;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->order());
    }

    // optional int32 country = 2;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->country());
    }

    // optional int32 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string charname = 4;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

    // optional int32 charrace = 5;
    if (has_charrace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charrace());
    }

    // optional int32 charlevel = 6;
    if (has_charlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charlevel());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopLevelInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TopLevelInfo*>(&from));
}

void TopLevelInfo::MergeFrom(const TopLevelInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
    if (from.has_charrace()) {
      set_charrace(from.charrace());
    }
    if (from.has_charlevel()) {
      set_charlevel(from.charlevel());
    }
  }
}

void TopLevelInfo::CopyFrom(const TopLevelInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopLevelInfo::IsInitialized() const {

  return true;
}

void TopLevelInfo::Swap(TopLevelInfo* other) {
  if (other != this) {
    std::swap(order_, other->order_);
    std::swap(country_, other->country_);
    std::swap(charid_, other->charid_);
    std::swap(charname_, other->charname_);
    std::swap(charrace_, other->charrace_);
    std::swap(charlevel_, other->charlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TopLevelInfo::GetTypeName() const {
  return "Protocol.TopLevelInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int TopGradeInfo::kOrderFieldNumber;
const int TopGradeInfo::kCountryFieldNumber;
const int TopGradeInfo::kCharidFieldNumber;
const int TopGradeInfo::kCharnameFieldNumber;
const int TopGradeInfo::kCharraceFieldNumber;
const int TopGradeInfo::kChargradeFieldNumber;
#endif  // !_MSC_VER

TopGradeInfo::TopGradeInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TopGradeInfo::InitAsDefaultInstance() {
}

TopGradeInfo::TopGradeInfo(const TopGradeInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TopGradeInfo::SharedCtor() {
  _cached_size_ = 0;
  order_ = 0;
  country_ = 0;
  charid_ = 0;
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  charrace_ = 0;
  chargrade_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopGradeInfo::~TopGradeInfo() {
  SharedDtor();
}

void TopGradeInfo::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TopGradeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TopGradeInfo& TopGradeInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoTopList_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoTopList_2eproto();
#endif
  return *default_instance_;
}

TopGradeInfo* TopGradeInfo::default_instance_ = NULL;

TopGradeInfo* TopGradeInfo::New() const {
  return new TopGradeInfo;
}

void TopGradeInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    order_ = 0;
    country_ = 0;
    charid_ = 0;
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
    charrace_ = 0;
    chargrade_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TopGradeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 order = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_country;
        break;
      }

      // optional int32 country = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_country:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &country_)));
          set_has_country();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional int32 charid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_charname;
        break;
      }

      // optional string charname = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_charrace;
        break;
      }

      // optional int32 charrace = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charrace:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charrace_)));
          set_has_charrace();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_chargrade;
        break;
      }

      // optional int32 chargrade = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_chargrade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &chargrade_)));
          set_has_chargrade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TopGradeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 order = 1;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->order(), output);
  }

  // optional int32 country = 2;
  if (has_country()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->country(), output);
  }

  // optional int32 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->charid(), output);
  }

  // optional string charname = 4;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->charname(), output);
  }

  // optional int32 charrace = 5;
  if (has_charrace()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->charrace(), output);
  }

  // optional int32 chargrade = 6;
  if (has_chargrade()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->chargrade(), output);
  }

}

int TopGradeInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 order = 1;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->order());
    }

    // optional int32 country = 2;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->country());
    }

    // optional int32 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string charname = 4;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

    // optional int32 charrace = 5;
    if (has_charrace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charrace());
    }

    // optional int32 chargrade = 6;
    if (has_chargrade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->chargrade());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopGradeInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TopGradeInfo*>(&from));
}

void TopGradeInfo::MergeFrom(const TopGradeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
    if (from.has_charrace()) {
      set_charrace(from.charrace());
    }
    if (from.has_chargrade()) {
      set_chargrade(from.chargrade());
    }
  }
}

void TopGradeInfo::CopyFrom(const TopGradeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopGradeInfo::IsInitialized() const {

  return true;
}

void TopGradeInfo::Swap(TopGradeInfo* other) {
  if (other != this) {
    std::swap(order_, other->order_);
    std::swap(country_, other->country_);
    std::swap(charid_, other->charid_);
    std::swap(charname_, other->charname_);
    std::swap(charrace_, other->charrace_);
    std::swap(chargrade_, other->chargrade_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TopGradeInfo::GetTypeName() const {
  return "Protocol.TopGradeInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int TopMoneyInfo::kOrderFieldNumber;
const int TopMoneyInfo::kCountryFieldNumber;
const int TopMoneyInfo::kCharidFieldNumber;
const int TopMoneyInfo::kCharnameFieldNumber;
const int TopMoneyInfo::kCharraceFieldNumber;
const int TopMoneyInfo::kCharmoneyFieldNumber;
#endif  // !_MSC_VER

TopMoneyInfo::TopMoneyInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TopMoneyInfo::InitAsDefaultInstance() {
}

TopMoneyInfo::TopMoneyInfo(const TopMoneyInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TopMoneyInfo::SharedCtor() {
  _cached_size_ = 0;
  order_ = 0;
  country_ = 0;
  charid_ = 0;
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  charrace_ = 0;
  charmoney_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopMoneyInfo::~TopMoneyInfo() {
  SharedDtor();
}

void TopMoneyInfo::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TopMoneyInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TopMoneyInfo& TopMoneyInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoTopList_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoTopList_2eproto();
#endif
  return *default_instance_;
}

TopMoneyInfo* TopMoneyInfo::default_instance_ = NULL;

TopMoneyInfo* TopMoneyInfo::New() const {
  return new TopMoneyInfo;
}

void TopMoneyInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    order_ = 0;
    country_ = 0;
    charid_ = 0;
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
    charrace_ = 0;
    charmoney_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TopMoneyInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 order = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_country;
        break;
      }

      // optional int32 country = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_country:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &country_)));
          set_has_country();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_charid;
        break;
      }

      // optional int32 charid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_charname;
        break;
      }

      // optional string charname = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_charrace;
        break;
      }

      // optional int32 charrace = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charrace:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charrace_)));
          set_has_charrace();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_charmoney;
        break;
      }

      // optional int32 charmoney = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charmoney:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charmoney_)));
          set_has_charmoney();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TopMoneyInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 order = 1;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->order(), output);
  }

  // optional int32 country = 2;
  if (has_country()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->country(), output);
  }

  // optional int32 charid = 3;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->charid(), output);
  }

  // optional string charname = 4;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->charname(), output);
  }

  // optional int32 charrace = 5;
  if (has_charrace()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->charrace(), output);
  }

  // optional int32 charmoney = 6;
  if (has_charmoney()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->charmoney(), output);
  }

}

int TopMoneyInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 order = 1;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->order());
    }

    // optional int32 country = 2;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->country());
    }

    // optional int32 charid = 3;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string charname = 4;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

    // optional int32 charrace = 5;
    if (has_charrace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charrace());
    }

    // optional int32 charmoney = 6;
    if (has_charmoney()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charmoney());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopMoneyInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TopMoneyInfo*>(&from));
}

void TopMoneyInfo::MergeFrom(const TopMoneyInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
    if (from.has_charrace()) {
      set_charrace(from.charrace());
    }
    if (from.has_charmoney()) {
      set_charmoney(from.charmoney());
    }
  }
}

void TopMoneyInfo::CopyFrom(const TopMoneyInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopMoneyInfo::IsInitialized() const {

  return true;
}

void TopMoneyInfo::Swap(TopMoneyInfo* other) {
  if (other != this) {
    std::swap(order_, other->order_);
    std::swap(country_, other->country_);
    std::swap(charid_, other->charid_);
    std::swap(charname_, other->charname_);
    std::swap(charrace_, other->charrace_);
    std::swap(charmoney_, other->charmoney_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TopMoneyInfo::GetTypeName() const {
  return "Protocol.TopMoneyInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int TopGuildGardeInfo::kOrderFieldNumber;
const int TopGuildGardeInfo::kCountryFieldNumber;
const int TopGuildGardeInfo::kGuildidFieldNumber;
const int TopGuildGardeInfo::kGuildnameFieldNumber;
const int TopGuildGardeInfo::kMasterFieldNumber;
const int TopGuildGardeInfo::kGuildgradeFieldNumber;
#endif  // !_MSC_VER

TopGuildGardeInfo::TopGuildGardeInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TopGuildGardeInfo::InitAsDefaultInstance() {
}

TopGuildGardeInfo::TopGuildGardeInfo(const TopGuildGardeInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TopGuildGardeInfo::SharedCtor() {
  _cached_size_ = 0;
  order_ = 0;
  country_ = 0;
  guildid_ = 0;
  guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  guildgrade_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopGuildGardeInfo::~TopGuildGardeInfo() {
  SharedDtor();
}

void TopGuildGardeInfo::SharedDtor() {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    delete guildname_;
  }
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    delete master_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TopGuildGardeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TopGuildGardeInfo& TopGuildGardeInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoTopList_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoTopList_2eproto();
#endif
  return *default_instance_;
}

TopGuildGardeInfo* TopGuildGardeInfo::default_instance_ = NULL;

TopGuildGardeInfo* TopGuildGardeInfo::New() const {
  return new TopGuildGardeInfo;
}

void TopGuildGardeInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    order_ = 0;
    country_ = 0;
    guildid_ = 0;
    if (has_guildname()) {
      if (guildname_ != &::google::protobuf::internal::kEmptyString) {
        guildname_->clear();
      }
    }
    if (has_master()) {
      if (master_ != &::google::protobuf::internal::kEmptyString) {
        master_->clear();
      }
    }
    guildgrade_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TopGuildGardeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 order = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &order_)));
          set_has_order();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_country;
        break;
      }

      // optional int32 country = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_country:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &country_)));
          set_has_country();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_guildid;
        break;
      }

      // optional int32 guildid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guildid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &guildid_)));
          set_has_guildid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_guildname;
        break;
      }

      // optional string guildname = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guildname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_guildname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_master;
        break;
      }

      // optional string master = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_master:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_master()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_guildgrade;
        break;
      }

      // optional int32 guildgrade = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_guildgrade:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &guildgrade_)));
          set_has_guildgrade();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TopGuildGardeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 order = 1;
  if (has_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->order(), output);
  }

  // optional int32 country = 2;
  if (has_country()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->country(), output);
  }

  // optional int32 guildid = 3;
  if (has_guildid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->guildid(), output);
  }

  // optional string guildname = 4;
  if (has_guildname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->guildname(), output);
  }

  // optional string master = 5;
  if (has_master()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->master(), output);
  }

  // optional int32 guildgrade = 6;
  if (has_guildgrade()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->guildgrade(), output);
  }

}

int TopGuildGardeInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 order = 1;
    if (has_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->order());
    }

    // optional int32 country = 2;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->country());
    }

    // optional int32 guildid = 3;
    if (has_guildid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->guildid());
    }

    // optional string guildname = 4;
    if (has_guildname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->guildname());
    }

    // optional string master = 5;
    if (has_master()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->master());
    }

    // optional int32 guildgrade = 6;
    if (has_guildgrade()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->guildgrade());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopGuildGardeInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TopGuildGardeInfo*>(&from));
}

void TopGuildGardeInfo::MergeFrom(const TopGuildGardeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_order()) {
      set_order(from.order());
    }
    if (from.has_country()) {
      set_country(from.country());
    }
    if (from.has_guildid()) {
      set_guildid(from.guildid());
    }
    if (from.has_guildname()) {
      set_guildname(from.guildname());
    }
    if (from.has_master()) {
      set_master(from.master());
    }
    if (from.has_guildgrade()) {
      set_guildgrade(from.guildgrade());
    }
  }
}

void TopGuildGardeInfo::CopyFrom(const TopGuildGardeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopGuildGardeInfo::IsInitialized() const {

  return true;
}

void TopGuildGardeInfo::Swap(TopGuildGardeInfo* other) {
  if (other != this) {
    std::swap(order_, other->order_);
    std::swap(country_, other->country_);
    std::swap(guildid_, other->guildid_);
    std::swap(guildname_, other->guildname_);
    std::swap(master_, other->master_);
    std::swap(guildgrade_, other->guildgrade_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TopGuildGardeInfo::GetTypeName() const {
  return "Protocol.TopGuildGardeInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int TopListInfo::kLevelInfoFieldNumber;
const int TopListInfo::kGradeInfoFieldNumber;
const int TopListInfo::kMoneyInfoFieldNumber;
const int TopListInfo::kGuildgardeInfoFieldNumber;
#endif  // !_MSC_VER

TopListInfo::TopListInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void TopListInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  level_info_ = const_cast< ::Protocol::TopLevelInfo*>(
      ::Protocol::TopLevelInfo::internal_default_instance());
#else
  level_info_ = const_cast< ::Protocol::TopLevelInfo*>(&::Protocol::TopLevelInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  grade_info_ = const_cast< ::Protocol::TopGradeInfo*>(
      ::Protocol::TopGradeInfo::internal_default_instance());
#else
  grade_info_ = const_cast< ::Protocol::TopGradeInfo*>(&::Protocol::TopGradeInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  money_info_ = const_cast< ::Protocol::TopMoneyInfo*>(
      ::Protocol::TopMoneyInfo::internal_default_instance());
#else
  money_info_ = const_cast< ::Protocol::TopMoneyInfo*>(&::Protocol::TopMoneyInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  guildgarde_info_ = const_cast< ::Protocol::TopGuildGardeInfo*>(
      ::Protocol::TopGuildGardeInfo::internal_default_instance());
#else
  guildgarde_info_ = const_cast< ::Protocol::TopGuildGardeInfo*>(&::Protocol::TopGuildGardeInfo::default_instance());
#endif
}

TopListInfo::TopListInfo(const TopListInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void TopListInfo::SharedCtor() {
  _cached_size_ = 0;
  level_info_ = NULL;
  grade_info_ = NULL;
  money_info_ = NULL;
  guildgarde_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopListInfo::~TopListInfo() {
  SharedDtor();
}

void TopListInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete level_info_;
    delete grade_info_;
    delete money_info_;
    delete guildgarde_info_;
  }
}

void TopListInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TopListInfo& TopListInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoTopList_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoTopList_2eproto();
#endif
  return *default_instance_;
}

TopListInfo* TopListInfo::default_instance_ = NULL;

TopListInfo* TopListInfo::New() const {
  return new TopListInfo;
}

void TopListInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_level_info()) {
      if (level_info_ != NULL) level_info_->::Protocol::TopLevelInfo::Clear();
    }
    if (has_grade_info()) {
      if (grade_info_ != NULL) grade_info_->::Protocol::TopGradeInfo::Clear();
    }
    if (has_money_info()) {
      if (money_info_ != NULL) money_info_->::Protocol::TopMoneyInfo::Clear();
    }
    if (has_guildgarde_info()) {
      if (guildgarde_info_ != NULL) guildgarde_info_->::Protocol::TopGuildGardeInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool TopListInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.TopLevelInfo level_info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_level_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_grade_info;
        break;
      }

      // optional .Protocol.TopGradeInfo grade_info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_grade_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_grade_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_money_info;
        break;
      }

      // optional .Protocol.TopMoneyInfo money_info = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_money_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_money_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_guildgarde_info;
        break;
      }

      // optional .Protocol.TopGuildGardeInfo guildgarde_info = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_guildgarde_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_guildgarde_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TopListInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.TopLevelInfo level_info = 1;
  if (has_level_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->level_info(), output);
  }

  // optional .Protocol.TopGradeInfo grade_info = 2;
  if (has_grade_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->grade_info(), output);
  }

  // optional .Protocol.TopMoneyInfo money_info = 3;
  if (has_money_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->money_info(), output);
  }

  // optional .Protocol.TopGuildGardeInfo guildgarde_info = 4;
  if (has_guildgarde_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->guildgarde_info(), output);
  }

}

int TopListInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.TopLevelInfo level_info = 1;
    if (has_level_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->level_info());
    }

    // optional .Protocol.TopGradeInfo grade_info = 2;
    if (has_grade_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->grade_info());
    }

    // optional .Protocol.TopMoneyInfo money_info = 3;
    if (has_money_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->money_info());
    }

    // optional .Protocol.TopGuildGardeInfo guildgarde_info = 4;
    if (has_guildgarde_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->guildgarde_info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopListInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TopListInfo*>(&from));
}

void TopListInfo::MergeFrom(const TopListInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level_info()) {
      mutable_level_info()->::Protocol::TopLevelInfo::MergeFrom(from.level_info());
    }
    if (from.has_grade_info()) {
      mutable_grade_info()->::Protocol::TopGradeInfo::MergeFrom(from.grade_info());
    }
    if (from.has_money_info()) {
      mutable_money_info()->::Protocol::TopMoneyInfo::MergeFrom(from.money_info());
    }
    if (from.has_guildgarde_info()) {
      mutable_guildgarde_info()->::Protocol::TopGuildGardeInfo::MergeFrom(from.guildgarde_info());
    }
  }
}

void TopListInfo::CopyFrom(const TopListInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopListInfo::IsInitialized() const {

  return true;
}

void TopListInfo::Swap(TopListInfo* other) {
  if (other != this) {
    std::swap(level_info_, other->level_info_);
    std::swap(grade_info_, other->grade_info_);
    std::swap(money_info_, other->money_info_);
    std::swap(guildgarde_info_, other->guildgarde_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string TopListInfo::GetTypeName() const {
  return "Protocol.TopListInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetTopList::kTopTypeFieldNumber;
#endif  // !_MSC_VER

RequestGetTopList::RequestGetTopList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetTopList::InitAsDefaultInstance() {
}

RequestGetTopList::RequestGetTopList(const RequestGetTopList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetTopList::SharedCtor() {
  _cached_size_ = 0;
  top_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetTopList::~RequestGetTopList() {
  SharedDtor();
}

void RequestGetTopList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetTopList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetTopList& RequestGetTopList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoTopList_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoTopList_2eproto();
#endif
  return *default_instance_;
}

RequestGetTopList* RequestGetTopList::default_instance_ = NULL;

RequestGetTopList* RequestGetTopList::New() const {
  return new RequestGetTopList;
}

void RequestGetTopList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    top_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetTopList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.TopListType top_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::TopListType_IsValid(value)) {
            set_top_type(static_cast< ::Protocol::TopListType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetTopList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.TopListType top_type = 1;
  if (has_top_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->top_type(), output);
  }

}

int RequestGetTopList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.TopListType top_type = 1;
    if (has_top_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->top_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetTopList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetTopList*>(&from));
}

void RequestGetTopList::MergeFrom(const RequestGetTopList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_top_type()) {
      set_top_type(from.top_type());
    }
  }
}

void RequestGetTopList::CopyFrom(const RequestGetTopList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetTopList::IsInitialized() const {

  return true;
}

void RequestGetTopList::Swap(RequestGetTopList* other) {
  if (other != this) {
    std::swap(top_type_, other->top_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetTopList::GetTypeName() const {
  return "Protocol.RequestGetTopList";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetTopList::kTopTypeFieldNumber;
const int ResponseGetTopList::kTopListFieldNumber;
const int ResponseGetTopList::kMyOrderFieldNumber;
#endif  // !_MSC_VER

ResponseGetTopList::ResponseGetTopList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetTopList::InitAsDefaultInstance() {
}

ResponseGetTopList::ResponseGetTopList(const ResponseGetTopList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetTopList::SharedCtor() {
  _cached_size_ = 0;
  top_type_ = 0;
  my_order_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetTopList::~ResponseGetTopList() {
  SharedDtor();
}

void ResponseGetTopList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetTopList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetTopList& ResponseGetTopList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoTopList_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoTopList_2eproto();
#endif
  return *default_instance_;
}

ResponseGetTopList* ResponseGetTopList::default_instance_ = NULL;

ResponseGetTopList* ResponseGetTopList::New() const {
  return new ResponseGetTopList;
}

void ResponseGetTopList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    top_type_ = 0;
    my_order_ = 0;
  }
  top_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetTopList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.TopListType top_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::TopListType_IsValid(value)) {
            set_top_type(static_cast< ::Protocol::TopListType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_top_list;
        break;
      }

      // repeated .Protocol.TopListInfo top_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_top_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_top_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_top_list;
        if (input->ExpectTag(24)) goto parse_my_order;
        break;
      }

      // optional int32 my_order = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_my_order:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &my_order_)));
          set_has_my_order();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetTopList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.TopListType top_type = 1;
  if (has_top_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->top_type(), output);
  }

  // repeated .Protocol.TopListInfo top_list = 2;
  for (int i = 0; i < this->top_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->top_list(i), output);
  }

  // optional int32 my_order = 3;
  if (has_my_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->my_order(), output);
  }

}

int ResponseGetTopList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.TopListType top_type = 1;
    if (has_top_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->top_type());
    }

    // optional int32 my_order = 3;
    if (has_my_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->my_order());
    }

  }
  // repeated .Protocol.TopListInfo top_list = 2;
  total_size += 1 * this->top_list_size();
  for (int i = 0; i < this->top_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->top_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetTopList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetTopList*>(&from));
}

void ResponseGetTopList::MergeFrom(const ResponseGetTopList& from) {
  GOOGLE_CHECK_NE(&from, this);
  top_list_.MergeFrom(from.top_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_top_type()) {
      set_top_type(from.top_type());
    }
    if (from.has_my_order()) {
      set_my_order(from.my_order());
    }
  }
}

void ResponseGetTopList::CopyFrom(const ResponseGetTopList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetTopList::IsInitialized() const {

  return true;
}

void ResponseGetTopList::Swap(ResponseGetTopList* other) {
  if (other != this) {
    std::swap(top_type_, other->top_type_);
    top_list_.Swap(&other->top_list_);
    std::swap(my_order_, other->my_order_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetTopList::GetTypeName() const {
  return "Protocol.ResponseGetTopList";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)
