// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoLogin.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoLogin.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace Protocol {

void protobuf_ShutdownFile_ProtoLogin_2eproto() {
  delete ZoneInfo::default_instance_;
  delete ZoneCharInfo::default_instance_;
  delete RequestRegister::default_instance_;
  delete ResponseRegister::default_instance_;
  delete RequestLogin::default_instance_;
  delete ResponseLogin::default_instance_;
  delete RequestEnterServer::default_instance_;
  delete ResponseEnterServer::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoLogin_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoLogin_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoGameData_2eproto();
  ZoneInfo::default_instance_ = new ZoneInfo();
  ZoneCharInfo::default_instance_ = new ZoneCharInfo();
  RequestRegister::default_instance_ = new RequestRegister();
  ResponseRegister::default_instance_ = new ResponseRegister();
  RequestLogin::default_instance_ = new RequestLogin();
  ResponseLogin::default_instance_ = new ResponseLogin();
  RequestEnterServer::default_instance_ = new RequestEnterServer();
  ResponseEnterServer::default_instance_ = new ResponseEnterServer();
  ZoneInfo::default_instance_->InitAsDefaultInstance();
  ZoneCharInfo::default_instance_->InitAsDefaultInstance();
  RequestRegister::default_instance_->InitAsDefaultInstance();
  ResponseRegister::default_instance_->InitAsDefaultInstance();
  RequestLogin::default_instance_->InitAsDefaultInstance();
  ResponseLogin::default_instance_->InitAsDefaultInstance();
  RequestEnterServer::default_instance_->InitAsDefaultInstance();
  ResponseEnterServer::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoLogin_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoLogin_2eproto_once_);
void protobuf_AddDesc_ProtoLogin_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoLogin_2eproto_once_,
                 &protobuf_AddDesc_ProtoLogin_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoLogin_2eproto {
  StaticDescriptorInitializer_ProtoLogin_2eproto() {
    protobuf_AddDesc_ProtoLogin_2eproto();
  }
} static_descriptor_initializer_ProtoLogin_2eproto_;
#endif
bool LoginOpCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool RegisterError_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool LoginError_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool EnterZoneError_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

bool ZoneInfo_ZoneState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ZoneInfo_ZoneState ZoneInfo::ZS_NORMAL;
const ZoneInfo_ZoneState ZoneInfo::ZS_BUSY;
const ZoneInfo_ZoneState ZoneInfo::ZS_FULL;
const ZoneInfo_ZoneState ZoneInfo::ZS_STOPED;
const ZoneInfo_ZoneState ZoneInfo::ZoneState_MIN;
const ZoneInfo_ZoneState ZoneInfo::ZoneState_MAX;
const int ZoneInfo::ZoneState_ARRAYSIZE;
#endif  // _MSC_VER
bool ZoneInfo_ZoneFlag_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const ZoneInfo_ZoneFlag ZoneInfo::ZF_NORMAL;
const ZoneInfo_ZoneFlag ZoneInfo::ZF_NEWER;
const ZoneInfo_ZoneFlag ZoneInfo::ZF_RECOMMEND;
const ZoneInfo_ZoneFlag ZoneInfo::ZoneFlag_MIN;
const ZoneInfo_ZoneFlag ZoneInfo::ZoneFlag_MAX;
const int ZoneInfo::ZoneFlag_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int ZoneInfo::kIdFieldNumber;
const int ZoneInfo::kNameFieldNumber;
const int ZoneInfo::kGroupFieldNumber;
const int ZoneInfo::kStateFieldNumber;
const int ZoneInfo::kFlagFieldNumber;
#endif  // !_MSC_VER

ZoneInfo::ZoneInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ZoneInfo::InitAsDefaultInstance() {
}

ZoneInfo::ZoneInfo(const ZoneInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ZoneInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  group_ = 0;
  state_ = 0;
  flag_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ZoneInfo::~ZoneInfo() {
  SharedDtor();
}

void ZoneInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ZoneInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ZoneInfo& ZoneInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

ZoneInfo* ZoneInfo::default_instance_ = NULL;

ZoneInfo* ZoneInfo::New() const {
  return new ZoneInfo;
}

void ZoneInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    group_ = 0;
    state_ = 0;
    flag_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ZoneInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_group;
        break;
      }

      // optional int32 group = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_group:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &group_)));
          set_has_group();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_state;
        break;
      }

      // optional .Protocol.ZoneInfo.ZoneState state = 4 [default = ZS_NORMAL];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::ZoneInfo_ZoneState_IsValid(value)) {
            set_state(static_cast< ::Protocol::ZoneInfo_ZoneState >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_flag;
        break;
      }

      // optional .Protocol.ZoneInfo.ZoneFlag flag = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::ZoneInfo_ZoneFlag_IsValid(value)) {
            set_flag(static_cast< ::Protocol::ZoneInfo_ZoneFlag >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ZoneInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 group = 3;
  if (has_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->group(), output);
  }

  // optional .Protocol.ZoneInfo.ZoneState state = 4 [default = ZS_NORMAL];
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->state(), output);
  }

  // optional .Protocol.ZoneInfo.ZoneFlag flag = 5;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->flag(), output);
  }

}

int ZoneInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 group = 3;
    if (has_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->group());
    }

    // optional .Protocol.ZoneInfo.ZoneState state = 4 [default = ZS_NORMAL];
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

    // optional .Protocol.ZoneInfo.ZoneFlag flag = 5;
    if (has_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->flag());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ZoneInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ZoneInfo*>(&from));
}

void ZoneInfo::MergeFrom(const ZoneInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_group()) {
      set_group(from.group());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_flag()) {
      set_flag(from.flag());
    }
  }
}

void ZoneInfo::CopyFrom(const ZoneInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZoneInfo::IsInitialized() const {

  return true;
}

void ZoneInfo::Swap(ZoneInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(group_, other->group_);
    std::swap(state_, other->state_);
    std::swap(flag_, other->flag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ZoneInfo::GetTypeName() const {
  return "Protocol.ZoneInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ZoneCharInfo::kZoneidFieldNumber;
const int ZoneCharInfo::kCharnameFieldNumber;
const int ZoneCharInfo::kCharlevelFieldNumber;
const int ZoneCharInfo::kCharraceFieldNumber;
#endif  // !_MSC_VER

ZoneCharInfo::ZoneCharInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ZoneCharInfo::InitAsDefaultInstance() {
}

ZoneCharInfo::ZoneCharInfo(const ZoneCharInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ZoneCharInfo::SharedCtor() {
  _cached_size_ = 0;
  zoneid_ = 0;
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  charlevel_ = 0;
  charrace_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ZoneCharInfo::~ZoneCharInfo() {
  SharedDtor();
}

void ZoneCharInfo::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ZoneCharInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ZoneCharInfo& ZoneCharInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

ZoneCharInfo* ZoneCharInfo::default_instance_ = NULL;

ZoneCharInfo* ZoneCharInfo::New() const {
  return new ZoneCharInfo;
}

void ZoneCharInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zoneid_ = 0;
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
    charlevel_ = 0;
    charrace_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ZoneCharInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zoneid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_charname;
        break;
      }

      // optional string charname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_charlevel;
        break;
      }

      // optional int32 charlevel = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charlevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charlevel_)));
          set_has_charlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_charrace;
        break;
      }

      // optional int32 charrace = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charrace:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charrace_)));
          set_has_charrace();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ZoneCharInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 zoneid = 1;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zoneid(), output);
  }

  // optional string charname = 2;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->charname(), output);
  }

  // optional int32 charlevel = 3;
  if (has_charlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->charlevel(), output);
  }

  // optional int32 charrace = 4;
  if (has_charrace()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->charrace(), output);
  }

}

int ZoneCharInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 zoneid = 1;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zoneid());
    }

    // optional string charname = 2;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

    // optional int32 charlevel = 3;
    if (has_charlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charlevel());
    }

    // optional int32 charrace = 4;
    if (has_charrace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charrace());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ZoneCharInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ZoneCharInfo*>(&from));
}

void ZoneCharInfo::MergeFrom(const ZoneCharInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
    if (from.has_charlevel()) {
      set_charlevel(from.charlevel());
    }
    if (from.has_charrace()) {
      set_charrace(from.charrace());
    }
  }
}

void ZoneCharInfo::CopyFrom(const ZoneCharInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZoneCharInfo::IsInitialized() const {

  return true;
}

void ZoneCharInfo::Swap(ZoneCharInfo* other) {
  if (other != this) {
    std::swap(zoneid_, other->zoneid_);
    std::swap(charname_, other->charname_);
    std::swap(charlevel_, other->charlevel_);
    std::swap(charrace_, other->charrace_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ZoneCharInfo::GetTypeName() const {
  return "Protocol.ZoneCharInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRegister::kAccountFieldNumber;
const int RequestRegister::kPasswordFieldNumber;
const int RequestRegister::kEmailFieldNumber;
#endif  // !_MSC_VER

RequestRegister::RequestRegister()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestRegister::InitAsDefaultInstance() {
}

RequestRegister::RequestRegister(const RequestRegister& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestRegister::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegister::~RequestRegister() {
  SharedDtor();
}

void RequestRegister::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRegister::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegister& RequestRegister::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

RequestRegister* RequestRegister::default_instance_ = NULL;

RequestRegister* RequestRegister::New() const {
  return new RequestRegister;
}

void RequestRegister::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
    if (has_email()) {
      if (email_ != &::google::protobuf::internal::kEmptyString) {
        email_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestRegister::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_password;
        break;
      }

      // optional string password = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_email;
        break;
      }

      // optional string email = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_email:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_email()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestRegister::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  // optional string password = 2;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->password(), output);
  }

  // optional string email = 3;
  if (has_email()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->email(), output);
  }

}

int RequestRegister::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string password = 2;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

    // optional string email = 3;
    if (has_email()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->email());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegister::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegister*>(&from));
}

void RequestRegister::MergeFrom(const RequestRegister& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
    if (from.has_email()) {
      set_email(from.email());
    }
  }
}

void RequestRegister::CopyFrom(const RequestRegister& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegister::IsInitialized() const {

  return true;
}

void RequestRegister::Swap(RequestRegister* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(password_, other->password_);
    std::swap(email_, other->email_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegister::GetTypeName() const {
  return "Protocol.RequestRegister";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseRegister::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseRegister::ResponseRegister()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseRegister::InitAsDefaultInstance() {
}

ResponseRegister::ResponseRegister(const ResponseRegister& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseRegister::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseRegister::~ResponseRegister() {
  SharedDtor();
}

void ResponseRegister::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseRegister::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseRegister& ResponseRegister::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseRegister* ResponseRegister::default_instance_ = NULL;

ResponseRegister* ResponseRegister::New() const {
  return new ResponseRegister;
}

void ResponseRegister::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseRegister::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.RegisterError result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::RegisterError_IsValid(value)) {
            set_result(static_cast< ::Protocol::RegisterError >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseRegister::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.RegisterError result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

}

int ResponseRegister::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.RegisterError result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseRegister::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseRegister*>(&from));
}

void ResponseRegister::MergeFrom(const ResponseRegister& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseRegister::CopyFrom(const ResponseRegister& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseRegister::IsInitialized() const {

  return true;
}

void ResponseRegister::Swap(ResponseRegister* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseRegister::GetTypeName() const {
  return "Protocol.ResponseRegister";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestLogin::kVersionFieldNumber;
const int RequestLogin::kAccountFieldNumber;
const int RequestLogin::kPasswordFieldNumber;
#endif  // !_MSC_VER

RequestLogin::RequestLogin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestLogin::InitAsDefaultInstance() {
}

RequestLogin::RequestLogin(const RequestLogin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestLogin::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestLogin::~RequestLogin() {
  SharedDtor();
}

void RequestLogin::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestLogin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestLogin& RequestLogin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

RequestLogin* RequestLogin::default_instance_ = NULL;

RequestLogin* RequestLogin::New() const {
  return new RequestLogin;
}

void RequestLogin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_password()) {
      if (password_ != &::google::protobuf::internal::kEmptyString) {
        password_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestLogin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_password;
        break;
      }

      // optional string password = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_password:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestLogin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

  // optional string password = 3;
  if (has_password()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->password(), output);
  }

}

int RequestLogin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string password = 3;
    if (has_password()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestLogin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestLogin*>(&from));
}

void RequestLogin::MergeFrom(const RequestLogin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_password()) {
      set_password(from.password());
    }
  }
}

void RequestLogin::CopyFrom(const RequestLogin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestLogin::IsInitialized() const {

  return true;
}

void RequestLogin::Swap(RequestLogin* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(account_, other->account_);
    std::swap(password_, other->password_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestLogin::GetTypeName() const {
  return "Protocol.RequestLogin";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseLogin::kResultFieldNumber;
const int ResponseLogin::kLoginKeyFieldNumber;
const int ResponseLogin::kZoneListFieldNumber;
const int ResponseLogin::kCharListFieldNumber;
const int ResponseLogin::kLastZoneidFieldNumber;
#endif  // !_MSC_VER

ResponseLogin::ResponseLogin()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseLogin::InitAsDefaultInstance() {
}

ResponseLogin::ResponseLogin(const ResponseLogin& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseLogin::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  login_key_ = 0u;
  last_zoneid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseLogin::~ResponseLogin() {
  SharedDtor();
}

void ResponseLogin::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseLogin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseLogin& ResponseLogin::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseLogin* ResponseLogin::default_instance_ = NULL;

ResponseLogin* ResponseLogin::New() const {
  return new ResponseLogin;
}

void ResponseLogin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    login_key_ = 0u;
    last_zoneid_ = 0;
  }
  zone_list_.Clear();
  char_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseLogin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.LoginError result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::LoginError_IsValid(value)) {
            set_result(static_cast< ::Protocol::LoginError >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_login_key;
        break;
      }

      // optional uint32 login_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_login_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &login_key_)));
          set_has_login_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_zone_list;
        break;
      }

      // repeated .Protocol.ZoneInfo zone_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_zone_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_zone_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_zone_list;
        if (input->ExpectTag(34)) goto parse_char_list;
        break;
      }

      // repeated .Protocol.ZoneCharInfo char_list = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_char_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_char_list;
        if (input->ExpectTag(40)) goto parse_last_zoneid;
        break;
      }

      // optional int32 last_zoneid = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_last_zoneid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &last_zoneid_)));
          set_has_last_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseLogin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.LoginError result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional uint32 login_key = 2;
  if (has_login_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->login_key(), output);
  }

  // repeated .Protocol.ZoneInfo zone_list = 3;
  for (int i = 0; i < this->zone_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->zone_list(i), output);
  }

  // repeated .Protocol.ZoneCharInfo char_list = 4;
  for (int i = 0; i < this->char_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->char_list(i), output);
  }

  // optional int32 last_zoneid = 5;
  if (has_last_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->last_zoneid(), output);
  }

}

int ResponseLogin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.LoginError result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional uint32 login_key = 2;
    if (has_login_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->login_key());
    }

    // optional int32 last_zoneid = 5;
    if (has_last_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->last_zoneid());
    }

  }
  // repeated .Protocol.ZoneInfo zone_list = 3;
  total_size += 1 * this->zone_list_size();
  for (int i = 0; i < this->zone_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->zone_list(i));
  }

  // repeated .Protocol.ZoneCharInfo char_list = 4;
  total_size += 1 * this->char_list_size();
  for (int i = 0; i < this->char_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->char_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseLogin::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseLogin*>(&from));
}

void ResponseLogin::MergeFrom(const ResponseLogin& from) {
  GOOGLE_CHECK_NE(&from, this);
  zone_list_.MergeFrom(from.zone_list_);
  char_list_.MergeFrom(from.char_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_login_key()) {
      set_login_key(from.login_key());
    }
    if (from.has_last_zoneid()) {
      set_last_zoneid(from.last_zoneid());
    }
  }
}

void ResponseLogin::CopyFrom(const ResponseLogin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseLogin::IsInitialized() const {

  return true;
}

void ResponseLogin::Swap(ResponseLogin* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(login_key_, other->login_key_);
    zone_list_.Swap(&other->zone_list_);
    char_list_.Swap(&other->char_list_);
    std::swap(last_zoneid_, other->last_zoneid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseLogin::GetTypeName() const {
  return "Protocol.ResponseLogin";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestEnterServer::kAccountFieldNumber;
const int RequestEnterServer::kLoginKeyFieldNumber;
const int RequestEnterServer::kZoneidFieldNumber;
#endif  // !_MSC_VER

RequestEnterServer::RequestEnterServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestEnterServer::InitAsDefaultInstance() {
}

RequestEnterServer::RequestEnterServer(const RequestEnterServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestEnterServer::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  login_key_ = 0u;
  zoneid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestEnterServer::~RequestEnterServer() {
  SharedDtor();
}

void RequestEnterServer::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestEnterServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestEnterServer& RequestEnterServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

RequestEnterServer* RequestEnterServer::default_instance_ = NULL;

RequestEnterServer* RequestEnterServer::New() const {
  return new RequestEnterServer;
}

void RequestEnterServer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    login_key_ = 0u;
    zoneid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestEnterServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_login_key;
        break;
      }

      // optional uint32 login_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_login_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &login_key_)));
          set_has_login_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_zoneid;
        break;
      }

      // optional int32 zoneid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_zoneid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestEnterServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  // optional uint32 login_key = 2;
  if (has_login_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->login_key(), output);
  }

  // optional int32 zoneid = 3;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->zoneid(), output);
  }

}

int RequestEnterServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional uint32 login_key = 2;
    if (has_login_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->login_key());
    }

    // optional int32 zoneid = 3;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zoneid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestEnterServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestEnterServer*>(&from));
}

void RequestEnterServer::MergeFrom(const RequestEnterServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_login_key()) {
      set_login_key(from.login_key());
    }
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
  }
}

void RequestEnterServer::CopyFrom(const RequestEnterServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestEnterServer::IsInitialized() const {

  return true;
}

void RequestEnterServer::Swap(RequestEnterServer* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(login_key_, other->login_key_);
    std::swap(zoneid_, other->zoneid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestEnterServer::GetTypeName() const {
  return "Protocol.RequestEnterServer";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseEnterServer::kResultFieldNumber;
const int ResponseEnterServer::kIpFieldNumber;
const int ResponseEnterServer::kPortFieldNumber;
#endif  // !_MSC_VER

ResponseEnterServer::ResponseEnterServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseEnterServer::InitAsDefaultInstance() {
}

ResponseEnterServer::ResponseEnterServer(const ResponseEnterServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseEnterServer::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseEnterServer::~ResponseEnterServer() {
  SharedDtor();
}

void ResponseEnterServer::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseEnterServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseEnterServer& ResponseEnterServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseEnterServer* ResponseEnterServer::default_instance_ = NULL;

ResponseEnterServer* ResponseEnterServer::New() const {
  return new ResponseEnterServer;
}

void ResponseEnterServer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseEnterServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.EnterZoneError result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::EnterZoneError_IsValid(value)) {
            set_result(static_cast< ::Protocol::EnterZoneError >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }

      // optional string ip = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // optional int32 port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseEnterServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.EnterZoneError result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->ip(), output);
  }

  // optional int32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->port(), output);
  }

}

int ResponseEnterServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.EnterZoneError result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // optional string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional int32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseEnterServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseEnterServer*>(&from));
}

void ResponseEnterServer::MergeFrom(const ResponseEnterServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
}

void ResponseEnterServer::CopyFrom(const ResponseEnterServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseEnterServer::IsInitialized() const {

  return true;
}

void ResponseEnterServer::Swap(ResponseEnterServer* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseEnterServer::GetTypeName() const {
  return "Protocol.ResponseEnterServer";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)
