// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoGameData.proto

#ifndef PROTOBUF_ProtoGameData_2eproto__INCLUDED
#define PROTOBUF_ProtoGameData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoGameData_2eproto();
void protobuf_AssignDesc_ProtoGameData_2eproto();
void protobuf_ShutdownFile_ProtoGameData_2eproto();

class CharBase;
class CharData;
class EquipInfo;
class PetInfo;
class WingInfo;
class EquipAddInfo;
class ItemData;
class ShortcutKeyData;
class JobSkillData;
class SkillData;
class SkillBuffData;
class MissionData;
class AchievementData;
class ActivityData;
class SettingData;
class OnlineRewardsData;
class CounterData;
class CharBinaryData;
class MapCell;
class TileMapData;
class MapCharInfo;
class MapMonsterInfo;
class MapNpcInfo;
class ItemLoc;
class ItemLocData;
class ItemLocNum;

enum ShortcutKeyData_KeyType {
  ShortcutKeyData_KeyType_KEY_TYPE_NULL = 0,
  ShortcutKeyData_KeyType_KEY_TYPE_ITEM = 1,
  ShortcutKeyData_KeyType_KEY_TYPE_SKILL = 2
};
bool ShortcutKeyData_KeyType_IsValid(int value);
const ShortcutKeyData_KeyType ShortcutKeyData_KeyType_KeyType_MIN = ShortcutKeyData_KeyType_KEY_TYPE_NULL;
const ShortcutKeyData_KeyType ShortcutKeyData_KeyType_KeyType_MAX = ShortcutKeyData_KeyType_KEY_TYPE_SKILL;
const int ShortcutKeyData_KeyType_KeyType_ARRAYSIZE = ShortcutKeyData_KeyType_KeyType_MAX + 1;

enum MissionData_State {
  MissionData_State_UNCOMPLETE = 0,
  MissionData_State_COMPLETED = 1,
  MissionData_State_CLOSED = 2,
  MissionData_State_UNACCEPT = 3
};
bool MissionData_State_IsValid(int value);
const MissionData_State MissionData_State_State_MIN = MissionData_State_UNCOMPLETE;
const MissionData_State MissionData_State_State_MAX = MissionData_State_UNACCEPT;
const int MissionData_State_State_ARRAYSIZE = MissionData_State_State_MAX + 1;

enum AchievementData_State {
  AchievementData_State_UNCOMPLETE = 0,
  AchievementData_State_COMPLETED = 1,
  AchievementData_State_CLOSED = 2
};
bool AchievementData_State_IsValid(int value);
const AchievementData_State AchievementData_State_State_MIN = AchievementData_State_UNCOMPLETE;
const AchievementData_State AchievementData_State_State_MAX = AchievementData_State_CLOSED;
const int AchievementData_State_State_ARRAYSIZE = AchievementData_State_State_MAX + 1;

enum MapCellFlag {
  CELL_FLAG_PASS = 0,
  CELL_FLAG_BLOCK = 1
};
bool MapCellFlag_IsValid(int value);
const MapCellFlag MapCellFlag_MIN = CELL_FLAG_PASS;
const MapCellFlag MapCellFlag_MAX = CELL_FLAG_BLOCK;
const int MapCellFlag_ARRAYSIZE = MapCellFlag_MAX + 1;

enum ObjectState {
  OBJ_STATE_NORMAL = 1,
  OBJ_STATE_DEATH = 2
};
bool ObjectState_IsValid(int value);
const ObjectState ObjectState_MIN = OBJ_STATE_NORMAL;
const ObjectState ObjectState_MAX = OBJ_STATE_DEATH;
const int ObjectState_ARRAYSIZE = ObjectState_MAX + 1;

// ===================================================================

class CharBase : public ::google::protobuf::MessageLite {
 public:
  CharBase();
  virtual ~CharBase();

  CharBase(const CharBase& from);

  inline CharBase& operator=(const CharBase& from) {
    CopyFrom(from);
    return *this;
  }

  static const CharBase& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CharBase* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CharBase* other);

  // implements Message ----------------------------------------------

  CharBase* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CharBase& from);
  void MergeFrom(const CharBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string charname = 1;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 1;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 country = 2;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 2;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional int32 race = 3;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 3;
  inline ::google::protobuf::int32 race() const;
  inline void set_race(::google::protobuf::int32 value);

  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional uint64 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // optional uint64 gold = 6;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 6;
  inline ::google::protobuf::uint64 gold() const;
  inline void set_gold(::google::protobuf::uint64 value);

  // optional uint64 bindgold = 7;
  inline bool has_bindgold() const;
  inline void clear_bindgold();
  static const int kBindgoldFieldNumber = 7;
  inline ::google::protobuf::uint64 bindgold() const;
  inline void set_bindgold(::google::protobuf::uint64 value);

  // optional uint64 money = 8;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 8;
  inline ::google::protobuf::uint64 money() const;
  inline void set_money(::google::protobuf::uint64 value);

  // optional uint64 safemoney = 9;
  inline bool has_safemoney() const;
  inline void clear_safemoney();
  static const int kSafemoneyFieldNumber = 9;
  inline ::google::protobuf::uint64 safemoney() const;
  inline void set_safemoney(::google::protobuf::uint64 value);

  // optional int32 mapid = 10;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 10;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional int32 x = 11;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 11;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 12;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 12;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 total_score = 13;
  inline bool has_total_score() const;
  inline void clear_total_score();
  static const int kTotalScoreFieldNumber = 13;
  inline ::google::protobuf::int32 total_score() const;
  inline void set_total_score(::google::protobuf::int32 value);

  // optional int64 offline_time = 50;
  inline bool has_offline_time() const;
  inline void clear_offline_time();
  static const int kOfflineTimeFieldNumber = 50;
  inline ::google::protobuf::int64 offline_time() const;
  inline void set_offline_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:CharBase)
 private:
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_bindgold();
  inline void clear_has_bindgold();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_safemoney();
  inline void clear_has_safemoney();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_total_score();
  inline void clear_has_total_score();
  inline void set_has_offline_time();
  inline void clear_has_offline_time();

  ::std::string* charname_;
  ::google::protobuf::int32 country_;
  ::google::protobuf::int32 race_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint64 gold_;
  ::google::protobuf::uint64 bindgold_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::uint64 money_;
  ::google::protobuf::uint64 safemoney_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int64 offline_time_;
  ::google::protobuf::int32 total_score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static CharBase* default_instance_;
};
// -------------------------------------------------------------------

class CharData : public ::google::protobuf::MessageLite {
 public:
  CharData();
  virtual ~CharData();

  CharData(const CharData& from);

  inline CharData& operator=(const CharData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CharData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CharData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CharData* other);

  // implements Message ----------------------------------------------

  CharData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CharData& from);
  void MergeFrom(const CharData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool inited = 1;
  inline bool has_inited() const;
  inline void clear_inited();
  static const int kInitedFieldNumber = 1;
  inline bool inited() const;
  inline void set_inited(bool value);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional int32 nickcolor = 3;
  inline bool has_nickcolor() const;
  inline void clear_nickcolor();
  static const int kNickcolorFieldNumber = 3;
  inline ::google::protobuf::int32 nickcolor() const;
  inline void set_nickcolor(::google::protobuf::int32 value);

  // optional int32 job = 4;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 4;
  inline ::google::protobuf::int32 job() const;
  inline void set_job(::google::protobuf::int32 value);

  // optional int32 levelup_point = 5;
  inline bool has_levelup_point() const;
  inline void clear_levelup_point();
  static const int kLevelupPointFieldNumber = 5;
  inline ::google::protobuf::int32 levelup_point() const;
  inline void set_levelup_point(::google::protobuf::int32 value);

  // optional int32 health = 13;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 13;
  inline ::google::protobuf::int32 health() const;
  inline void set_health(::google::protobuf::int32 value);

  // optional int32 hp = 14;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 14;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 mp = 15;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 15;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // optional int32 sp = 16;
  inline bool has_sp() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 16;
  inline ::google::protobuf::int32 sp() const;
  inline void set_sp(::google::protobuf::int32 value);

  // optional int32 jp = 17;
  inline bool has_jp() const;
  inline void clear_jp();
  static const int kJpFieldNumber = 17;
  inline ::google::protobuf::int32 jp() const;
  inline void set_jp(::google::protobuf::int32 value);

  // optional int32 hungry = 18 [default = 100];
  inline bool has_hungry() const;
  inline void clear_hungry();
  static const int kHungryFieldNumber = 18;
  inline ::google::protobuf::int32 hungry() const;
  inline void set_hungry(::google::protobuf::int32 value);

  // optional int32 str = 19;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 19;
  inline ::google::protobuf::int32 str() const;
  inline void set_str(::google::protobuf::int32 value);

  // optional int32 dex = 20;
  inline bool has_dex() const;
  inline void clear_dex();
  static const int kDexFieldNumber = 20;
  inline ::google::protobuf::int32 dex() const;
  inline void set_dex(::google::protobuf::int32 value);

  // optional int32 intgent = 21;
  inline bool has_intgent() const;
  inline void clear_intgent();
  static const int kIntgentFieldNumber = 21;
  inline ::google::protobuf::int32 intgent() const;
  inline void set_intgent(::google::protobuf::int32 value);

  // optional int32 con = 22;
  inline bool has_con() const;
  inline void clear_con();
  static const int kConFieldNumber = 22;
  inline ::google::protobuf::int32 con() const;
  inline void set_con(::google::protobuf::int32 value);

  // optional int32 wiz = 23;
  inline bool has_wiz() const;
  inline void clear_wiz();
  static const int kWizFieldNumber = 23;
  inline ::google::protobuf::int32 wiz() const;
  inline void set_wiz(::google::protobuf::int32 value);

  // optional int32 pkcount = 26;
  inline bool has_pkcount() const;
  inline void clear_pkcount();
  static const int kPkcountFieldNumber = 26;
  inline ::google::protobuf::int32 pkcount() const;
  inline void set_pkcount(::google::protobuf::int32 value);

  // optional int32 battle_prop = 30;
  inline bool has_battle_prop() const;
  inline void clear_battle_prop();
  static const int kBattlePropFieldNumber = 30;
  inline ::google::protobuf::int32 battle_prop() const;
  inline void set_battle_prop(::google::protobuf::int32 value);

  // optional int32 reincarnate = 32;
  inline bool has_reincarnate() const;
  inline void clear_reincarnate();
  static const int kReincarnateFieldNumber = 32;
  inline ::google::protobuf::int32 reincarnate() const;
  inline void set_reincarnate(::google::protobuf::int32 value);

  // optional int32 renpin = 33;
  inline bool has_renpin() const;
  inline void clear_renpin();
  static const int kRenpinFieldNumber = 33;
  inline ::google::protobuf::int32 renpin() const;
  inline void set_renpin(::google::protobuf::int32 value);

  // optional int32 bagsize = 34;
  inline bool has_bagsize() const;
  inline void clear_bagsize();
  static const int kBagsizeFieldNumber = 34;
  inline ::google::protobuf::int32 bagsize() const;
  inline void set_bagsize(::google::protobuf::int32 value);

  // optional int32 safesize = 35;
  inline bool has_safesize() const;
  inline void clear_safesize();
  static const int kSafesizeFieldNumber = 35;
  inline ::google::protobuf::int32 safesize() const;
  inline void set_safesize(::google::protobuf::int32 value);

  // optional int32 chat_channel = 36;
  inline bool has_chat_channel() const;
  inline void clear_chat_channel();
  static const int kChatChannelFieldNumber = 36;
  inline ::google::protobuf::int32 chat_channel() const;
  inline void set_chat_channel(::google::protobuf::int32 value);

  // optional uint64 total_gold = 37;
  inline bool has_total_gold() const;
  inline void clear_total_gold();
  static const int kTotalGoldFieldNumber = 37;
  inline ::google::protobuf::uint64 total_gold() const;
  inline void set_total_gold(::google::protobuf::uint64 value);

  // optional int32 vip_award_id = 38;
  inline bool has_vip_award_id() const;
  inline void clear_vip_award_id();
  static const int kVipAwardIdFieldNumber = 38;
  inline ::google::protobuf::int32 vip_award_id() const;
  inline void set_vip_award_id(::google::protobuf::int32 value);

  // optional int32 kill_enemy = 39;
  inline bool has_kill_enemy() const;
  inline void clear_kill_enemy();
  static const int kKillEnemyFieldNumber = 39;
  inline ::google::protobuf::int32 kill_enemy() const;
  inline void set_kill_enemy(::google::protobuf::int32 value);

  // optional int32 serial_login_day = 40 [default = 1];
  inline bool has_serial_login_day() const;
  inline void clear_serial_login_day();
  static const int kSerialLoginDayFieldNumber = 40;
  inline ::google::protobuf::int32 serial_login_day() const;
  inline void set_serial_login_day(::google::protobuf::int32 value);

  // optional int32 copies_map = 41;
  inline bool has_copies_map() const;
  inline void clear_copies_map();
  static const int kCopiesMapFieldNumber = 41;
  inline ::google::protobuf::int32 copies_map() const;
  inline void set_copies_map(::google::protobuf::int32 value);

  // optional int32 total_guild_credits = 42;
  inline bool has_total_guild_credits() const;
  inline void clear_total_guild_credits();
  static const int kTotalGuildCreditsFieldNumber = 42;
  inline ::google::protobuf::int32 total_guild_credits() const;
  inline void set_total_guild_credits(::google::protobuf::int32 value);

  // optional int32 field_mapid = 43;
  inline bool has_field_mapid() const;
  inline void clear_field_mapid();
  static const int kFieldMapidFieldNumber = 43;
  inline ::google::protobuf::int32 field_mapid() const;
  inline void set_field_mapid(::google::protobuf::int32 value);

  // optional int32 field_mapx = 44;
  inline bool has_field_mapx() const;
  inline void clear_field_mapx();
  static const int kFieldMapxFieldNumber = 44;
  inline ::google::protobuf::int32 field_mapx() const;
  inline void set_field_mapx(::google::protobuf::int32 value);

  // optional int32 field_mapy = 45;
  inline bool has_field_mapy() const;
  inline void clear_field_mapy();
  static const int kFieldMapyFieldNumber = 45;
  inline ::google::protobuf::int32 field_mapy() const;
  inline void set_field_mapy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CharData)
 private:
  inline void set_has_inited();
  inline void clear_has_inited();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_nickcolor();
  inline void clear_has_nickcolor();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_levelup_point();
  inline void clear_has_levelup_point();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_sp();
  inline void clear_has_sp();
  inline void set_has_jp();
  inline void clear_has_jp();
  inline void set_has_hungry();
  inline void clear_has_hungry();
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_dex();
  inline void clear_has_dex();
  inline void set_has_intgent();
  inline void clear_has_intgent();
  inline void set_has_con();
  inline void clear_has_con();
  inline void set_has_wiz();
  inline void clear_has_wiz();
  inline void set_has_pkcount();
  inline void clear_has_pkcount();
  inline void set_has_battle_prop();
  inline void clear_has_battle_prop();
  inline void set_has_reincarnate();
  inline void clear_has_reincarnate();
  inline void set_has_renpin();
  inline void clear_has_renpin();
  inline void set_has_bagsize();
  inline void clear_has_bagsize();
  inline void set_has_safesize();
  inline void clear_has_safesize();
  inline void set_has_chat_channel();
  inline void clear_has_chat_channel();
  inline void set_has_total_gold();
  inline void clear_has_total_gold();
  inline void set_has_vip_award_id();
  inline void clear_has_vip_award_id();
  inline void set_has_kill_enemy();
  inline void clear_has_kill_enemy();
  inline void set_has_serial_login_day();
  inline void clear_has_serial_login_day();
  inline void set_has_copies_map();
  inline void clear_has_copies_map();
  inline void set_has_total_guild_credits();
  inline void clear_has_total_guild_credits();
  inline void set_has_field_mapid();
  inline void clear_has_field_mapid();
  inline void set_has_field_mapx();
  inline void clear_has_field_mapx();
  inline void set_has_field_mapy();
  inline void clear_has_field_mapy();

  ::std::string* nickname_;
  bool inited_;
  ::google::protobuf::int32 nickcolor_;
  ::google::protobuf::int32 job_;
  ::google::protobuf::int32 levelup_point_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 mp_;
  ::google::protobuf::int32 sp_;
  ::google::protobuf::int32 jp_;
  ::google::protobuf::int32 hungry_;
  ::google::protobuf::int32 str_;
  ::google::protobuf::int32 dex_;
  ::google::protobuf::int32 intgent_;
  ::google::protobuf::int32 con_;
  ::google::protobuf::int32 wiz_;
  ::google::protobuf::int32 pkcount_;
  ::google::protobuf::int32 battle_prop_;
  ::google::protobuf::int32 reincarnate_;
  ::google::protobuf::int32 renpin_;
  ::google::protobuf::int32 bagsize_;
  ::google::protobuf::int32 safesize_;
  ::google::protobuf::int32 chat_channel_;
  ::google::protobuf::uint64 total_gold_;
  ::google::protobuf::int32 vip_award_id_;
  ::google::protobuf::int32 kill_enemy_;
  ::google::protobuf::int32 serial_login_day_;
  ::google::protobuf::int32 copies_map_;
  ::google::protobuf::int32 total_guild_credits_;
  ::google::protobuf::int32 field_mapid_;
  ::google::protobuf::int32 field_mapx_;
  ::google::protobuf::int32 field_mapy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(32 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static CharData* default_instance_;
};
// -------------------------------------------------------------------

class EquipInfo : public ::google::protobuf::MessageLite {
 public:
  EquipInfo();
  virtual ~EquipInfo();

  EquipInfo(const EquipInfo& from);

  inline EquipInfo& operator=(const EquipInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const EquipInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EquipInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EquipInfo* other);

  // implements Message ----------------------------------------------

  EquipInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EquipInfo& from);
  void MergeFrom(const EquipInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 duration = 1;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 1;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional int32 frozen = 2;
  inline bool has_frozen() const;
  inline void clear_frozen();
  static const int kFrozenFieldNumber = 2;
  inline ::google::protobuf::int32 frozen() const;
  inline void set_frozen(::google::protobuf::int32 value);

  // optional int32 prop = 3;
  inline bool has_prop() const;
  inline void clear_prop();
  static const int kPropFieldNumber = 3;
  inline ::google::protobuf::int32 prop() const;
  inline void set_prop(::google::protobuf::int32 value);

  // optional int32 star = 4;
  inline bool has_star() const;
  inline void clear_star();
  static const int kStarFieldNumber = 4;
  inline ::google::protobuf::int32 star() const;
  inline void set_star(::google::protobuf::int32 value);

  // repeated int32 grooves = 5;
  inline int grooves_size() const;
  inline void clear_grooves();
  static const int kGroovesFieldNumber = 5;
  inline ::google::protobuf::int32 grooves(int index) const;
  inline void set_grooves(int index, ::google::protobuf::int32 value);
  inline void add_grooves(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      grooves() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_grooves();

  // optional int32 upgrade = 6;
  inline bool has_upgrade() const;
  inline void clear_upgrade();
  static const int kUpgradeFieldNumber = 6;
  inline ::google::protobuf::int32 upgrade() const;
  inline void set_upgrade(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EquipInfo)
 private:
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_frozen();
  inline void clear_has_frozen();
  inline void set_has_prop();
  inline void clear_has_prop();
  inline void set_has_star();
  inline void clear_has_star();
  inline void set_has_upgrade();
  inline void clear_has_upgrade();

  ::google::protobuf::int32 duration_;
  ::google::protobuf::int32 frozen_;
  ::google::protobuf::int32 prop_;
  ::google::protobuf::int32 star_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > grooves_;
  ::google::protobuf::int32 upgrade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static EquipInfo* default_instance_;
};
// -------------------------------------------------------------------

class PetInfo : public ::google::protobuf::MessageLite {
 public:
  PetInfo();
  virtual ~PetInfo();

  PetInfo(const PetInfo& from);

  inline PetInfo& operator=(const PetInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PetInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PetInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PetInfo* other);

  // implements Message ----------------------------------------------

  PetInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PetInfo& from);
  void MergeFrom(const PetInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 property = 1;
  inline bool has_property() const;
  inline void clear_property();
  static const int kPropertyFieldNumber = 1;
  inline ::google::protobuf::int32 property() const;
  inline void set_property(::google::protobuf::int32 value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 hp = 4;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 4;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PetInfo)
 private:
  inline void set_has_property();
  inline void clear_has_property();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_hp();
  inline void clear_has_hp();

  ::google::protobuf::int32 property_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 hp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static PetInfo* default_instance_;
};
// -------------------------------------------------------------------

class WingInfo : public ::google::protobuf::MessageLite {
 public:
  WingInfo();
  virtual ~WingInfo();

  WingInfo(const WingInfo& from);

  inline WingInfo& operator=(const WingInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const WingInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WingInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WingInfo* other);

  // implements Message ----------------------------------------------

  WingInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WingInfo& from);
  void MergeFrom(const WingInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WingInfo)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();

  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static WingInfo* default_instance_;
};
// -------------------------------------------------------------------

class EquipAddInfo : public ::google::protobuf::MessageLite {
 public:
  EquipAddInfo();
  virtual ~EquipAddInfo();

  EquipAddInfo(const EquipAddInfo& from);

  inline EquipAddInfo& operator=(const EquipAddInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const EquipAddInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EquipAddInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EquipAddInfo* other);

  // implements Message ----------------------------------------------

  EquipAddInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EquipAddInfo& from);
  void MergeFrom(const EquipAddInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline ::google::protobuf::int32 str() const;
  inline void set_str(::google::protobuf::int32 value);

  // optional int32 con = 2;
  inline bool has_con() const;
  inline void clear_con();
  static const int kConFieldNumber = 2;
  inline ::google::protobuf::int32 con() const;
  inline void set_con(::google::protobuf::int32 value);

  // optional int32 dex = 3;
  inline bool has_dex() const;
  inline void clear_dex();
  static const int kDexFieldNumber = 3;
  inline ::google::protobuf::int32 dex() const;
  inline void set_dex(::google::protobuf::int32 value);

  // optional int32 wiz = 4;
  inline bool has_wiz() const;
  inline void clear_wiz();
  static const int kWizFieldNumber = 4;
  inline ::google::protobuf::int32 wiz() const;
  inline void set_wiz(::google::protobuf::int32 value);

  // optional int32 intgent = 5;
  inline bool has_intgent() const;
  inline void clear_intgent();
  static const int kIntgentFieldNumber = 5;
  inline ::google::protobuf::int32 intgent() const;
  inline void set_intgent(::google::protobuf::int32 value);

  // optional int32 attack = 6;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 6;
  inline ::google::protobuf::int32 attack() const;
  inline void set_attack(::google::protobuf::int32 value);

  // optional int32 attack_per = 7;
  inline bool has_attack_per() const;
  inline void clear_attack_per();
  static const int kAttackPerFieldNumber = 7;
  inline ::google::protobuf::int32 attack_per() const;
  inline void set_attack_per(::google::protobuf::int32 value);

  // optional int32 critical = 8;
  inline bool has_critical() const;
  inline void clear_critical();
  static const int kCriticalFieldNumber = 8;
  inline ::google::protobuf::int32 critical() const;
  inline void set_critical(::google::protobuf::int32 value);

  // optional int32 none2 = 9;
  inline bool has_none2() const;
  inline void clear_none2();
  static const int kNone2FieldNumber = 9;
  inline ::google::protobuf::int32 none2() const;
  inline void set_none2(::google::protobuf::int32 value);

  // optional int32 phydef = 10;
  inline bool has_phydef() const;
  inline void clear_phydef();
  static const int kPhydefFieldNumber = 10;
  inline ::google::protobuf::int32 phydef() const;
  inline void set_phydef(::google::protobuf::int32 value);

  // optional int32 phydef_per = 11;
  inline bool has_phydef_per() const;
  inline void clear_phydef_per();
  static const int kPhydefPerFieldNumber = 11;
  inline ::google::protobuf::int32 phydef_per() const;
  inline void set_phydef_per(::google::protobuf::int32 value);

  // optional int32 magdef = 12;
  inline bool has_magdef() const;
  inline void clear_magdef();
  static const int kMagdefFieldNumber = 12;
  inline ::google::protobuf::int32 magdef() const;
  inline void set_magdef(::google::protobuf::int32 value);

  // optional int32 magdef_per = 13;
  inline bool has_magdef_per() const;
  inline void clear_magdef_per();
  static const int kMagdefPerFieldNumber = 13;
  inline ::google::protobuf::int32 magdef_per() const;
  inline void set_magdef_per(::google::protobuf::int32 value);

  // optional int32 hp = 14;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 14;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 hp_per = 15;
  inline bool has_hp_per() const;
  inline void clear_hp_per();
  static const int kHpPerFieldNumber = 15;
  inline ::google::protobuf::int32 hp_per() const;
  inline void set_hp_per(::google::protobuf::int32 value);

  // optional int32 mp = 16;
  inline bool has_mp() const;
  inline void clear_mp();
  static const int kMpFieldNumber = 16;
  inline ::google::protobuf::int32 mp() const;
  inline void set_mp(::google::protobuf::int32 value);

  // optional int32 mp_per = 17;
  inline bool has_mp_per() const;
  inline void clear_mp_per();
  static const int kMpPerFieldNumber = 17;
  inline ::google::protobuf::int32 mp_per() const;
  inline void set_mp_per(::google::protobuf::int32 value);

  // optional int32 sp = 18;
  inline bool has_sp() const;
  inline void clear_sp();
  static const int kSpFieldNumber = 18;
  inline ::google::protobuf::int32 sp() const;
  inline void set_sp(::google::protobuf::int32 value);

  // optional int32 sp_per = 19;
  inline bool has_sp_per() const;
  inline void clear_sp_per();
  static const int kSpPerFieldNumber = 19;
  inline ::google::protobuf::int32 sp_per() const;
  inline void set_sp_per(::google::protobuf::int32 value);

  // optional int32 atk_acc = 20;
  inline bool has_atk_acc() const;
  inline void clear_atk_acc();
  static const int kAtkAccFieldNumber = 20;
  inline ::google::protobuf::int32 atk_acc() const;
  inline void set_atk_acc(::google::protobuf::int32 value);

  // optional int32 def_acc = 21;
  inline bool has_def_acc() const;
  inline void clear_def_acc();
  static const int kDefAccFieldNumber = 21;
  inline ::google::protobuf::int32 def_acc() const;
  inline void set_def_acc(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EquipAddInfo)
 private:
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_con();
  inline void clear_has_con();
  inline void set_has_dex();
  inline void clear_has_dex();
  inline void set_has_wiz();
  inline void clear_has_wiz();
  inline void set_has_intgent();
  inline void clear_has_intgent();
  inline void set_has_attack();
  inline void clear_has_attack();
  inline void set_has_attack_per();
  inline void clear_has_attack_per();
  inline void set_has_critical();
  inline void clear_has_critical();
  inline void set_has_none2();
  inline void clear_has_none2();
  inline void set_has_phydef();
  inline void clear_has_phydef();
  inline void set_has_phydef_per();
  inline void clear_has_phydef_per();
  inline void set_has_magdef();
  inline void clear_has_magdef();
  inline void set_has_magdef_per();
  inline void clear_has_magdef_per();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_hp_per();
  inline void clear_has_hp_per();
  inline void set_has_mp();
  inline void clear_has_mp();
  inline void set_has_mp_per();
  inline void clear_has_mp_per();
  inline void set_has_sp();
  inline void clear_has_sp();
  inline void set_has_sp_per();
  inline void clear_has_sp_per();
  inline void set_has_atk_acc();
  inline void clear_has_atk_acc();
  inline void set_has_def_acc();
  inline void clear_has_def_acc();

  ::google::protobuf::int32 str_;
  ::google::protobuf::int32 con_;
  ::google::protobuf::int32 dex_;
  ::google::protobuf::int32 wiz_;
  ::google::protobuf::int32 intgent_;
  ::google::protobuf::int32 attack_;
  ::google::protobuf::int32 attack_per_;
  ::google::protobuf::int32 critical_;
  ::google::protobuf::int32 none2_;
  ::google::protobuf::int32 phydef_;
  ::google::protobuf::int32 phydef_per_;
  ::google::protobuf::int32 magdef_;
  ::google::protobuf::int32 magdef_per_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 hp_per_;
  ::google::protobuf::int32 mp_;
  ::google::protobuf::int32 mp_per_;
  ::google::protobuf::int32 sp_;
  ::google::protobuf::int32 sp_per_;
  ::google::protobuf::int32 atk_acc_;
  ::google::protobuf::int32 def_acc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static EquipAddInfo* default_instance_;
};
// -------------------------------------------------------------------

class ItemData : public ::google::protobuf::MessageLite {
 public:
  ItemData();
  virtual ~ItemData();

  ItemData(const ItemData& from);

  inline ItemData& operator=(const ItemData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemData* other);

  // implements Message ----------------------------------------------

  ItemData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemData& from);
  void MergeFrom(const ItemData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional int32 item_id = 2;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // optional int32 slot = 3;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 3;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // optional int32 bind = 4;
  inline bool has_bind() const;
  inline void clear_bind();
  static const int kBindFieldNumber = 4;
  inline ::google::protobuf::int32 bind() const;
  inline void set_bind(::google::protobuf::int32 value);

  // optional int32 overlay = 5 [default = 1];
  inline bool has_overlay() const;
  inline void clear_overlay();
  static const int kOverlayFieldNumber = 5;
  inline ::google::protobuf::int32 overlay() const;
  inline void set_overlay(::google::protobuf::int32 value);

  // optional int32 quality = 6;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 6;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // optional int64 expired_time = 7;
  inline bool has_expired_time() const;
  inline void clear_expired_time();
  static const int kExpiredTimeFieldNumber = 7;
  inline ::google::protobuf::int64 expired_time() const;
  inline void set_expired_time(::google::protobuf::int64 value);

  // optional .EquipInfo equip_info = 100;
  inline bool has_equip_info() const;
  inline void clear_equip_info();
  static const int kEquipInfoFieldNumber = 100;
  inline const ::EquipInfo& equip_info() const;
  inline ::EquipInfo* mutable_equip_info();
  inline ::EquipInfo* release_equip_info();
  inline void set_allocated_equip_info(::EquipInfo* equip_info);

  // optional .PetInfo pet_info = 200;
  inline bool has_pet_info() const;
  inline void clear_pet_info();
  static const int kPetInfoFieldNumber = 200;
  inline const ::PetInfo& pet_info() const;
  inline ::PetInfo* mutable_pet_info();
  inline ::PetInfo* release_pet_info();
  inline void set_allocated_pet_info(::PetInfo* pet_info);

  // optional .WingInfo wing_info = 300;
  inline bool has_wing_info() const;
  inline void clear_wing_info();
  static const int kWingInfoFieldNumber = 300;
  inline const ::WingInfo& wing_info() const;
  inline ::WingInfo* mutable_wing_info();
  inline ::WingInfo* release_wing_info();
  inline void set_allocated_wing_info(::WingInfo* wing_info);

  // optional .EquipAddInfo equip_add_info = 400;
  inline bool has_equip_add_info() const;
  inline void clear_equip_add_info();
  static const int kEquipAddInfoFieldNumber = 400;
  inline const ::EquipAddInfo& equip_add_info() const;
  inline ::EquipAddInfo* mutable_equip_add_info();
  inline ::EquipAddInfo* release_equip_add_info();
  inline void set_allocated_equip_add_info(::EquipAddInfo* equip_add_info);

  // @@protoc_insertion_point(class_scope:ItemData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_slot();
  inline void clear_has_slot();
  inline void set_has_bind();
  inline void clear_has_bind();
  inline void set_has_overlay();
  inline void clear_has_overlay();
  inline void set_has_quality();
  inline void clear_has_quality();
  inline void set_has_expired_time();
  inline void clear_has_expired_time();
  inline void set_has_equip_info();
  inline void clear_has_equip_info();
  inline void set_has_pet_info();
  inline void clear_has_pet_info();
  inline void set_has_wing_info();
  inline void clear_has_wing_info();
  inline void set_has_equip_add_info();
  inline void clear_has_equip_add_info();

  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 slot_;
  ::google::protobuf::int32 bind_;
  ::google::protobuf::int32 overlay_;
  ::google::protobuf::int32 quality_;
  ::google::protobuf::int64 expired_time_;
  ::EquipInfo* equip_info_;
  ::PetInfo* pet_info_;
  ::WingInfo* wing_info_;
  ::EquipAddInfo* equip_add_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static ItemData* default_instance_;
};
// -------------------------------------------------------------------

class ShortcutKeyData : public ::google::protobuf::MessageLite {
 public:
  ShortcutKeyData();
  virtual ~ShortcutKeyData();

  ShortcutKeyData(const ShortcutKeyData& from);

  inline ShortcutKeyData& operator=(const ShortcutKeyData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ShortcutKeyData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShortcutKeyData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShortcutKeyData* other);

  // implements Message ----------------------------------------------

  ShortcutKeyData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShortcutKeyData& from);
  void MergeFrom(const ShortcutKeyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ShortcutKeyData_KeyType KeyType;
  static const KeyType KEY_TYPE_NULL = ShortcutKeyData_KeyType_KEY_TYPE_NULL;
  static const KeyType KEY_TYPE_ITEM = ShortcutKeyData_KeyType_KEY_TYPE_ITEM;
  static const KeyType KEY_TYPE_SKILL = ShortcutKeyData_KeyType_KEY_TYPE_SKILL;
  static inline bool KeyType_IsValid(int value) {
    return ShortcutKeyData_KeyType_IsValid(value);
  }
  static const KeyType KeyType_MIN =
    ShortcutKeyData_KeyType_KeyType_MIN;
  static const KeyType KeyType_MAX =
    ShortcutKeyData_KeyType_KeyType_MAX;
  static const int KeyType_ARRAYSIZE =
    ShortcutKeyData_KeyType_KeyType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .ShortcutKeyData.KeyType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::ShortcutKeyData_KeyType type() const;
  inline void set_type(::ShortcutKeyData_KeyType value);

  // optional int32 key_slot = 2;
  inline bool has_key_slot() const;
  inline void clear_key_slot();
  static const int kKeySlotFieldNumber = 2;
  inline ::google::protobuf::int32 key_slot() const;
  inline void set_key_slot(::google::protobuf::int32 value);

  // optional int32 item_id = 3;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // optional int32 item_slot = 4;
  inline bool has_item_slot() const;
  inline void clear_item_slot();
  static const int kItemSlotFieldNumber = 4;
  inline ::google::protobuf::int32 item_slot() const;
  inline void set_item_slot(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShortcutKeyData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_key_slot();
  inline void clear_has_key_slot();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_slot();
  inline void clear_has_item_slot();

  int type_;
  ::google::protobuf::int32 key_slot_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 item_slot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static ShortcutKeyData* default_instance_;
};
// -------------------------------------------------------------------

class JobSkillData : public ::google::protobuf::MessageLite {
 public:
  JobSkillData();
  virtual ~JobSkillData();

  JobSkillData(const JobSkillData& from);

  inline JobSkillData& operator=(const JobSkillData& from) {
    CopyFrom(from);
    return *this;
  }

  static const JobSkillData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JobSkillData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JobSkillData* other);

  // implements Message ----------------------------------------------

  JobSkillData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JobSkillData& from);
  void MergeFrom(const JobSkillData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::int32 skill_id() const;
  inline void set_skill_id(::google::protobuf::int32 value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int64 cd_time = 4;
  inline bool has_cd_time() const;
  inline void clear_cd_time();
  static const int kCdTimeFieldNumber = 4;
  inline ::google::protobuf::int64 cd_time() const;
  inline void set_cd_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:JobSkillData)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_cd_time();
  inline void clear_has_cd_time();

  ::google::protobuf::int32 skill_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int64 cd_time_;
  ::google::protobuf::int32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static JobSkillData* default_instance_;
};
// -------------------------------------------------------------------

class SkillData : public ::google::protobuf::MessageLite {
 public:
  SkillData();
  virtual ~SkillData();

  SkillData(const SkillData& from);

  inline SkillData& operator=(const SkillData& from) {
    CopyFrom(from);
    return *this;
  }

  static const SkillData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SkillData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SkillData* other);

  // implements Message ----------------------------------------------

  SkillData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SkillData& from);
  void MergeFrom(const SkillData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 skill_id = 1;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 1;
  inline ::google::protobuf::int32 skill_id() const;
  inline void set_skill_id(::google::protobuf::int32 value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 exp = 3;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 3;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int64 cd_time = 4;
  inline bool has_cd_time() const;
  inline void clear_cd_time();
  static const int kCdTimeFieldNumber = 4;
  inline ::google::protobuf::int64 cd_time() const;
  inline void set_cd_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SkillData)
 private:
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_cd_time();
  inline void clear_has_cd_time();

  ::google::protobuf::int32 skill_id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int64 cd_time_;
  ::google::protobuf::int32 exp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static SkillData* default_instance_;
};
// -------------------------------------------------------------------

class SkillBuffData : public ::google::protobuf::MessageLite {
 public:
  SkillBuffData();
  virtual ~SkillBuffData();

  SkillBuffData(const SkillBuffData& from);

  inline SkillBuffData& operator=(const SkillBuffData& from) {
    CopyFrom(from);
    return *this;
  }

  static const SkillBuffData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SkillBuffData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SkillBuffData* other);

  // implements Message ----------------------------------------------

  SkillBuffData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SkillBuffData& from);
  void MergeFrom(const SkillBuffData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 attacker_id = 1;
  inline bool has_attacker_id() const;
  inline void clear_attacker_id();
  static const int kAttackerIdFieldNumber = 1;
  inline ::google::protobuf::int32 attacker_id() const;
  inline void set_attacker_id(::google::protobuf::int32 value);

  // optional int32 buff_id = 2;
  inline bool has_buff_id() const;
  inline void clear_buff_id();
  static const int kBuffIdFieldNumber = 2;
  inline ::google::protobuf::int32 buff_id() const;
  inline void set_buff_id(::google::protobuf::int32 value);

  // optional int32 skill_id = 3;
  inline bool has_skill_id() const;
  inline void clear_skill_id();
  static const int kSkillIdFieldNumber = 3;
  inline ::google::protobuf::int32 skill_id() const;
  inline void set_skill_id(::google::protobuf::int32 value);

  // optional int32 skill_level = 4;
  inline bool has_skill_level() const;
  inline void clear_skill_level();
  static const int kSkillLevelFieldNumber = 4;
  inline ::google::protobuf::int32 skill_level() const;
  inline void set_skill_level(::google::protobuf::int32 value);

  // optional int32 remain_time = 5;
  inline bool has_remain_time() const;
  inline void clear_remain_time();
  static const int kRemainTimeFieldNumber = 5;
  inline ::google::protobuf::int32 remain_time() const;
  inline void set_remain_time(::google::protobuf::int32 value);

  // optional int32 param1 = 6;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 6;
  inline ::google::protobuf::int32 param1() const;
  inline void set_param1(::google::protobuf::int32 value);

  // optional int32 param2 = 7;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 7;
  inline ::google::protobuf::int32 param2() const;
  inline void set_param2(::google::protobuf::int32 value);

  // optional int32 param3 = 8;
  inline bool has_param3() const;
  inline void clear_param3();
  static const int kParam3FieldNumber = 8;
  inline ::google::protobuf::int32 param3() const;
  inline void set_param3(::google::protobuf::int32 value);

  // optional int32 param4 = 9;
  inline bool has_param4() const;
  inline void clear_param4();
  static const int kParam4FieldNumber = 9;
  inline ::google::protobuf::int32 param4() const;
  inline void set_param4(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SkillBuffData)
 private:
  inline void set_has_attacker_id();
  inline void clear_has_attacker_id();
  inline void set_has_buff_id();
  inline void clear_has_buff_id();
  inline void set_has_skill_id();
  inline void clear_has_skill_id();
  inline void set_has_skill_level();
  inline void clear_has_skill_level();
  inline void set_has_remain_time();
  inline void clear_has_remain_time();
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_param3();
  inline void clear_has_param3();
  inline void set_has_param4();
  inline void clear_has_param4();

  ::google::protobuf::int32 attacker_id_;
  ::google::protobuf::int32 buff_id_;
  ::google::protobuf::int32 skill_id_;
  ::google::protobuf::int32 skill_level_;
  ::google::protobuf::int32 remain_time_;
  ::google::protobuf::int32 param1_;
  ::google::protobuf::int32 param2_;
  ::google::protobuf::int32 param3_;
  ::google::protobuf::int32 param4_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static SkillBuffData* default_instance_;
};
// -------------------------------------------------------------------

class MissionData : public ::google::protobuf::MessageLite {
 public:
  MissionData();
  virtual ~MissionData();

  MissionData(const MissionData& from);

  inline MissionData& operator=(const MissionData& from) {
    CopyFrom(from);
    return *this;
  }

  static const MissionData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MissionData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MissionData* other);

  // implements Message ----------------------------------------------

  MissionData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MissionData& from);
  void MergeFrom(const MissionData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MissionData_State State;
  static const State UNCOMPLETE = MissionData_State_UNCOMPLETE;
  static const State COMPLETED = MissionData_State_COMPLETED;
  static const State CLOSED = MissionData_State_CLOSED;
  static const State UNACCEPT = MissionData_State_UNACCEPT;
  static inline bool State_IsValid(int value) {
    return MissionData_State_IsValid(value);
  }
  static const State State_MIN =
    MissionData_State_State_MIN;
  static const State State_MAX =
    MissionData_State_State_MAX;
  static const int State_ARRAYSIZE =
    MissionData_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .MissionData.State state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::MissionData_State state() const;
  inline void set_state(::MissionData_State value);

  // optional int32 mon_num = 3;
  inline bool has_mon_num() const;
  inline void clear_mon_num();
  static const int kMonNumFieldNumber = 3;
  inline ::google::protobuf::int32 mon_num() const;
  inline void set_mon_num(::google::protobuf::int32 value);

  // optional int32 item_num = 4;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 4;
  inline ::google::protobuf::int32 item_num() const;
  inline void set_item_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MissionData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_mon_num();
  inline void clear_has_mon_num();
  inline void set_has_item_num();
  inline void clear_has_item_num();

  ::google::protobuf::int32 id_;
  int state_;
  ::google::protobuf::int32 mon_num_;
  ::google::protobuf::int32 item_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static MissionData* default_instance_;
};
// -------------------------------------------------------------------

class AchievementData : public ::google::protobuf::MessageLite {
 public:
  AchievementData();
  virtual ~AchievementData();

  AchievementData(const AchievementData& from);

  inline AchievementData& operator=(const AchievementData& from) {
    CopyFrom(from);
    return *this;
  }

  static const AchievementData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AchievementData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AchievementData* other);

  // implements Message ----------------------------------------------

  AchievementData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AchievementData& from);
  void MergeFrom(const AchievementData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AchievementData_State State;
  static const State UNCOMPLETE = AchievementData_State_UNCOMPLETE;
  static const State COMPLETED = AchievementData_State_COMPLETED;
  static const State CLOSED = AchievementData_State_CLOSED;
  static inline bool State_IsValid(int value) {
    return AchievementData_State_IsValid(value);
  }
  static const State State_MIN =
    AchievementData_State_State_MIN;
  static const State State_MAX =
    AchievementData_State_State_MAX;
  static const int State_ARRAYSIZE =
    AchievementData_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .AchievementData.State state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::AchievementData_State state() const;
  inline void set_state(::AchievementData_State value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AchievementData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::int32 id_;
  int state_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static AchievementData* default_instance_;
};
// -------------------------------------------------------------------

class ActivityData : public ::google::protobuf::MessageLite {
 public:
  ActivityData();
  virtual ~ActivityData();

  ActivityData(const ActivityData& from);

  inline ActivityData& operator=(const ActivityData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ActivityData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivityData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivityData* other);

  // implements Message ----------------------------------------------

  ActivityData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivityData& from);
  void MergeFrom(const ActivityData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ActivityData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static ActivityData* default_instance_;
};
// -------------------------------------------------------------------

class SettingData : public ::google::protobuf::MessageLite {
 public:
  SettingData();
  virtual ~SettingData();

  SettingData(const SettingData& from);

  inline SettingData& operator=(const SettingData& from) {
    CopyFrom(from);
    return *this;
  }

  static const SettingData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SettingData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SettingData* other);

  // implements Message ----------------------------------------------

  SettingData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SettingData& from);
  void MergeFrom(const SettingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool hide_head = 1 [default = true];
  inline bool has_hide_head() const;
  inline void clear_hide_head();
  static const int kHideHeadFieldNumber = 1;
  inline bool hide_head() const;
  inline void set_hide_head(bool value);

  // optional bool refuse_teamup = 2;
  inline bool has_refuse_teamup() const;
  inline void clear_refuse_teamup();
  static const int kRefuseTeamupFieldNumber = 2;
  inline bool refuse_teamup() const;
  inline void set_refuse_teamup(bool value);

  // optional bool refuse_guildteamup = 3;
  inline bool has_refuse_guildteamup() const;
  inline void clear_refuse_guildteamup();
  static const int kRefuseGuildteamupFieldNumber = 3;
  inline bool refuse_guildteamup() const;
  inline void set_refuse_guildteamup(bool value);

  // optional bool close_effectsound = 4;
  inline bool has_close_effectsound() const;
  inline void clear_close_effectsound();
  static const int kCloseEffectsoundFieldNumber = 4;
  inline bool close_effectsound() const;
  inline void set_close_effectsound(bool value);

  // optional bool close_bgmusic = 5;
  inline bool has_close_bgmusic() const;
  inline void clear_close_bgmusic();
  static const int kCloseBgmusicFieldNumber = 5;
  inline bool close_bgmusic() const;
  inline void set_close_bgmusic(bool value);

  // optional bool dropitem_to_bag = 6;
  inline bool has_dropitem_to_bag() const;
  inline void clear_dropitem_to_bag();
  static const int kDropitemToBagFieldNumber = 6;
  inline bool dropitem_to_bag() const;
  inline void set_dropitem_to_bag(bool value);

  // @@protoc_insertion_point(class_scope:SettingData)
 private:
  inline void set_has_hide_head();
  inline void clear_has_hide_head();
  inline void set_has_refuse_teamup();
  inline void clear_has_refuse_teamup();
  inline void set_has_refuse_guildteamup();
  inline void clear_has_refuse_guildteamup();
  inline void set_has_close_effectsound();
  inline void clear_has_close_effectsound();
  inline void set_has_close_bgmusic();
  inline void clear_has_close_bgmusic();
  inline void set_has_dropitem_to_bag();
  inline void clear_has_dropitem_to_bag();

  bool hide_head_;
  bool refuse_teamup_;
  bool refuse_guildteamup_;
  bool close_effectsound_;
  bool close_bgmusic_;
  bool dropitem_to_bag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static SettingData* default_instance_;
};
// -------------------------------------------------------------------

class OnlineRewardsData : public ::google::protobuf::MessageLite {
 public:
  OnlineRewardsData();
  virtual ~OnlineRewardsData();

  OnlineRewardsData(const OnlineRewardsData& from);

  inline OnlineRewardsData& operator=(const OnlineRewardsData& from) {
    CopyFrom(from);
    return *this;
  }

  static const OnlineRewardsData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OnlineRewardsData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OnlineRewardsData* other);

  // implements Message ----------------------------------------------

  OnlineRewardsData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OnlineRewardsData& from);
  void MergeFrom(const OnlineRewardsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // optional bool flag = 3;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 3;
  inline bool flag() const;
  inline void set_flag(bool value);

  // @@protoc_insertion_point(class_scope:OnlineRewardsData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 time_;
  bool flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static OnlineRewardsData* default_instance_;
};
// -------------------------------------------------------------------

class CounterData : public ::google::protobuf::MessageLite {
 public:
  CounterData();
  virtual ~CounterData();

  CounterData(const CounterData& from);

  inline CounterData& operator=(const CounterData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CounterData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CounterData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CounterData* other);

  // implements Message ----------------------------------------------

  CounterData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CounterData& from);
  void MergeFrom(const CounterData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 main_type = 1;
  inline bool has_main_type() const;
  inline void clear_main_type();
  static const int kMainTypeFieldNumber = 1;
  inline ::google::protobuf::int32 main_type() const;
  inline void set_main_type(::google::protobuf::int32 value);

  // optional int32 sub_type = 2;
  inline bool has_sub_type() const;
  inline void clear_sub_type();
  static const int kSubTypeFieldNumber = 2;
  inline ::google::protobuf::int32 sub_type() const;
  inline void set_sub_type(::google::protobuf::int32 value);

  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional int32 value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CounterData)
 private:
  inline void set_has_main_type();
  inline void clear_has_main_type();
  inline void set_has_sub_type();
  inline void clear_has_sub_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::int32 main_type_;
  ::google::protobuf::int32 sub_type_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static CounterData* default_instance_;
};
// -------------------------------------------------------------------

class CharBinaryData : public ::google::protobuf::MessageLite {
 public:
  CharBinaryData();
  virtual ~CharBinaryData();

  CharBinaryData(const CharBinaryData& from);

  inline CharBinaryData& operator=(const CharBinaryData& from) {
    CopyFrom(from);
    return *this;
  }

  static const CharBinaryData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CharBinaryData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CharBinaryData* other);

  // implements Message ----------------------------------------------

  CharBinaryData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CharBinaryData& from);
  void MergeFrom(const CharBinaryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CharData chardata = 1;
  inline bool has_chardata() const;
  inline void clear_chardata();
  static const int kChardataFieldNumber = 1;
  inline const ::CharData& chardata() const;
  inline ::CharData* mutable_chardata();
  inline ::CharData* release_chardata();
  inline void set_allocated_chardata(::CharData* chardata);

  // repeated .ItemData equip_items = 2;
  inline int equip_items_size() const;
  inline void clear_equip_items();
  static const int kEquipItemsFieldNumber = 2;
  inline const ::ItemData& equip_items(int index) const;
  inline ::ItemData* mutable_equip_items(int index);
  inline ::ItemData* add_equip_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      equip_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_equip_items();

  // repeated .ItemData avatar_items = 3;
  inline int avatar_items_size() const;
  inline void clear_avatar_items();
  static const int kAvatarItemsFieldNumber = 3;
  inline const ::ItemData& avatar_items(int index) const;
  inline ::ItemData* mutable_avatar_items(int index);
  inline ::ItemData* add_avatar_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      avatar_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_avatar_items();

  // repeated .ItemData bag_items = 4;
  inline int bag_items_size() const;
  inline void clear_bag_items();
  static const int kBagItemsFieldNumber = 4;
  inline const ::ItemData& bag_items(int index) const;
  inline ::ItemData* mutable_bag_items(int index);
  inline ::ItemData* add_bag_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      bag_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_bag_items();

  // repeated .ItemData safe_items = 5;
  inline int safe_items_size() const;
  inline void clear_safe_items();
  static const int kSafeItemsFieldNumber = 5;
  inline const ::ItemData& safe_items(int index) const;
  inline ::ItemData* mutable_safe_items(int index);
  inline ::ItemData* add_safe_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      safe_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_safe_items();

  // repeated .JobSkillData job_skills = 6;
  inline int job_skills_size() const;
  inline void clear_job_skills();
  static const int kJobSkillsFieldNumber = 6;
  inline const ::JobSkillData& job_skills(int index) const;
  inline ::JobSkillData* mutable_job_skills(int index);
  inline ::JobSkillData* add_job_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::JobSkillData >&
      job_skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::JobSkillData >*
      mutable_job_skills();

  // repeated .SkillData skills = 7;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 7;
  inline const ::SkillData& skills(int index) const;
  inline ::SkillData* mutable_skills(int index);
  inline ::SkillData* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::SkillData >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkillData >*
      mutable_skills();

  // repeated .ShortcutKeyData shortcut_keys = 8;
  inline int shortcut_keys_size() const;
  inline void clear_shortcut_keys();
  static const int kShortcutKeysFieldNumber = 8;
  inline const ::ShortcutKeyData& shortcut_keys(int index) const;
  inline ::ShortcutKeyData* mutable_shortcut_keys(int index);
  inline ::ShortcutKeyData* add_shortcut_keys();
  inline const ::google::protobuf::RepeatedPtrField< ::ShortcutKeyData >&
      shortcut_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::ShortcutKeyData >*
      mutable_shortcut_keys();

  // repeated .SkillBuffData skill_buffs = 9;
  inline int skill_buffs_size() const;
  inline void clear_skill_buffs();
  static const int kSkillBuffsFieldNumber = 9;
  inline const ::SkillBuffData& skill_buffs(int index) const;
  inline ::SkillBuffData* mutable_skill_buffs(int index);
  inline ::SkillBuffData* add_skill_buffs();
  inline const ::google::protobuf::RepeatedPtrField< ::SkillBuffData >&
      skill_buffs() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkillBuffData >*
      mutable_skill_buffs();

  // repeated .MissionData missions = 10;
  inline int missions_size() const;
  inline void clear_missions();
  static const int kMissionsFieldNumber = 10;
  inline const ::MissionData& missions(int index) const;
  inline ::MissionData* mutable_missions(int index);
  inline ::MissionData* add_missions();
  inline const ::google::protobuf::RepeatedPtrField< ::MissionData >&
      missions() const;
  inline ::google::protobuf::RepeatedPtrField< ::MissionData >*
      mutable_missions();

  // repeated .AchievementData achievements = 11;
  inline int achievements_size() const;
  inline void clear_achievements();
  static const int kAchievementsFieldNumber = 11;
  inline const ::AchievementData& achievements(int index) const;
  inline ::AchievementData* mutable_achievements(int index);
  inline ::AchievementData* add_achievements();
  inline const ::google::protobuf::RepeatedPtrField< ::AchievementData >&
      achievements() const;
  inline ::google::protobuf::RepeatedPtrField< ::AchievementData >*
      mutable_achievements();

  // repeated .ActivityData activitys = 12;
  inline int activitys_size() const;
  inline void clear_activitys();
  static const int kActivitysFieldNumber = 12;
  inline const ::ActivityData& activitys(int index) const;
  inline ::ActivityData* mutable_activitys(int index);
  inline ::ActivityData* add_activitys();
  inline const ::google::protobuf::RepeatedPtrField< ::ActivityData >&
      activitys() const;
  inline ::google::protobuf::RepeatedPtrField< ::ActivityData >*
      mutable_activitys();

  // optional .SettingData setting_data = 13;
  inline bool has_setting_data() const;
  inline void clear_setting_data();
  static const int kSettingDataFieldNumber = 13;
  inline const ::SettingData& setting_data() const;
  inline ::SettingData* mutable_setting_data();
  inline ::SettingData* release_setting_data();
  inline void set_allocated_setting_data(::SettingData* setting_data);

  // optional .OnlineRewardsData onlinerewards_data = 14;
  inline bool has_onlinerewards_data() const;
  inline void clear_onlinerewards_data();
  static const int kOnlinerewardsDataFieldNumber = 14;
  inline const ::OnlineRewardsData& onlinerewards_data() const;
  inline ::OnlineRewardsData* mutable_onlinerewards_data();
  inline ::OnlineRewardsData* release_onlinerewards_data();
  inline void set_allocated_onlinerewards_data(::OnlineRewardsData* onlinerewards_data);

  // repeated .CounterData counter_data = 15;
  inline int counter_data_size() const;
  inline void clear_counter_data();
  static const int kCounterDataFieldNumber = 15;
  inline const ::CounterData& counter_data(int index) const;
  inline ::CounterData* mutable_counter_data(int index);
  inline ::CounterData* add_counter_data();
  inline const ::google::protobuf::RepeatedPtrField< ::CounterData >&
      counter_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::CounterData >*
      mutable_counter_data();

  // @@protoc_insertion_point(class_scope:CharBinaryData)
 private:
  inline void set_has_chardata();
  inline void clear_has_chardata();
  inline void set_has_setting_data();
  inline void clear_has_setting_data();
  inline void set_has_onlinerewards_data();
  inline void clear_has_onlinerewards_data();

  ::CharData* chardata_;
  ::google::protobuf::RepeatedPtrField< ::ItemData > equip_items_;
  ::google::protobuf::RepeatedPtrField< ::ItemData > avatar_items_;
  ::google::protobuf::RepeatedPtrField< ::ItemData > bag_items_;
  ::google::protobuf::RepeatedPtrField< ::ItemData > safe_items_;
  ::google::protobuf::RepeatedPtrField< ::JobSkillData > job_skills_;
  ::google::protobuf::RepeatedPtrField< ::SkillData > skills_;
  ::google::protobuf::RepeatedPtrField< ::ShortcutKeyData > shortcut_keys_;
  ::google::protobuf::RepeatedPtrField< ::SkillBuffData > skill_buffs_;
  ::google::protobuf::RepeatedPtrField< ::MissionData > missions_;
  ::google::protobuf::RepeatedPtrField< ::AchievementData > achievements_;
  ::google::protobuf::RepeatedPtrField< ::ActivityData > activitys_;
  ::SettingData* setting_data_;
  ::OnlineRewardsData* onlinerewards_data_;
  ::google::protobuf::RepeatedPtrField< ::CounterData > counter_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static CharBinaryData* default_instance_;
};
// -------------------------------------------------------------------

class MapCell : public ::google::protobuf::MessageLite {
 public:
  MapCell();
  virtual ~MapCell();

  MapCell(const MapCell& from);

  inline MapCell& operator=(const MapCell& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapCell& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapCell* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapCell* other);

  // implements Message ----------------------------------------------

  MapCell* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapCell& from);
  void MergeFrom(const MapCell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MapCellFlag flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::MapCellFlag flag() const;
  inline void set_flag(::MapCellFlag value);

  // @@protoc_insertion_point(class_scope:MapCell)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  int flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static MapCell* default_instance_;
};
// -------------------------------------------------------------------

class TileMapData : public ::google::protobuf::MessageLite {
 public:
  TileMapData();
  virtual ~TileMapData();

  TileMapData(const TileMapData& from);

  inline TileMapData& operator=(const TileMapData& from) {
    CopyFrom(from);
    return *this;
  }

  static const TileMapData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TileMapData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TileMapData* other);

  // implements Message ----------------------------------------------

  TileMapData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TileMapData& from);
  void MergeFrom(const TileMapData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 tilewidth = 3;
  inline bool has_tilewidth() const;
  inline void clear_tilewidth();
  static const int kTilewidthFieldNumber = 3;
  inline ::google::protobuf::int32 tilewidth() const;
  inline void set_tilewidth(::google::protobuf::int32 value);

  // optional int32 tileheight = 4;
  inline bool has_tileheight() const;
  inline void clear_tileheight();
  static const int kTileheightFieldNumber = 4;
  inline ::google::protobuf::int32 tileheight() const;
  inline void set_tileheight(::google::protobuf::int32 value);

  // repeated .MapCell cell_list = 5;
  inline int cell_list_size() const;
  inline void clear_cell_list();
  static const int kCellListFieldNumber = 5;
  inline const ::MapCell& cell_list(int index) const;
  inline ::MapCell* mutable_cell_list(int index);
  inline ::MapCell* add_cell_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MapCell >&
      cell_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapCell >*
      mutable_cell_list();

  // @@protoc_insertion_point(class_scope:TileMapData)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_tilewidth();
  inline void clear_has_tilewidth();
  inline void set_has_tileheight();
  inline void clear_has_tileheight();

  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 tilewidth_;
  ::google::protobuf::int32 tileheight_;
  ::google::protobuf::RepeatedPtrField< ::MapCell > cell_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static TileMapData* default_instance_;
};
// -------------------------------------------------------------------

class MapCharInfo : public ::google::protobuf::MessageLite {
 public:
  MapCharInfo();
  virtual ~MapCharInfo();

  MapCharInfo(const MapCharInfo& from);

  inline MapCharInfo& operator=(const MapCharInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapCharInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapCharInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapCharInfo* other);

  // implements Message ----------------------------------------------

  MapCharInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapCharInfo& from);
  void MergeFrom(const MapCharInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 country = 4;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 4;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional int32 curhp = 5;
  inline bool has_curhp() const;
  inline void clear_curhp();
  static const int kCurhpFieldNumber = 5;
  inline ::google::protobuf::int32 curhp() const;
  inline void set_curhp(::google::protobuf::int32 value);

  // optional int32 maxhp = 6;
  inline bool has_maxhp() const;
  inline void clear_maxhp();
  static const int kMaxhpFieldNumber = 6;
  inline ::google::protobuf::int32 maxhp() const;
  inline void set_maxhp(::google::protobuf::int32 value);

  // optional int32 curmp = 7;
  inline bool has_curmp() const;
  inline void clear_curmp();
  static const int kCurmpFieldNumber = 7;
  inline ::google::protobuf::int32 curmp() const;
  inline void set_curmp(::google::protobuf::int32 value);

  // optional int32 maxmp = 8;
  inline bool has_maxmp() const;
  inline void clear_maxmp();
  static const int kMaxmpFieldNumber = 8;
  inline ::google::protobuf::int32 maxmp() const;
  inline void set_maxmp(::google::protobuf::int32 value);

  // optional int32 x = 9;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 9;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 10;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 10;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 tx = 11;
  inline bool has_tx() const;
  inline void clear_tx();
  static const int kTxFieldNumber = 11;
  inline ::google::protobuf::int32 tx() const;
  inline void set_tx(::google::protobuf::int32 value);

  // optional int32 ty = 12;
  inline bool has_ty() const;
  inline void clear_ty();
  static const int kTyFieldNumber = 12;
  inline ::google::protobuf::int32 ty() const;
  inline void set_ty(::google::protobuf::int32 value);

  // optional int32 direction = 13;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 13;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional int32 race = 14;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 14;
  inline ::google::protobuf::int32 race() const;
  inline void set_race(::google::protobuf::int32 value);

  // optional int32 move_speed = 15;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 15;
  inline ::google::protobuf::int32 move_speed() const;
  inline void set_move_speed(::google::protobuf::int32 value);

  // optional .ObjectState state = 16;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 16;
  inline ::ObjectState state() const;
  inline void set_state(::ObjectState value);

  // repeated int32 looks = 17;
  inline int looks_size() const;
  inline void clear_looks();
  static const int kLooksFieldNumber = 17;
  inline ::google::protobuf::int32 looks(int index) const;
  inline void set_looks(int index, ::google::protobuf::int32 value);
  inline void add_looks(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      looks() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_looks();

  // repeated .SkillBuffData skill_buffs = 18;
  inline int skill_buffs_size() const;
  inline void clear_skill_buffs();
  static const int kSkillBuffsFieldNumber = 18;
  inline const ::SkillBuffData& skill_buffs(int index) const;
  inline ::SkillBuffData* mutable_skill_buffs(int index);
  inline ::SkillBuffData* add_skill_buffs();
  inline const ::google::protobuf::RepeatedPtrField< ::SkillBuffData >&
      skill_buffs() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkillBuffData >*
      mutable_skill_buffs();

  // @@protoc_insertion_point(class_scope:MapCharInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_curhp();
  inline void clear_has_curhp();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();
  inline void set_has_curmp();
  inline void clear_has_curmp();
  inline void set_has_maxmp();
  inline void clear_has_maxmp();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_tx();
  inline void clear_has_tx();
  inline void set_has_ty();
  inline void clear_has_ty();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();
  inline void set_has_state();
  inline void clear_has_state();

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 country_;
  ::google::protobuf::int32 curhp_;
  ::google::protobuf::int32 maxhp_;
  ::google::protobuf::int32 curmp_;
  ::google::protobuf::int32 maxmp_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 tx_;
  ::google::protobuf::int32 ty_;
  ::google::protobuf::int32 direction_;
  ::google::protobuf::int32 race_;
  ::google::protobuf::int32 move_speed_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > looks_;
  ::google::protobuf::RepeatedPtrField< ::SkillBuffData > skill_buffs_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static MapCharInfo* default_instance_;
};
// -------------------------------------------------------------------

class MapMonsterInfo : public ::google::protobuf::MessageLite {
 public:
  MapMonsterInfo();
  virtual ~MapMonsterInfo();

  MapMonsterInfo(const MapMonsterInfo& from);

  inline MapMonsterInfo& operator=(const MapMonsterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapMonsterInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapMonsterInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapMonsterInfo* other);

  // implements Message ----------------------------------------------

  MapMonsterInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapMonsterInfo& from);
  void MergeFrom(const MapMonsterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 curhp = 2;
  inline bool has_curhp() const;
  inline void clear_curhp();
  static const int kCurhpFieldNumber = 2;
  inline ::google::protobuf::int32 curhp() const;
  inline void set_curhp(::google::protobuf::int32 value);

  // optional int32 maxhp = 3;
  inline bool has_maxhp() const;
  inline void clear_maxhp();
  static const int kMaxhpFieldNumber = 3;
  inline ::google::protobuf::int32 maxhp() const;
  inline void set_maxhp(::google::protobuf::int32 value);

  // optional int32 x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 monid = 6;
  inline bool has_monid() const;
  inline void clear_monid();
  static const int kMonidFieldNumber = 6;
  inline ::google::protobuf::int32 monid() const;
  inline void set_monid(::google::protobuf::int32 value);

  // optional int32 move_speed = 7;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 7;
  inline ::google::protobuf::int32 move_speed() const;
  inline void set_move_speed(::google::protobuf::int32 value);

  // optional .ObjectState state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline ::ObjectState state() const;
  inline void set_state(::ObjectState value);

  // repeated .SkillBuffData skill_buffs = 9;
  inline int skill_buffs_size() const;
  inline void clear_skill_buffs();
  static const int kSkillBuffsFieldNumber = 9;
  inline const ::SkillBuffData& skill_buffs(int index) const;
  inline ::SkillBuffData* mutable_skill_buffs(int index);
  inline ::SkillBuffData* add_skill_buffs();
  inline const ::google::protobuf::RepeatedPtrField< ::SkillBuffData >&
      skill_buffs() const;
  inline ::google::protobuf::RepeatedPtrField< ::SkillBuffData >*
      mutable_skill_buffs();

  // @@protoc_insertion_point(class_scope:MapMonsterInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_curhp();
  inline void clear_has_curhp();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_monid();
  inline void clear_has_monid();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 curhp_;
  ::google::protobuf::int32 maxhp_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 monid_;
  ::google::protobuf::int32 move_speed_;
  int state_;
  ::google::protobuf::RepeatedPtrField< ::SkillBuffData > skill_buffs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static MapMonsterInfo* default_instance_;
};
// -------------------------------------------------------------------

class MapNpcInfo : public ::google::protobuf::MessageLite {
 public:
  MapNpcInfo();
  virtual ~MapNpcInfo();

  MapNpcInfo(const MapNpcInfo& from);

  inline MapNpcInfo& operator=(const MapNpcInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MapNpcInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapNpcInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapNpcInfo* other);

  // implements Message ----------------------------------------------

  MapNpcInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapNpcInfo& from);
  void MergeFrom(const MapNpcInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 npcid = 4;
  inline bool has_npcid() const;
  inline void clear_npcid();
  static const int kNpcidFieldNumber = 4;
  inline ::google::protobuf::int32 npcid() const;
  inline void set_npcid(::google::protobuf::int32 value);

  // optional int32 func = 5;
  inline bool has_func() const;
  inline void clear_func();
  static const int kFuncFieldNumber = 5;
  inline ::google::protobuf::int32 func() const;
  inline void set_func(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapNpcInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_npcid();
  inline void clear_has_npcid();
  inline void set_has_func();
  inline void clear_has_func();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 npcid_;
  ::google::protobuf::int32 func_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static MapNpcInfo* default_instance_;
};
// -------------------------------------------------------------------

class ItemLoc : public ::google::protobuf::MessageLite {
 public:
  ItemLoc();
  virtual ~ItemLoc();

  ItemLoc(const ItemLoc& from);

  inline ItemLoc& operator=(const ItemLoc& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemLoc& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemLoc* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemLoc* other);

  // implements Message ----------------------------------------------

  ItemLoc* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemLoc& from);
  void MergeFrom(const ItemLoc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pkg = 1;
  inline bool has_pkg() const;
  inline void clear_pkg();
  static const int kPkgFieldNumber = 1;
  inline ::google::protobuf::int32 pkg() const;
  inline void set_pkg(::google::protobuf::int32 value);

  // optional int32 slot = 2;
  inline bool has_slot() const;
  inline void clear_slot();
  static const int kSlotFieldNumber = 2;
  inline ::google::protobuf::int32 slot() const;
  inline void set_slot(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ItemLoc)
 private:
  inline void set_has_pkg();
  inline void clear_has_pkg();
  inline void set_has_slot();
  inline void clear_has_slot();

  ::google::protobuf::int32 pkg_;
  ::google::protobuf::int32 slot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static ItemLoc* default_instance_;
};
// -------------------------------------------------------------------

class ItemLocData : public ::google::protobuf::MessageLite {
 public:
  ItemLocData();
  virtual ~ItemLocData();

  ItemLocData(const ItemLocData& from);

  inline ItemLocData& operator=(const ItemLocData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemLocData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemLocData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemLocData* other);

  // implements Message ----------------------------------------------

  ItemLocData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemLocData& from);
  void MergeFrom(const ItemLocData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // optional .ItemData item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::ItemData& item() const;
  inline ::ItemData* mutable_item();
  inline ::ItemData* release_item();
  inline void set_allocated_item(::ItemData* item);

  // @@protoc_insertion_point(class_scope:ItemLocData)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();
  inline void set_has_item();
  inline void clear_has_item();

  ::ItemLoc* loc_;
  ::ItemData* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static ItemLocData* default_instance_;
};
// -------------------------------------------------------------------

class ItemLocNum : public ::google::protobuf::MessageLite {
 public:
  ItemLocNum();
  virtual ~ItemLocNum();

  ItemLocNum(const ItemLocNum& from);

  inline ItemLocNum& operator=(const ItemLocNum& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemLocNum& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemLocNum* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemLocNum* other);

  // implements Message ----------------------------------------------

  ItemLocNum* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemLocNum& from);
  void MergeFrom(const ItemLocNum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ItemLocNum)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();
  inline void set_has_num();
  inline void clear_has_num();

  ::ItemLoc* loc_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoGameData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoGameData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoGameData_2eproto();
  friend void protobuf_ShutdownFile_ProtoGameData_2eproto();

  void InitAsDefaultInstance();
  static ItemLocNum* default_instance_;
};
// ===================================================================


// ===================================================================

// CharBase

// optional string charname = 1;
inline bool CharBase::has_charname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharBase::set_has_charname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharBase::clear_has_charname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharBase::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& CharBase::charname() const {
  return *charname_;
}
inline void CharBase::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void CharBase::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void CharBase::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharBase::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* CharBase::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharBase::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 country = 2;
inline bool CharBase::has_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharBase::set_has_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharBase::clear_has_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharBase::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 CharBase::country() const {
  return country_;
}
inline void CharBase::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional int32 race = 3;
inline bool CharBase::has_race() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharBase::set_has_race() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharBase::clear_has_race() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharBase::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::google::protobuf::int32 CharBase::race() const {
  return race_;
}
inline void CharBase::set_race(::google::protobuf::int32 value) {
  set_has_race();
  race_ = value;
}

// optional int32 level = 4;
inline bool CharBase::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CharBase::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CharBase::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CharBase::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CharBase::level() const {
  return level_;
}
inline void CharBase::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional uint64 exp = 5;
inline bool CharBase::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CharBase::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CharBase::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CharBase::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 CharBase::exp() const {
  return exp_;
}
inline void CharBase::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint64 gold = 6;
inline bool CharBase::has_gold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CharBase::set_has_gold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CharBase::clear_has_gold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CharBase::clear_gold() {
  gold_ = GOOGLE_ULONGLONG(0);
  clear_has_gold();
}
inline ::google::protobuf::uint64 CharBase::gold() const {
  return gold_;
}
inline void CharBase::set_gold(::google::protobuf::uint64 value) {
  set_has_gold();
  gold_ = value;
}

// optional uint64 bindgold = 7;
inline bool CharBase::has_bindgold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CharBase::set_has_bindgold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CharBase::clear_has_bindgold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CharBase::clear_bindgold() {
  bindgold_ = GOOGLE_ULONGLONG(0);
  clear_has_bindgold();
}
inline ::google::protobuf::uint64 CharBase::bindgold() const {
  return bindgold_;
}
inline void CharBase::set_bindgold(::google::protobuf::uint64 value) {
  set_has_bindgold();
  bindgold_ = value;
}

// optional uint64 money = 8;
inline bool CharBase::has_money() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CharBase::set_has_money() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CharBase::clear_has_money() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CharBase::clear_money() {
  money_ = GOOGLE_ULONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::uint64 CharBase::money() const {
  return money_;
}
inline void CharBase::set_money(::google::protobuf::uint64 value) {
  set_has_money();
  money_ = value;
}

// optional uint64 safemoney = 9;
inline bool CharBase::has_safemoney() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CharBase::set_has_safemoney() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CharBase::clear_has_safemoney() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CharBase::clear_safemoney() {
  safemoney_ = GOOGLE_ULONGLONG(0);
  clear_has_safemoney();
}
inline ::google::protobuf::uint64 CharBase::safemoney() const {
  return safemoney_;
}
inline void CharBase::set_safemoney(::google::protobuf::uint64 value) {
  set_has_safemoney();
  safemoney_ = value;
}

// optional int32 mapid = 10;
inline bool CharBase::has_mapid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CharBase::set_has_mapid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CharBase::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CharBase::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 CharBase::mapid() const {
  return mapid_;
}
inline void CharBase::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional int32 x = 11;
inline bool CharBase::has_x() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CharBase::set_has_x() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CharBase::clear_has_x() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CharBase::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 CharBase::x() const {
  return x_;
}
inline void CharBase::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 12;
inline bool CharBase::has_y() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CharBase::set_has_y() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CharBase::clear_has_y() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CharBase::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 CharBase::y() const {
  return y_;
}
inline void CharBase::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 total_score = 13;
inline bool CharBase::has_total_score() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CharBase::set_has_total_score() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CharBase::clear_has_total_score() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CharBase::clear_total_score() {
  total_score_ = 0;
  clear_has_total_score();
}
inline ::google::protobuf::int32 CharBase::total_score() const {
  return total_score_;
}
inline void CharBase::set_total_score(::google::protobuf::int32 value) {
  set_has_total_score();
  total_score_ = value;
}

// optional int64 offline_time = 50;
inline bool CharBase::has_offline_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CharBase::set_has_offline_time() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CharBase::clear_has_offline_time() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CharBase::clear_offline_time() {
  offline_time_ = GOOGLE_LONGLONG(0);
  clear_has_offline_time();
}
inline ::google::protobuf::int64 CharBase::offline_time() const {
  return offline_time_;
}
inline void CharBase::set_offline_time(::google::protobuf::int64 value) {
  set_has_offline_time();
  offline_time_ = value;
}

// -------------------------------------------------------------------

// CharData

// optional bool inited = 1;
inline bool CharData::has_inited() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharData::set_has_inited() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharData::clear_has_inited() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharData::clear_inited() {
  inited_ = false;
  clear_has_inited();
}
inline bool CharData::inited() const {
  return inited_;
}
inline void CharData::set_inited(bool value) {
  set_has_inited();
  inited_ = value;
}

// optional string nickname = 2;
inline bool CharData::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharData::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharData::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharData::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& CharData::nickname() const {
  return *nickname_;
}
inline void CharData::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CharData::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void CharData::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharData::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* CharData::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharData::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 nickcolor = 3;
inline bool CharData::has_nickcolor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharData::set_has_nickcolor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharData::clear_has_nickcolor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharData::clear_nickcolor() {
  nickcolor_ = 0;
  clear_has_nickcolor();
}
inline ::google::protobuf::int32 CharData::nickcolor() const {
  return nickcolor_;
}
inline void CharData::set_nickcolor(::google::protobuf::int32 value) {
  set_has_nickcolor();
  nickcolor_ = value;
}

// optional int32 job = 4;
inline bool CharData::has_job() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CharData::set_has_job() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CharData::clear_has_job() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CharData::clear_job() {
  job_ = 0;
  clear_has_job();
}
inline ::google::protobuf::int32 CharData::job() const {
  return job_;
}
inline void CharData::set_job(::google::protobuf::int32 value) {
  set_has_job();
  job_ = value;
}

// optional int32 levelup_point = 5;
inline bool CharData::has_levelup_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CharData::set_has_levelup_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CharData::clear_has_levelup_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CharData::clear_levelup_point() {
  levelup_point_ = 0;
  clear_has_levelup_point();
}
inline ::google::protobuf::int32 CharData::levelup_point() const {
  return levelup_point_;
}
inline void CharData::set_levelup_point(::google::protobuf::int32 value) {
  set_has_levelup_point();
  levelup_point_ = value;
}

// optional int32 health = 13;
inline bool CharData::has_health() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CharData::set_has_health() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CharData::clear_has_health() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CharData::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 CharData::health() const {
  return health_;
}
inline void CharData::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
}

// optional int32 hp = 14;
inline bool CharData::has_hp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CharData::set_has_hp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CharData::clear_has_hp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CharData::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 CharData::hp() const {
  return hp_;
}
inline void CharData::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 mp = 15;
inline bool CharData::has_mp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CharData::set_has_mp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CharData::clear_has_mp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CharData::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 CharData::mp() const {
  return mp_;
}
inline void CharData::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
}

// optional int32 sp = 16;
inline bool CharData::has_sp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CharData::set_has_sp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CharData::clear_has_sp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CharData::clear_sp() {
  sp_ = 0;
  clear_has_sp();
}
inline ::google::protobuf::int32 CharData::sp() const {
  return sp_;
}
inline void CharData::set_sp(::google::protobuf::int32 value) {
  set_has_sp();
  sp_ = value;
}

// optional int32 jp = 17;
inline bool CharData::has_jp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CharData::set_has_jp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CharData::clear_has_jp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CharData::clear_jp() {
  jp_ = 0;
  clear_has_jp();
}
inline ::google::protobuf::int32 CharData::jp() const {
  return jp_;
}
inline void CharData::set_jp(::google::protobuf::int32 value) {
  set_has_jp();
  jp_ = value;
}

// optional int32 hungry = 18 [default = 100];
inline bool CharData::has_hungry() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CharData::set_has_hungry() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CharData::clear_has_hungry() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CharData::clear_hungry() {
  hungry_ = 100;
  clear_has_hungry();
}
inline ::google::protobuf::int32 CharData::hungry() const {
  return hungry_;
}
inline void CharData::set_hungry(::google::protobuf::int32 value) {
  set_has_hungry();
  hungry_ = value;
}

// optional int32 str = 19;
inline bool CharData::has_str() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CharData::set_has_str() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CharData::clear_has_str() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CharData::clear_str() {
  str_ = 0;
  clear_has_str();
}
inline ::google::protobuf::int32 CharData::str() const {
  return str_;
}
inline void CharData::set_str(::google::protobuf::int32 value) {
  set_has_str();
  str_ = value;
}

// optional int32 dex = 20;
inline bool CharData::has_dex() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CharData::set_has_dex() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CharData::clear_has_dex() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CharData::clear_dex() {
  dex_ = 0;
  clear_has_dex();
}
inline ::google::protobuf::int32 CharData::dex() const {
  return dex_;
}
inline void CharData::set_dex(::google::protobuf::int32 value) {
  set_has_dex();
  dex_ = value;
}

// optional int32 intgent = 21;
inline bool CharData::has_intgent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CharData::set_has_intgent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CharData::clear_has_intgent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CharData::clear_intgent() {
  intgent_ = 0;
  clear_has_intgent();
}
inline ::google::protobuf::int32 CharData::intgent() const {
  return intgent_;
}
inline void CharData::set_intgent(::google::protobuf::int32 value) {
  set_has_intgent();
  intgent_ = value;
}

// optional int32 con = 22;
inline bool CharData::has_con() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CharData::set_has_con() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CharData::clear_has_con() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CharData::clear_con() {
  con_ = 0;
  clear_has_con();
}
inline ::google::protobuf::int32 CharData::con() const {
  return con_;
}
inline void CharData::set_con(::google::protobuf::int32 value) {
  set_has_con();
  con_ = value;
}

// optional int32 wiz = 23;
inline bool CharData::has_wiz() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CharData::set_has_wiz() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CharData::clear_has_wiz() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CharData::clear_wiz() {
  wiz_ = 0;
  clear_has_wiz();
}
inline ::google::protobuf::int32 CharData::wiz() const {
  return wiz_;
}
inline void CharData::set_wiz(::google::protobuf::int32 value) {
  set_has_wiz();
  wiz_ = value;
}

// optional int32 pkcount = 26;
inline bool CharData::has_pkcount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CharData::set_has_pkcount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CharData::clear_has_pkcount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CharData::clear_pkcount() {
  pkcount_ = 0;
  clear_has_pkcount();
}
inline ::google::protobuf::int32 CharData::pkcount() const {
  return pkcount_;
}
inline void CharData::set_pkcount(::google::protobuf::int32 value) {
  set_has_pkcount();
  pkcount_ = value;
}

// optional int32 battle_prop = 30;
inline bool CharData::has_battle_prop() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CharData::set_has_battle_prop() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CharData::clear_has_battle_prop() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CharData::clear_battle_prop() {
  battle_prop_ = 0;
  clear_has_battle_prop();
}
inline ::google::protobuf::int32 CharData::battle_prop() const {
  return battle_prop_;
}
inline void CharData::set_battle_prop(::google::protobuf::int32 value) {
  set_has_battle_prop();
  battle_prop_ = value;
}

// optional int32 reincarnate = 32;
inline bool CharData::has_reincarnate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CharData::set_has_reincarnate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CharData::clear_has_reincarnate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CharData::clear_reincarnate() {
  reincarnate_ = 0;
  clear_has_reincarnate();
}
inline ::google::protobuf::int32 CharData::reincarnate() const {
  return reincarnate_;
}
inline void CharData::set_reincarnate(::google::protobuf::int32 value) {
  set_has_reincarnate();
  reincarnate_ = value;
}

// optional int32 renpin = 33;
inline bool CharData::has_renpin() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CharData::set_has_renpin() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CharData::clear_has_renpin() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CharData::clear_renpin() {
  renpin_ = 0;
  clear_has_renpin();
}
inline ::google::protobuf::int32 CharData::renpin() const {
  return renpin_;
}
inline void CharData::set_renpin(::google::protobuf::int32 value) {
  set_has_renpin();
  renpin_ = value;
}

// optional int32 bagsize = 34;
inline bool CharData::has_bagsize() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CharData::set_has_bagsize() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CharData::clear_has_bagsize() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CharData::clear_bagsize() {
  bagsize_ = 0;
  clear_has_bagsize();
}
inline ::google::protobuf::int32 CharData::bagsize() const {
  return bagsize_;
}
inline void CharData::set_bagsize(::google::protobuf::int32 value) {
  set_has_bagsize();
  bagsize_ = value;
}

// optional int32 safesize = 35;
inline bool CharData::has_safesize() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CharData::set_has_safesize() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CharData::clear_has_safesize() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CharData::clear_safesize() {
  safesize_ = 0;
  clear_has_safesize();
}
inline ::google::protobuf::int32 CharData::safesize() const {
  return safesize_;
}
inline void CharData::set_safesize(::google::protobuf::int32 value) {
  set_has_safesize();
  safesize_ = value;
}

// optional int32 chat_channel = 36;
inline bool CharData::has_chat_channel() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CharData::set_has_chat_channel() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CharData::clear_has_chat_channel() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CharData::clear_chat_channel() {
  chat_channel_ = 0;
  clear_has_chat_channel();
}
inline ::google::protobuf::int32 CharData::chat_channel() const {
  return chat_channel_;
}
inline void CharData::set_chat_channel(::google::protobuf::int32 value) {
  set_has_chat_channel();
  chat_channel_ = value;
}

// optional uint64 total_gold = 37;
inline bool CharData::has_total_gold() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void CharData::set_has_total_gold() {
  _has_bits_[0] |= 0x00800000u;
}
inline void CharData::clear_has_total_gold() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void CharData::clear_total_gold() {
  total_gold_ = GOOGLE_ULONGLONG(0);
  clear_has_total_gold();
}
inline ::google::protobuf::uint64 CharData::total_gold() const {
  return total_gold_;
}
inline void CharData::set_total_gold(::google::protobuf::uint64 value) {
  set_has_total_gold();
  total_gold_ = value;
}

// optional int32 vip_award_id = 38;
inline bool CharData::has_vip_award_id() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void CharData::set_has_vip_award_id() {
  _has_bits_[0] |= 0x01000000u;
}
inline void CharData::clear_has_vip_award_id() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void CharData::clear_vip_award_id() {
  vip_award_id_ = 0;
  clear_has_vip_award_id();
}
inline ::google::protobuf::int32 CharData::vip_award_id() const {
  return vip_award_id_;
}
inline void CharData::set_vip_award_id(::google::protobuf::int32 value) {
  set_has_vip_award_id();
  vip_award_id_ = value;
}

// optional int32 kill_enemy = 39;
inline bool CharData::has_kill_enemy() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void CharData::set_has_kill_enemy() {
  _has_bits_[0] |= 0x02000000u;
}
inline void CharData::clear_has_kill_enemy() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void CharData::clear_kill_enemy() {
  kill_enemy_ = 0;
  clear_has_kill_enemy();
}
inline ::google::protobuf::int32 CharData::kill_enemy() const {
  return kill_enemy_;
}
inline void CharData::set_kill_enemy(::google::protobuf::int32 value) {
  set_has_kill_enemy();
  kill_enemy_ = value;
}

// optional int32 serial_login_day = 40 [default = 1];
inline bool CharData::has_serial_login_day() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void CharData::set_has_serial_login_day() {
  _has_bits_[0] |= 0x04000000u;
}
inline void CharData::clear_has_serial_login_day() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void CharData::clear_serial_login_day() {
  serial_login_day_ = 1;
  clear_has_serial_login_day();
}
inline ::google::protobuf::int32 CharData::serial_login_day() const {
  return serial_login_day_;
}
inline void CharData::set_serial_login_day(::google::protobuf::int32 value) {
  set_has_serial_login_day();
  serial_login_day_ = value;
}

// optional int32 copies_map = 41;
inline bool CharData::has_copies_map() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void CharData::set_has_copies_map() {
  _has_bits_[0] |= 0x08000000u;
}
inline void CharData::clear_has_copies_map() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void CharData::clear_copies_map() {
  copies_map_ = 0;
  clear_has_copies_map();
}
inline ::google::protobuf::int32 CharData::copies_map() const {
  return copies_map_;
}
inline void CharData::set_copies_map(::google::protobuf::int32 value) {
  set_has_copies_map();
  copies_map_ = value;
}

// optional int32 total_guild_credits = 42;
inline bool CharData::has_total_guild_credits() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void CharData::set_has_total_guild_credits() {
  _has_bits_[0] |= 0x10000000u;
}
inline void CharData::clear_has_total_guild_credits() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void CharData::clear_total_guild_credits() {
  total_guild_credits_ = 0;
  clear_has_total_guild_credits();
}
inline ::google::protobuf::int32 CharData::total_guild_credits() const {
  return total_guild_credits_;
}
inline void CharData::set_total_guild_credits(::google::protobuf::int32 value) {
  set_has_total_guild_credits();
  total_guild_credits_ = value;
}

// optional int32 field_mapid = 43;
inline bool CharData::has_field_mapid() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void CharData::set_has_field_mapid() {
  _has_bits_[0] |= 0x20000000u;
}
inline void CharData::clear_has_field_mapid() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void CharData::clear_field_mapid() {
  field_mapid_ = 0;
  clear_has_field_mapid();
}
inline ::google::protobuf::int32 CharData::field_mapid() const {
  return field_mapid_;
}
inline void CharData::set_field_mapid(::google::protobuf::int32 value) {
  set_has_field_mapid();
  field_mapid_ = value;
}

// optional int32 field_mapx = 44;
inline bool CharData::has_field_mapx() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void CharData::set_has_field_mapx() {
  _has_bits_[0] |= 0x40000000u;
}
inline void CharData::clear_has_field_mapx() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void CharData::clear_field_mapx() {
  field_mapx_ = 0;
  clear_has_field_mapx();
}
inline ::google::protobuf::int32 CharData::field_mapx() const {
  return field_mapx_;
}
inline void CharData::set_field_mapx(::google::protobuf::int32 value) {
  set_has_field_mapx();
  field_mapx_ = value;
}

// optional int32 field_mapy = 45;
inline bool CharData::has_field_mapy() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void CharData::set_has_field_mapy() {
  _has_bits_[0] |= 0x80000000u;
}
inline void CharData::clear_has_field_mapy() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void CharData::clear_field_mapy() {
  field_mapy_ = 0;
  clear_has_field_mapy();
}
inline ::google::protobuf::int32 CharData::field_mapy() const {
  return field_mapy_;
}
inline void CharData::set_field_mapy(::google::protobuf::int32 value) {
  set_has_field_mapy();
  field_mapy_ = value;
}

// -------------------------------------------------------------------

// EquipInfo

// optional int32 duration = 1;
inline bool EquipInfo::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipInfo::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipInfo::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipInfo::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 EquipInfo::duration() const {
  return duration_;
}
inline void EquipInfo::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional int32 frozen = 2;
inline bool EquipInfo::has_frozen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipInfo::set_has_frozen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipInfo::clear_has_frozen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipInfo::clear_frozen() {
  frozen_ = 0;
  clear_has_frozen();
}
inline ::google::protobuf::int32 EquipInfo::frozen() const {
  return frozen_;
}
inline void EquipInfo::set_frozen(::google::protobuf::int32 value) {
  set_has_frozen();
  frozen_ = value;
}

// optional int32 prop = 3;
inline bool EquipInfo::has_prop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EquipInfo::set_has_prop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EquipInfo::clear_has_prop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EquipInfo::clear_prop() {
  prop_ = 0;
  clear_has_prop();
}
inline ::google::protobuf::int32 EquipInfo::prop() const {
  return prop_;
}
inline void EquipInfo::set_prop(::google::protobuf::int32 value) {
  set_has_prop();
  prop_ = value;
}

// optional int32 star = 4;
inline bool EquipInfo::has_star() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EquipInfo::set_has_star() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EquipInfo::clear_has_star() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EquipInfo::clear_star() {
  star_ = 0;
  clear_has_star();
}
inline ::google::protobuf::int32 EquipInfo::star() const {
  return star_;
}
inline void EquipInfo::set_star(::google::protobuf::int32 value) {
  set_has_star();
  star_ = value;
}

// repeated int32 grooves = 5;
inline int EquipInfo::grooves_size() const {
  return grooves_.size();
}
inline void EquipInfo::clear_grooves() {
  grooves_.Clear();
}
inline ::google::protobuf::int32 EquipInfo::grooves(int index) const {
  return grooves_.Get(index);
}
inline void EquipInfo::set_grooves(int index, ::google::protobuf::int32 value) {
  grooves_.Set(index, value);
}
inline void EquipInfo::add_grooves(::google::protobuf::int32 value) {
  grooves_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
EquipInfo::grooves() const {
  return grooves_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
EquipInfo::mutable_grooves() {
  return &grooves_;
}

// optional int32 upgrade = 6;
inline bool EquipInfo::has_upgrade() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EquipInfo::set_has_upgrade() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EquipInfo::clear_has_upgrade() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EquipInfo::clear_upgrade() {
  upgrade_ = 0;
  clear_has_upgrade();
}
inline ::google::protobuf::int32 EquipInfo::upgrade() const {
  return upgrade_;
}
inline void EquipInfo::set_upgrade(::google::protobuf::int32 value) {
  set_has_upgrade();
  upgrade_ = value;
}

// -------------------------------------------------------------------

// PetInfo

// optional int32 property = 1;
inline bool PetInfo::has_property() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PetInfo::set_has_property() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PetInfo::clear_has_property() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PetInfo::clear_property() {
  property_ = 0;
  clear_has_property();
}
inline ::google::protobuf::int32 PetInfo::property() const {
  return property_;
}
inline void PetInfo::set_property(::google::protobuf::int32 value) {
  set_has_property();
  property_ = value;
}

// optional int32 level = 2;
inline bool PetInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PetInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PetInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PetInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 PetInfo::level() const {
  return level_;
}
inline void PetInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 exp = 3;
inline bool PetInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PetInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PetInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PetInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 PetInfo::exp() const {
  return exp_;
}
inline void PetInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 hp = 4;
inline bool PetInfo::has_hp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PetInfo::set_has_hp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PetInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PetInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 PetInfo::hp() const {
  return hp_;
}
inline void PetInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// -------------------------------------------------------------------

// WingInfo

// optional int32 level = 1;
inline bool WingInfo::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WingInfo::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WingInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WingInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 WingInfo::level() const {
  return level_;
}
inline void WingInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 exp = 2;
inline bool WingInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WingInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WingInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WingInfo::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 WingInfo::exp() const {
  return exp_;
}
inline void WingInfo::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// -------------------------------------------------------------------

// EquipAddInfo

// optional int32 str = 1;
inline bool EquipAddInfo::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipAddInfo::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipAddInfo::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipAddInfo::clear_str() {
  str_ = 0;
  clear_has_str();
}
inline ::google::protobuf::int32 EquipAddInfo::str() const {
  return str_;
}
inline void EquipAddInfo::set_str(::google::protobuf::int32 value) {
  set_has_str();
  str_ = value;
}

// optional int32 con = 2;
inline bool EquipAddInfo::has_con() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipAddInfo::set_has_con() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipAddInfo::clear_has_con() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipAddInfo::clear_con() {
  con_ = 0;
  clear_has_con();
}
inline ::google::protobuf::int32 EquipAddInfo::con() const {
  return con_;
}
inline void EquipAddInfo::set_con(::google::protobuf::int32 value) {
  set_has_con();
  con_ = value;
}

// optional int32 dex = 3;
inline bool EquipAddInfo::has_dex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EquipAddInfo::set_has_dex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EquipAddInfo::clear_has_dex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EquipAddInfo::clear_dex() {
  dex_ = 0;
  clear_has_dex();
}
inline ::google::protobuf::int32 EquipAddInfo::dex() const {
  return dex_;
}
inline void EquipAddInfo::set_dex(::google::protobuf::int32 value) {
  set_has_dex();
  dex_ = value;
}

// optional int32 wiz = 4;
inline bool EquipAddInfo::has_wiz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EquipAddInfo::set_has_wiz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EquipAddInfo::clear_has_wiz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EquipAddInfo::clear_wiz() {
  wiz_ = 0;
  clear_has_wiz();
}
inline ::google::protobuf::int32 EquipAddInfo::wiz() const {
  return wiz_;
}
inline void EquipAddInfo::set_wiz(::google::protobuf::int32 value) {
  set_has_wiz();
  wiz_ = value;
}

// optional int32 intgent = 5;
inline bool EquipAddInfo::has_intgent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EquipAddInfo::set_has_intgent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EquipAddInfo::clear_has_intgent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EquipAddInfo::clear_intgent() {
  intgent_ = 0;
  clear_has_intgent();
}
inline ::google::protobuf::int32 EquipAddInfo::intgent() const {
  return intgent_;
}
inline void EquipAddInfo::set_intgent(::google::protobuf::int32 value) {
  set_has_intgent();
  intgent_ = value;
}

// optional int32 attack = 6;
inline bool EquipAddInfo::has_attack() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EquipAddInfo::set_has_attack() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EquipAddInfo::clear_has_attack() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EquipAddInfo::clear_attack() {
  attack_ = 0;
  clear_has_attack();
}
inline ::google::protobuf::int32 EquipAddInfo::attack() const {
  return attack_;
}
inline void EquipAddInfo::set_attack(::google::protobuf::int32 value) {
  set_has_attack();
  attack_ = value;
}

// optional int32 attack_per = 7;
inline bool EquipAddInfo::has_attack_per() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EquipAddInfo::set_has_attack_per() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EquipAddInfo::clear_has_attack_per() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EquipAddInfo::clear_attack_per() {
  attack_per_ = 0;
  clear_has_attack_per();
}
inline ::google::protobuf::int32 EquipAddInfo::attack_per() const {
  return attack_per_;
}
inline void EquipAddInfo::set_attack_per(::google::protobuf::int32 value) {
  set_has_attack_per();
  attack_per_ = value;
}

// optional int32 critical = 8;
inline bool EquipAddInfo::has_critical() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EquipAddInfo::set_has_critical() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EquipAddInfo::clear_has_critical() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EquipAddInfo::clear_critical() {
  critical_ = 0;
  clear_has_critical();
}
inline ::google::protobuf::int32 EquipAddInfo::critical() const {
  return critical_;
}
inline void EquipAddInfo::set_critical(::google::protobuf::int32 value) {
  set_has_critical();
  critical_ = value;
}

// optional int32 none2 = 9;
inline bool EquipAddInfo::has_none2() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EquipAddInfo::set_has_none2() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EquipAddInfo::clear_has_none2() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EquipAddInfo::clear_none2() {
  none2_ = 0;
  clear_has_none2();
}
inline ::google::protobuf::int32 EquipAddInfo::none2() const {
  return none2_;
}
inline void EquipAddInfo::set_none2(::google::protobuf::int32 value) {
  set_has_none2();
  none2_ = value;
}

// optional int32 phydef = 10;
inline bool EquipAddInfo::has_phydef() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EquipAddInfo::set_has_phydef() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EquipAddInfo::clear_has_phydef() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EquipAddInfo::clear_phydef() {
  phydef_ = 0;
  clear_has_phydef();
}
inline ::google::protobuf::int32 EquipAddInfo::phydef() const {
  return phydef_;
}
inline void EquipAddInfo::set_phydef(::google::protobuf::int32 value) {
  set_has_phydef();
  phydef_ = value;
}

// optional int32 phydef_per = 11;
inline bool EquipAddInfo::has_phydef_per() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EquipAddInfo::set_has_phydef_per() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EquipAddInfo::clear_has_phydef_per() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EquipAddInfo::clear_phydef_per() {
  phydef_per_ = 0;
  clear_has_phydef_per();
}
inline ::google::protobuf::int32 EquipAddInfo::phydef_per() const {
  return phydef_per_;
}
inline void EquipAddInfo::set_phydef_per(::google::protobuf::int32 value) {
  set_has_phydef_per();
  phydef_per_ = value;
}

// optional int32 magdef = 12;
inline bool EquipAddInfo::has_magdef() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EquipAddInfo::set_has_magdef() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EquipAddInfo::clear_has_magdef() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EquipAddInfo::clear_magdef() {
  magdef_ = 0;
  clear_has_magdef();
}
inline ::google::protobuf::int32 EquipAddInfo::magdef() const {
  return magdef_;
}
inline void EquipAddInfo::set_magdef(::google::protobuf::int32 value) {
  set_has_magdef();
  magdef_ = value;
}

// optional int32 magdef_per = 13;
inline bool EquipAddInfo::has_magdef_per() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EquipAddInfo::set_has_magdef_per() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EquipAddInfo::clear_has_magdef_per() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EquipAddInfo::clear_magdef_per() {
  magdef_per_ = 0;
  clear_has_magdef_per();
}
inline ::google::protobuf::int32 EquipAddInfo::magdef_per() const {
  return magdef_per_;
}
inline void EquipAddInfo::set_magdef_per(::google::protobuf::int32 value) {
  set_has_magdef_per();
  magdef_per_ = value;
}

// optional int32 hp = 14;
inline bool EquipAddInfo::has_hp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EquipAddInfo::set_has_hp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EquipAddInfo::clear_has_hp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EquipAddInfo::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 EquipAddInfo::hp() const {
  return hp_;
}
inline void EquipAddInfo::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 hp_per = 15;
inline bool EquipAddInfo::has_hp_per() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EquipAddInfo::set_has_hp_per() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EquipAddInfo::clear_has_hp_per() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EquipAddInfo::clear_hp_per() {
  hp_per_ = 0;
  clear_has_hp_per();
}
inline ::google::protobuf::int32 EquipAddInfo::hp_per() const {
  return hp_per_;
}
inline void EquipAddInfo::set_hp_per(::google::protobuf::int32 value) {
  set_has_hp_per();
  hp_per_ = value;
}

// optional int32 mp = 16;
inline bool EquipAddInfo::has_mp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EquipAddInfo::set_has_mp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EquipAddInfo::clear_has_mp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EquipAddInfo::clear_mp() {
  mp_ = 0;
  clear_has_mp();
}
inline ::google::protobuf::int32 EquipAddInfo::mp() const {
  return mp_;
}
inline void EquipAddInfo::set_mp(::google::protobuf::int32 value) {
  set_has_mp();
  mp_ = value;
}

// optional int32 mp_per = 17;
inline bool EquipAddInfo::has_mp_per() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EquipAddInfo::set_has_mp_per() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EquipAddInfo::clear_has_mp_per() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EquipAddInfo::clear_mp_per() {
  mp_per_ = 0;
  clear_has_mp_per();
}
inline ::google::protobuf::int32 EquipAddInfo::mp_per() const {
  return mp_per_;
}
inline void EquipAddInfo::set_mp_per(::google::protobuf::int32 value) {
  set_has_mp_per();
  mp_per_ = value;
}

// optional int32 sp = 18;
inline bool EquipAddInfo::has_sp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EquipAddInfo::set_has_sp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EquipAddInfo::clear_has_sp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EquipAddInfo::clear_sp() {
  sp_ = 0;
  clear_has_sp();
}
inline ::google::protobuf::int32 EquipAddInfo::sp() const {
  return sp_;
}
inline void EquipAddInfo::set_sp(::google::protobuf::int32 value) {
  set_has_sp();
  sp_ = value;
}

// optional int32 sp_per = 19;
inline bool EquipAddInfo::has_sp_per() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EquipAddInfo::set_has_sp_per() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EquipAddInfo::clear_has_sp_per() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EquipAddInfo::clear_sp_per() {
  sp_per_ = 0;
  clear_has_sp_per();
}
inline ::google::protobuf::int32 EquipAddInfo::sp_per() const {
  return sp_per_;
}
inline void EquipAddInfo::set_sp_per(::google::protobuf::int32 value) {
  set_has_sp_per();
  sp_per_ = value;
}

// optional int32 atk_acc = 20;
inline bool EquipAddInfo::has_atk_acc() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EquipAddInfo::set_has_atk_acc() {
  _has_bits_[0] |= 0x00080000u;
}
inline void EquipAddInfo::clear_has_atk_acc() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void EquipAddInfo::clear_atk_acc() {
  atk_acc_ = 0;
  clear_has_atk_acc();
}
inline ::google::protobuf::int32 EquipAddInfo::atk_acc() const {
  return atk_acc_;
}
inline void EquipAddInfo::set_atk_acc(::google::protobuf::int32 value) {
  set_has_atk_acc();
  atk_acc_ = value;
}

// optional int32 def_acc = 21;
inline bool EquipAddInfo::has_def_acc() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EquipAddInfo::set_has_def_acc() {
  _has_bits_[0] |= 0x00100000u;
}
inline void EquipAddInfo::clear_has_def_acc() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void EquipAddInfo::clear_def_acc() {
  def_acc_ = 0;
  clear_has_def_acc();
}
inline ::google::protobuf::int32 EquipAddInfo::def_acc() const {
  return def_acc_;
}
inline void EquipAddInfo::set_def_acc(::google::protobuf::int32 value) {
  set_has_def_acc();
  def_acc_ = value;
}

// -------------------------------------------------------------------

// ItemData

// optional uint32 id = 1;
inline bool ItemData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemData::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ItemData::id() const {
  return id_;
}
inline void ItemData::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 item_id = 2;
inline bool ItemData::has_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemData::set_has_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemData::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemData::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 ItemData::item_id() const {
  return item_id_;
}
inline void ItemData::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional int32 slot = 3;
inline bool ItemData::has_slot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemData::set_has_slot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemData::clear_has_slot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemData::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 ItemData::slot() const {
  return slot_;
}
inline void ItemData::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// optional int32 bind = 4;
inline bool ItemData::has_bind() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ItemData::set_has_bind() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ItemData::clear_has_bind() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ItemData::clear_bind() {
  bind_ = 0;
  clear_has_bind();
}
inline ::google::protobuf::int32 ItemData::bind() const {
  return bind_;
}
inline void ItemData::set_bind(::google::protobuf::int32 value) {
  set_has_bind();
  bind_ = value;
}

// optional int32 overlay = 5 [default = 1];
inline bool ItemData::has_overlay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ItemData::set_has_overlay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ItemData::clear_has_overlay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ItemData::clear_overlay() {
  overlay_ = 1;
  clear_has_overlay();
}
inline ::google::protobuf::int32 ItemData::overlay() const {
  return overlay_;
}
inline void ItemData::set_overlay(::google::protobuf::int32 value) {
  set_has_overlay();
  overlay_ = value;
}

// optional int32 quality = 6;
inline bool ItemData::has_quality() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ItemData::set_has_quality() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ItemData::clear_has_quality() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ItemData::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 ItemData::quality() const {
  return quality_;
}
inline void ItemData::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// optional int64 expired_time = 7;
inline bool ItemData::has_expired_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ItemData::set_has_expired_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ItemData::clear_has_expired_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ItemData::clear_expired_time() {
  expired_time_ = GOOGLE_LONGLONG(0);
  clear_has_expired_time();
}
inline ::google::protobuf::int64 ItemData::expired_time() const {
  return expired_time_;
}
inline void ItemData::set_expired_time(::google::protobuf::int64 value) {
  set_has_expired_time();
  expired_time_ = value;
}

// optional .EquipInfo equip_info = 100;
inline bool ItemData::has_equip_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ItemData::set_has_equip_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ItemData::clear_has_equip_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ItemData::clear_equip_info() {
  if (equip_info_ != NULL) equip_info_->::EquipInfo::Clear();
  clear_has_equip_info();
}
inline const ::EquipInfo& ItemData::equip_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equip_info_ != NULL ? *equip_info_ : *default_instance().equip_info_;
#else
  return equip_info_ != NULL ? *equip_info_ : *default_instance_->equip_info_;
#endif
}
inline ::EquipInfo* ItemData::mutable_equip_info() {
  set_has_equip_info();
  if (equip_info_ == NULL) equip_info_ = new ::EquipInfo;
  return equip_info_;
}
inline ::EquipInfo* ItemData::release_equip_info() {
  clear_has_equip_info();
  ::EquipInfo* temp = equip_info_;
  equip_info_ = NULL;
  return temp;
}
inline void ItemData::set_allocated_equip_info(::EquipInfo* equip_info) {
  delete equip_info_;
  equip_info_ = equip_info;
  if (equip_info) {
    set_has_equip_info();
  } else {
    clear_has_equip_info();
  }
}

// optional .PetInfo pet_info = 200;
inline bool ItemData::has_pet_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ItemData::set_has_pet_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ItemData::clear_has_pet_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ItemData::clear_pet_info() {
  if (pet_info_ != NULL) pet_info_->::PetInfo::Clear();
  clear_has_pet_info();
}
inline const ::PetInfo& ItemData::pet_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pet_info_ != NULL ? *pet_info_ : *default_instance().pet_info_;
#else
  return pet_info_ != NULL ? *pet_info_ : *default_instance_->pet_info_;
#endif
}
inline ::PetInfo* ItemData::mutable_pet_info() {
  set_has_pet_info();
  if (pet_info_ == NULL) pet_info_ = new ::PetInfo;
  return pet_info_;
}
inline ::PetInfo* ItemData::release_pet_info() {
  clear_has_pet_info();
  ::PetInfo* temp = pet_info_;
  pet_info_ = NULL;
  return temp;
}
inline void ItemData::set_allocated_pet_info(::PetInfo* pet_info) {
  delete pet_info_;
  pet_info_ = pet_info;
  if (pet_info) {
    set_has_pet_info();
  } else {
    clear_has_pet_info();
  }
}

// optional .WingInfo wing_info = 300;
inline bool ItemData::has_wing_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ItemData::set_has_wing_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ItemData::clear_has_wing_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ItemData::clear_wing_info() {
  if (wing_info_ != NULL) wing_info_->::WingInfo::Clear();
  clear_has_wing_info();
}
inline const ::WingInfo& ItemData::wing_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return wing_info_ != NULL ? *wing_info_ : *default_instance().wing_info_;
#else
  return wing_info_ != NULL ? *wing_info_ : *default_instance_->wing_info_;
#endif
}
inline ::WingInfo* ItemData::mutable_wing_info() {
  set_has_wing_info();
  if (wing_info_ == NULL) wing_info_ = new ::WingInfo;
  return wing_info_;
}
inline ::WingInfo* ItemData::release_wing_info() {
  clear_has_wing_info();
  ::WingInfo* temp = wing_info_;
  wing_info_ = NULL;
  return temp;
}
inline void ItemData::set_allocated_wing_info(::WingInfo* wing_info) {
  delete wing_info_;
  wing_info_ = wing_info;
  if (wing_info) {
    set_has_wing_info();
  } else {
    clear_has_wing_info();
  }
}

// optional .EquipAddInfo equip_add_info = 400;
inline bool ItemData::has_equip_add_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ItemData::set_has_equip_add_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ItemData::clear_has_equip_add_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ItemData::clear_equip_add_info() {
  if (equip_add_info_ != NULL) equip_add_info_->::EquipAddInfo::Clear();
  clear_has_equip_add_info();
}
inline const ::EquipAddInfo& ItemData::equip_add_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equip_add_info_ != NULL ? *equip_add_info_ : *default_instance().equip_add_info_;
#else
  return equip_add_info_ != NULL ? *equip_add_info_ : *default_instance_->equip_add_info_;
#endif
}
inline ::EquipAddInfo* ItemData::mutable_equip_add_info() {
  set_has_equip_add_info();
  if (equip_add_info_ == NULL) equip_add_info_ = new ::EquipAddInfo;
  return equip_add_info_;
}
inline ::EquipAddInfo* ItemData::release_equip_add_info() {
  clear_has_equip_add_info();
  ::EquipAddInfo* temp = equip_add_info_;
  equip_add_info_ = NULL;
  return temp;
}
inline void ItemData::set_allocated_equip_add_info(::EquipAddInfo* equip_add_info) {
  delete equip_add_info_;
  equip_add_info_ = equip_add_info;
  if (equip_add_info) {
    set_has_equip_add_info();
  } else {
    clear_has_equip_add_info();
  }
}

// -------------------------------------------------------------------

// ShortcutKeyData

// optional .ShortcutKeyData.KeyType type = 1;
inline bool ShortcutKeyData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShortcutKeyData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShortcutKeyData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShortcutKeyData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ShortcutKeyData_KeyType ShortcutKeyData::type() const {
  return static_cast< ::ShortcutKeyData_KeyType >(type_);
}
inline void ShortcutKeyData::set_type(::ShortcutKeyData_KeyType value) {
  assert(::ShortcutKeyData_KeyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 key_slot = 2;
inline bool ShortcutKeyData::has_key_slot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShortcutKeyData::set_has_key_slot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShortcutKeyData::clear_has_key_slot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShortcutKeyData::clear_key_slot() {
  key_slot_ = 0;
  clear_has_key_slot();
}
inline ::google::protobuf::int32 ShortcutKeyData::key_slot() const {
  return key_slot_;
}
inline void ShortcutKeyData::set_key_slot(::google::protobuf::int32 value) {
  set_has_key_slot();
  key_slot_ = value;
}

// optional int32 item_id = 3;
inline bool ShortcutKeyData::has_item_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShortcutKeyData::set_has_item_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShortcutKeyData::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShortcutKeyData::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 ShortcutKeyData::item_id() const {
  return item_id_;
}
inline void ShortcutKeyData::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional int32 item_slot = 4;
inline bool ShortcutKeyData::has_item_slot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShortcutKeyData::set_has_item_slot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShortcutKeyData::clear_has_item_slot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShortcutKeyData::clear_item_slot() {
  item_slot_ = 0;
  clear_has_item_slot();
}
inline ::google::protobuf::int32 ShortcutKeyData::item_slot() const {
  return item_slot_;
}
inline void ShortcutKeyData::set_item_slot(::google::protobuf::int32 value) {
  set_has_item_slot();
  item_slot_ = value;
}

// -------------------------------------------------------------------

// JobSkillData

// optional int32 skill_id = 1;
inline bool JobSkillData::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobSkillData::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobSkillData::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobSkillData::clear_skill_id() {
  skill_id_ = 0;
  clear_has_skill_id();
}
inline ::google::protobuf::int32 JobSkillData::skill_id() const {
  return skill_id_;
}
inline void JobSkillData::set_skill_id(::google::protobuf::int32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional int32 level = 2;
inline bool JobSkillData::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobSkillData::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobSkillData::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobSkillData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 JobSkillData::level() const {
  return level_;
}
inline void JobSkillData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 exp = 3;
inline bool JobSkillData::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobSkillData::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobSkillData::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobSkillData::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 JobSkillData::exp() const {
  return exp_;
}
inline void JobSkillData::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int64 cd_time = 4;
inline bool JobSkillData::has_cd_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobSkillData::set_has_cd_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobSkillData::clear_has_cd_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobSkillData::clear_cd_time() {
  cd_time_ = GOOGLE_LONGLONG(0);
  clear_has_cd_time();
}
inline ::google::protobuf::int64 JobSkillData::cd_time() const {
  return cd_time_;
}
inline void JobSkillData::set_cd_time(::google::protobuf::int64 value) {
  set_has_cd_time();
  cd_time_ = value;
}

// -------------------------------------------------------------------

// SkillData

// optional int32 skill_id = 1;
inline bool SkillData::has_skill_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillData::set_has_skill_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillData::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillData::clear_skill_id() {
  skill_id_ = 0;
  clear_has_skill_id();
}
inline ::google::protobuf::int32 SkillData::skill_id() const {
  return skill_id_;
}
inline void SkillData::set_skill_id(::google::protobuf::int32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional int32 level = 2;
inline bool SkillData::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillData::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillData::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 SkillData::level() const {
  return level_;
}
inline void SkillData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 exp = 3;
inline bool SkillData::has_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillData::set_has_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillData::clear_has_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillData::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 SkillData::exp() const {
  return exp_;
}
inline void SkillData::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int64 cd_time = 4;
inline bool SkillData::has_cd_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillData::set_has_cd_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillData::clear_has_cd_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillData::clear_cd_time() {
  cd_time_ = GOOGLE_LONGLONG(0);
  clear_has_cd_time();
}
inline ::google::protobuf::int64 SkillData::cd_time() const {
  return cd_time_;
}
inline void SkillData::set_cd_time(::google::protobuf::int64 value) {
  set_has_cd_time();
  cd_time_ = value;
}

// -------------------------------------------------------------------

// SkillBuffData

// optional int32 attacker_id = 1;
inline bool SkillBuffData::has_attacker_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkillBuffData::set_has_attacker_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkillBuffData::clear_has_attacker_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkillBuffData::clear_attacker_id() {
  attacker_id_ = 0;
  clear_has_attacker_id();
}
inline ::google::protobuf::int32 SkillBuffData::attacker_id() const {
  return attacker_id_;
}
inline void SkillBuffData::set_attacker_id(::google::protobuf::int32 value) {
  set_has_attacker_id();
  attacker_id_ = value;
}

// optional int32 buff_id = 2;
inline bool SkillBuffData::has_buff_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkillBuffData::set_has_buff_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkillBuffData::clear_has_buff_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkillBuffData::clear_buff_id() {
  buff_id_ = 0;
  clear_has_buff_id();
}
inline ::google::protobuf::int32 SkillBuffData::buff_id() const {
  return buff_id_;
}
inline void SkillBuffData::set_buff_id(::google::protobuf::int32 value) {
  set_has_buff_id();
  buff_id_ = value;
}

// optional int32 skill_id = 3;
inline bool SkillBuffData::has_skill_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkillBuffData::set_has_skill_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkillBuffData::clear_has_skill_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkillBuffData::clear_skill_id() {
  skill_id_ = 0;
  clear_has_skill_id();
}
inline ::google::protobuf::int32 SkillBuffData::skill_id() const {
  return skill_id_;
}
inline void SkillBuffData::set_skill_id(::google::protobuf::int32 value) {
  set_has_skill_id();
  skill_id_ = value;
}

// optional int32 skill_level = 4;
inline bool SkillBuffData::has_skill_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkillBuffData::set_has_skill_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkillBuffData::clear_has_skill_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkillBuffData::clear_skill_level() {
  skill_level_ = 0;
  clear_has_skill_level();
}
inline ::google::protobuf::int32 SkillBuffData::skill_level() const {
  return skill_level_;
}
inline void SkillBuffData::set_skill_level(::google::protobuf::int32 value) {
  set_has_skill_level();
  skill_level_ = value;
}

// optional int32 remain_time = 5;
inline bool SkillBuffData::has_remain_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkillBuffData::set_has_remain_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkillBuffData::clear_has_remain_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkillBuffData::clear_remain_time() {
  remain_time_ = 0;
  clear_has_remain_time();
}
inline ::google::protobuf::int32 SkillBuffData::remain_time() const {
  return remain_time_;
}
inline void SkillBuffData::set_remain_time(::google::protobuf::int32 value) {
  set_has_remain_time();
  remain_time_ = value;
}

// optional int32 param1 = 6;
inline bool SkillBuffData::has_param1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SkillBuffData::set_has_param1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SkillBuffData::clear_has_param1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SkillBuffData::clear_param1() {
  param1_ = 0;
  clear_has_param1();
}
inline ::google::protobuf::int32 SkillBuffData::param1() const {
  return param1_;
}
inline void SkillBuffData::set_param1(::google::protobuf::int32 value) {
  set_has_param1();
  param1_ = value;
}

// optional int32 param2 = 7;
inline bool SkillBuffData::has_param2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SkillBuffData::set_has_param2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SkillBuffData::clear_has_param2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SkillBuffData::clear_param2() {
  param2_ = 0;
  clear_has_param2();
}
inline ::google::protobuf::int32 SkillBuffData::param2() const {
  return param2_;
}
inline void SkillBuffData::set_param2(::google::protobuf::int32 value) {
  set_has_param2();
  param2_ = value;
}

// optional int32 param3 = 8;
inline bool SkillBuffData::has_param3() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SkillBuffData::set_has_param3() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SkillBuffData::clear_has_param3() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SkillBuffData::clear_param3() {
  param3_ = 0;
  clear_has_param3();
}
inline ::google::protobuf::int32 SkillBuffData::param3() const {
  return param3_;
}
inline void SkillBuffData::set_param3(::google::protobuf::int32 value) {
  set_has_param3();
  param3_ = value;
}

// optional int32 param4 = 9;
inline bool SkillBuffData::has_param4() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SkillBuffData::set_has_param4() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SkillBuffData::clear_has_param4() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SkillBuffData::clear_param4() {
  param4_ = 0;
  clear_has_param4();
}
inline ::google::protobuf::int32 SkillBuffData::param4() const {
  return param4_;
}
inline void SkillBuffData::set_param4(::google::protobuf::int32 value) {
  set_has_param4();
  param4_ = value;
}

// -------------------------------------------------------------------

// MissionData

// optional int32 id = 1;
inline bool MissionData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MissionData::id() const {
  return id_;
}
inline void MissionData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .MissionData.State state = 2;
inline bool MissionData::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MissionData::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MissionData::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MissionData::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::MissionData_State MissionData::state() const {
  return static_cast< ::MissionData_State >(state_);
}
inline void MissionData::set_state(::MissionData_State value) {
  assert(::MissionData_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional int32 mon_num = 3;
inline bool MissionData::has_mon_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MissionData::set_has_mon_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MissionData::clear_has_mon_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MissionData::clear_mon_num() {
  mon_num_ = 0;
  clear_has_mon_num();
}
inline ::google::protobuf::int32 MissionData::mon_num() const {
  return mon_num_;
}
inline void MissionData::set_mon_num(::google::protobuf::int32 value) {
  set_has_mon_num();
  mon_num_ = value;
}

// optional int32 item_num = 4;
inline bool MissionData::has_item_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MissionData::set_has_item_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MissionData::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MissionData::clear_item_num() {
  item_num_ = 0;
  clear_has_item_num();
}
inline ::google::protobuf::int32 MissionData::item_num() const {
  return item_num_;
}
inline void MissionData::set_item_num(::google::protobuf::int32 value) {
  set_has_item_num();
  item_num_ = value;
}

// -------------------------------------------------------------------

// AchievementData

// optional int32 id = 1;
inline bool AchievementData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AchievementData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AchievementData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AchievementData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 AchievementData::id() const {
  return id_;
}
inline void AchievementData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .AchievementData.State state = 2;
inline bool AchievementData::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AchievementData::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AchievementData::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AchievementData::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::AchievementData_State AchievementData::state() const {
  return static_cast< ::AchievementData_State >(state_);
}
inline void AchievementData::set_state(::AchievementData_State value) {
  assert(::AchievementData_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional int32 num = 3;
inline bool AchievementData::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AchievementData::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AchievementData::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AchievementData::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 AchievementData::num() const {
  return num_;
}
inline void AchievementData::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// ActivityData

// optional int32 id = 1;
inline bool ActivityData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivityData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivityData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivityData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActivityData::id() const {
  return id_;
}
inline void ActivityData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 num = 3;
inline bool ActivityData::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActivityData::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActivityData::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActivityData::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ActivityData::num() const {
  return num_;
}
inline void ActivityData::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// SettingData

// optional bool hide_head = 1 [default = true];
inline bool SettingData::has_hide_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SettingData::set_has_hide_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SettingData::clear_has_hide_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SettingData::clear_hide_head() {
  hide_head_ = true;
  clear_has_hide_head();
}
inline bool SettingData::hide_head() const {
  return hide_head_;
}
inline void SettingData::set_hide_head(bool value) {
  set_has_hide_head();
  hide_head_ = value;
}

// optional bool refuse_teamup = 2;
inline bool SettingData::has_refuse_teamup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SettingData::set_has_refuse_teamup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SettingData::clear_has_refuse_teamup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SettingData::clear_refuse_teamup() {
  refuse_teamup_ = false;
  clear_has_refuse_teamup();
}
inline bool SettingData::refuse_teamup() const {
  return refuse_teamup_;
}
inline void SettingData::set_refuse_teamup(bool value) {
  set_has_refuse_teamup();
  refuse_teamup_ = value;
}

// optional bool refuse_guildteamup = 3;
inline bool SettingData::has_refuse_guildteamup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SettingData::set_has_refuse_guildteamup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SettingData::clear_has_refuse_guildteamup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SettingData::clear_refuse_guildteamup() {
  refuse_guildteamup_ = false;
  clear_has_refuse_guildteamup();
}
inline bool SettingData::refuse_guildteamup() const {
  return refuse_guildteamup_;
}
inline void SettingData::set_refuse_guildteamup(bool value) {
  set_has_refuse_guildteamup();
  refuse_guildteamup_ = value;
}

// optional bool close_effectsound = 4;
inline bool SettingData::has_close_effectsound() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SettingData::set_has_close_effectsound() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SettingData::clear_has_close_effectsound() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SettingData::clear_close_effectsound() {
  close_effectsound_ = false;
  clear_has_close_effectsound();
}
inline bool SettingData::close_effectsound() const {
  return close_effectsound_;
}
inline void SettingData::set_close_effectsound(bool value) {
  set_has_close_effectsound();
  close_effectsound_ = value;
}

// optional bool close_bgmusic = 5;
inline bool SettingData::has_close_bgmusic() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SettingData::set_has_close_bgmusic() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SettingData::clear_has_close_bgmusic() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SettingData::clear_close_bgmusic() {
  close_bgmusic_ = false;
  clear_has_close_bgmusic();
}
inline bool SettingData::close_bgmusic() const {
  return close_bgmusic_;
}
inline void SettingData::set_close_bgmusic(bool value) {
  set_has_close_bgmusic();
  close_bgmusic_ = value;
}

// optional bool dropitem_to_bag = 6;
inline bool SettingData::has_dropitem_to_bag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SettingData::set_has_dropitem_to_bag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SettingData::clear_has_dropitem_to_bag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SettingData::clear_dropitem_to_bag() {
  dropitem_to_bag_ = false;
  clear_has_dropitem_to_bag();
}
inline bool SettingData::dropitem_to_bag() const {
  return dropitem_to_bag_;
}
inline void SettingData::set_dropitem_to_bag(bool value) {
  set_has_dropitem_to_bag();
  dropitem_to_bag_ = value;
}

// -------------------------------------------------------------------

// OnlineRewardsData

// optional int32 id = 1;
inline bool OnlineRewardsData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlineRewardsData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlineRewardsData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlineRewardsData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 OnlineRewardsData::id() const {
  return id_;
}
inline void OnlineRewardsData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 time = 2;
inline bool OnlineRewardsData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineRewardsData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineRewardsData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineRewardsData::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 OnlineRewardsData::time() const {
  return time_;
}
inline void OnlineRewardsData::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// optional bool flag = 3;
inline bool OnlineRewardsData::has_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnlineRewardsData::set_has_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnlineRewardsData::clear_has_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnlineRewardsData::clear_flag() {
  flag_ = false;
  clear_has_flag();
}
inline bool OnlineRewardsData::flag() const {
  return flag_;
}
inline void OnlineRewardsData::set_flag(bool value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// CounterData

// optional int32 main_type = 1;
inline bool CounterData::has_main_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CounterData::set_has_main_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CounterData::clear_has_main_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CounterData::clear_main_type() {
  main_type_ = 0;
  clear_has_main_type();
}
inline ::google::protobuf::int32 CounterData::main_type() const {
  return main_type_;
}
inline void CounterData::set_main_type(::google::protobuf::int32 value) {
  set_has_main_type();
  main_type_ = value;
}

// optional int32 sub_type = 2;
inline bool CounterData::has_sub_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CounterData::set_has_sub_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CounterData::clear_has_sub_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CounterData::clear_sub_type() {
  sub_type_ = 0;
  clear_has_sub_type();
}
inline ::google::protobuf::int32 CounterData::sub_type() const {
  return sub_type_;
}
inline void CounterData::set_sub_type(::google::protobuf::int32 value) {
  set_has_sub_type();
  sub_type_ = value;
}

// optional int64 timestamp = 3;
inline bool CounterData::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CounterData::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CounterData::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CounterData::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 CounterData::timestamp() const {
  return timestamp_;
}
inline void CounterData::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional int32 value = 4;
inline bool CounterData::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CounterData::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CounterData::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CounterData::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 CounterData::value() const {
  return value_;
}
inline void CounterData::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// CharBinaryData

// optional .CharData chardata = 1;
inline bool CharBinaryData::has_chardata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharBinaryData::set_has_chardata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharBinaryData::clear_has_chardata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharBinaryData::clear_chardata() {
  if (chardata_ != NULL) chardata_->::CharData::Clear();
  clear_has_chardata();
}
inline const ::CharData& CharBinaryData::chardata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chardata_ != NULL ? *chardata_ : *default_instance().chardata_;
#else
  return chardata_ != NULL ? *chardata_ : *default_instance_->chardata_;
#endif
}
inline ::CharData* CharBinaryData::mutable_chardata() {
  set_has_chardata();
  if (chardata_ == NULL) chardata_ = new ::CharData;
  return chardata_;
}
inline ::CharData* CharBinaryData::release_chardata() {
  clear_has_chardata();
  ::CharData* temp = chardata_;
  chardata_ = NULL;
  return temp;
}
inline void CharBinaryData::set_allocated_chardata(::CharData* chardata) {
  delete chardata_;
  chardata_ = chardata;
  if (chardata) {
    set_has_chardata();
  } else {
    clear_has_chardata();
  }
}

// repeated .ItemData equip_items = 2;
inline int CharBinaryData::equip_items_size() const {
  return equip_items_.size();
}
inline void CharBinaryData::clear_equip_items() {
  equip_items_.Clear();
}
inline const ::ItemData& CharBinaryData::equip_items(int index) const {
  return equip_items_.Get(index);
}
inline ::ItemData* CharBinaryData::mutable_equip_items(int index) {
  return equip_items_.Mutable(index);
}
inline ::ItemData* CharBinaryData::add_equip_items() {
  return equip_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
CharBinaryData::equip_items() const {
  return equip_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
CharBinaryData::mutable_equip_items() {
  return &equip_items_;
}

// repeated .ItemData avatar_items = 3;
inline int CharBinaryData::avatar_items_size() const {
  return avatar_items_.size();
}
inline void CharBinaryData::clear_avatar_items() {
  avatar_items_.Clear();
}
inline const ::ItemData& CharBinaryData::avatar_items(int index) const {
  return avatar_items_.Get(index);
}
inline ::ItemData* CharBinaryData::mutable_avatar_items(int index) {
  return avatar_items_.Mutable(index);
}
inline ::ItemData* CharBinaryData::add_avatar_items() {
  return avatar_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
CharBinaryData::avatar_items() const {
  return avatar_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
CharBinaryData::mutable_avatar_items() {
  return &avatar_items_;
}

// repeated .ItemData bag_items = 4;
inline int CharBinaryData::bag_items_size() const {
  return bag_items_.size();
}
inline void CharBinaryData::clear_bag_items() {
  bag_items_.Clear();
}
inline const ::ItemData& CharBinaryData::bag_items(int index) const {
  return bag_items_.Get(index);
}
inline ::ItemData* CharBinaryData::mutable_bag_items(int index) {
  return bag_items_.Mutable(index);
}
inline ::ItemData* CharBinaryData::add_bag_items() {
  return bag_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
CharBinaryData::bag_items() const {
  return bag_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
CharBinaryData::mutable_bag_items() {
  return &bag_items_;
}

// repeated .ItemData safe_items = 5;
inline int CharBinaryData::safe_items_size() const {
  return safe_items_.size();
}
inline void CharBinaryData::clear_safe_items() {
  safe_items_.Clear();
}
inline const ::ItemData& CharBinaryData::safe_items(int index) const {
  return safe_items_.Get(index);
}
inline ::ItemData* CharBinaryData::mutable_safe_items(int index) {
  return safe_items_.Mutable(index);
}
inline ::ItemData* CharBinaryData::add_safe_items() {
  return safe_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
CharBinaryData::safe_items() const {
  return safe_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
CharBinaryData::mutable_safe_items() {
  return &safe_items_;
}

// repeated .JobSkillData job_skills = 6;
inline int CharBinaryData::job_skills_size() const {
  return job_skills_.size();
}
inline void CharBinaryData::clear_job_skills() {
  job_skills_.Clear();
}
inline const ::JobSkillData& CharBinaryData::job_skills(int index) const {
  return job_skills_.Get(index);
}
inline ::JobSkillData* CharBinaryData::mutable_job_skills(int index) {
  return job_skills_.Mutable(index);
}
inline ::JobSkillData* CharBinaryData::add_job_skills() {
  return job_skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::JobSkillData >&
CharBinaryData::job_skills() const {
  return job_skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::JobSkillData >*
CharBinaryData::mutable_job_skills() {
  return &job_skills_;
}

// repeated .SkillData skills = 7;
inline int CharBinaryData::skills_size() const {
  return skills_.size();
}
inline void CharBinaryData::clear_skills() {
  skills_.Clear();
}
inline const ::SkillData& CharBinaryData::skills(int index) const {
  return skills_.Get(index);
}
inline ::SkillData* CharBinaryData::mutable_skills(int index) {
  return skills_.Mutable(index);
}
inline ::SkillData* CharBinaryData::add_skills() {
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkillData >&
CharBinaryData::skills() const {
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkillData >*
CharBinaryData::mutable_skills() {
  return &skills_;
}

// repeated .ShortcutKeyData shortcut_keys = 8;
inline int CharBinaryData::shortcut_keys_size() const {
  return shortcut_keys_.size();
}
inline void CharBinaryData::clear_shortcut_keys() {
  shortcut_keys_.Clear();
}
inline const ::ShortcutKeyData& CharBinaryData::shortcut_keys(int index) const {
  return shortcut_keys_.Get(index);
}
inline ::ShortcutKeyData* CharBinaryData::mutable_shortcut_keys(int index) {
  return shortcut_keys_.Mutable(index);
}
inline ::ShortcutKeyData* CharBinaryData::add_shortcut_keys() {
  return shortcut_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShortcutKeyData >&
CharBinaryData::shortcut_keys() const {
  return shortcut_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::ShortcutKeyData >*
CharBinaryData::mutable_shortcut_keys() {
  return &shortcut_keys_;
}

// repeated .SkillBuffData skill_buffs = 9;
inline int CharBinaryData::skill_buffs_size() const {
  return skill_buffs_.size();
}
inline void CharBinaryData::clear_skill_buffs() {
  skill_buffs_.Clear();
}
inline const ::SkillBuffData& CharBinaryData::skill_buffs(int index) const {
  return skill_buffs_.Get(index);
}
inline ::SkillBuffData* CharBinaryData::mutable_skill_buffs(int index) {
  return skill_buffs_.Mutable(index);
}
inline ::SkillBuffData* CharBinaryData::add_skill_buffs() {
  return skill_buffs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkillBuffData >&
CharBinaryData::skill_buffs() const {
  return skill_buffs_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkillBuffData >*
CharBinaryData::mutable_skill_buffs() {
  return &skill_buffs_;
}

// repeated .MissionData missions = 10;
inline int CharBinaryData::missions_size() const {
  return missions_.size();
}
inline void CharBinaryData::clear_missions() {
  missions_.Clear();
}
inline const ::MissionData& CharBinaryData::missions(int index) const {
  return missions_.Get(index);
}
inline ::MissionData* CharBinaryData::mutable_missions(int index) {
  return missions_.Mutable(index);
}
inline ::MissionData* CharBinaryData::add_missions() {
  return missions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MissionData >&
CharBinaryData::missions() const {
  return missions_;
}
inline ::google::protobuf::RepeatedPtrField< ::MissionData >*
CharBinaryData::mutable_missions() {
  return &missions_;
}

// repeated .AchievementData achievements = 11;
inline int CharBinaryData::achievements_size() const {
  return achievements_.size();
}
inline void CharBinaryData::clear_achievements() {
  achievements_.Clear();
}
inline const ::AchievementData& CharBinaryData::achievements(int index) const {
  return achievements_.Get(index);
}
inline ::AchievementData* CharBinaryData::mutable_achievements(int index) {
  return achievements_.Mutable(index);
}
inline ::AchievementData* CharBinaryData::add_achievements() {
  return achievements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AchievementData >&
CharBinaryData::achievements() const {
  return achievements_;
}
inline ::google::protobuf::RepeatedPtrField< ::AchievementData >*
CharBinaryData::mutable_achievements() {
  return &achievements_;
}

// repeated .ActivityData activitys = 12;
inline int CharBinaryData::activitys_size() const {
  return activitys_.size();
}
inline void CharBinaryData::clear_activitys() {
  activitys_.Clear();
}
inline const ::ActivityData& CharBinaryData::activitys(int index) const {
  return activitys_.Get(index);
}
inline ::ActivityData* CharBinaryData::mutable_activitys(int index) {
  return activitys_.Mutable(index);
}
inline ::ActivityData* CharBinaryData::add_activitys() {
  return activitys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ActivityData >&
CharBinaryData::activitys() const {
  return activitys_;
}
inline ::google::protobuf::RepeatedPtrField< ::ActivityData >*
CharBinaryData::mutable_activitys() {
  return &activitys_;
}

// optional .SettingData setting_data = 13;
inline bool CharBinaryData::has_setting_data() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CharBinaryData::set_has_setting_data() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CharBinaryData::clear_has_setting_data() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CharBinaryData::clear_setting_data() {
  if (setting_data_ != NULL) setting_data_->::SettingData::Clear();
  clear_has_setting_data();
}
inline const ::SettingData& CharBinaryData::setting_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return setting_data_ != NULL ? *setting_data_ : *default_instance().setting_data_;
#else
  return setting_data_ != NULL ? *setting_data_ : *default_instance_->setting_data_;
#endif
}
inline ::SettingData* CharBinaryData::mutable_setting_data() {
  set_has_setting_data();
  if (setting_data_ == NULL) setting_data_ = new ::SettingData;
  return setting_data_;
}
inline ::SettingData* CharBinaryData::release_setting_data() {
  clear_has_setting_data();
  ::SettingData* temp = setting_data_;
  setting_data_ = NULL;
  return temp;
}
inline void CharBinaryData::set_allocated_setting_data(::SettingData* setting_data) {
  delete setting_data_;
  setting_data_ = setting_data;
  if (setting_data) {
    set_has_setting_data();
  } else {
    clear_has_setting_data();
  }
}

// optional .OnlineRewardsData onlinerewards_data = 14;
inline bool CharBinaryData::has_onlinerewards_data() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CharBinaryData::set_has_onlinerewards_data() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CharBinaryData::clear_has_onlinerewards_data() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CharBinaryData::clear_onlinerewards_data() {
  if (onlinerewards_data_ != NULL) onlinerewards_data_->::OnlineRewardsData::Clear();
  clear_has_onlinerewards_data();
}
inline const ::OnlineRewardsData& CharBinaryData::onlinerewards_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return onlinerewards_data_ != NULL ? *onlinerewards_data_ : *default_instance().onlinerewards_data_;
#else
  return onlinerewards_data_ != NULL ? *onlinerewards_data_ : *default_instance_->onlinerewards_data_;
#endif
}
inline ::OnlineRewardsData* CharBinaryData::mutable_onlinerewards_data() {
  set_has_onlinerewards_data();
  if (onlinerewards_data_ == NULL) onlinerewards_data_ = new ::OnlineRewardsData;
  return onlinerewards_data_;
}
inline ::OnlineRewardsData* CharBinaryData::release_onlinerewards_data() {
  clear_has_onlinerewards_data();
  ::OnlineRewardsData* temp = onlinerewards_data_;
  onlinerewards_data_ = NULL;
  return temp;
}
inline void CharBinaryData::set_allocated_onlinerewards_data(::OnlineRewardsData* onlinerewards_data) {
  delete onlinerewards_data_;
  onlinerewards_data_ = onlinerewards_data;
  if (onlinerewards_data) {
    set_has_onlinerewards_data();
  } else {
    clear_has_onlinerewards_data();
  }
}

// repeated .CounterData counter_data = 15;
inline int CharBinaryData::counter_data_size() const {
  return counter_data_.size();
}
inline void CharBinaryData::clear_counter_data() {
  counter_data_.Clear();
}
inline const ::CounterData& CharBinaryData::counter_data(int index) const {
  return counter_data_.Get(index);
}
inline ::CounterData* CharBinaryData::mutable_counter_data(int index) {
  return counter_data_.Mutable(index);
}
inline ::CounterData* CharBinaryData::add_counter_data() {
  return counter_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CounterData >&
CharBinaryData::counter_data() const {
  return counter_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::CounterData >*
CharBinaryData::mutable_counter_data() {
  return &counter_data_;
}

// -------------------------------------------------------------------

// MapCell

// optional .MapCellFlag flag = 1;
inline bool MapCell::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapCell::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapCell::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapCell::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::MapCellFlag MapCell::flag() const {
  return static_cast< ::MapCellFlag >(flag_);
}
inline void MapCell::set_flag(::MapCellFlag value) {
  assert(::MapCellFlag_IsValid(value));
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// TileMapData

// optional int32 width = 1;
inline bool TileMapData::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TileMapData::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TileMapData::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TileMapData::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 TileMapData::width() const {
  return width_;
}
inline void TileMapData::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 2;
inline bool TileMapData::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TileMapData::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TileMapData::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TileMapData::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 TileMapData::height() const {
  return height_;
}
inline void TileMapData::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// optional int32 tilewidth = 3;
inline bool TileMapData::has_tilewidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TileMapData::set_has_tilewidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TileMapData::clear_has_tilewidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TileMapData::clear_tilewidth() {
  tilewidth_ = 0;
  clear_has_tilewidth();
}
inline ::google::protobuf::int32 TileMapData::tilewidth() const {
  return tilewidth_;
}
inline void TileMapData::set_tilewidth(::google::protobuf::int32 value) {
  set_has_tilewidth();
  tilewidth_ = value;
}

// optional int32 tileheight = 4;
inline bool TileMapData::has_tileheight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TileMapData::set_has_tileheight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TileMapData::clear_has_tileheight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TileMapData::clear_tileheight() {
  tileheight_ = 0;
  clear_has_tileheight();
}
inline ::google::protobuf::int32 TileMapData::tileheight() const {
  return tileheight_;
}
inline void TileMapData::set_tileheight(::google::protobuf::int32 value) {
  set_has_tileheight();
  tileheight_ = value;
}

// repeated .MapCell cell_list = 5;
inline int TileMapData::cell_list_size() const {
  return cell_list_.size();
}
inline void TileMapData::clear_cell_list() {
  cell_list_.Clear();
}
inline const ::MapCell& TileMapData::cell_list(int index) const {
  return cell_list_.Get(index);
}
inline ::MapCell* TileMapData::mutable_cell_list(int index) {
  return cell_list_.Mutable(index);
}
inline ::MapCell* TileMapData::add_cell_list() {
  return cell_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapCell >&
TileMapData::cell_list() const {
  return cell_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapCell >*
TileMapData::mutable_cell_list() {
  return &cell_list_;
}

// -------------------------------------------------------------------

// MapCharInfo

// optional int32 id = 1;
inline bool MapCharInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapCharInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapCharInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapCharInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapCharInfo::id() const {
  return id_;
}
inline void MapCharInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool MapCharInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapCharInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapCharInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapCharInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MapCharInfo::name() const {
  return *name_;
}
inline void MapCharInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapCharInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapCharInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapCharInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MapCharInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapCharInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 3;
inline bool MapCharInfo::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapCharInfo::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapCharInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapCharInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 MapCharInfo::level() const {
  return level_;
}
inline void MapCharInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 country = 4;
inline bool MapCharInfo::has_country() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapCharInfo::set_has_country() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapCharInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapCharInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 MapCharInfo::country() const {
  return country_;
}
inline void MapCharInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional int32 curhp = 5;
inline bool MapCharInfo::has_curhp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapCharInfo::set_has_curhp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapCharInfo::clear_has_curhp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapCharInfo::clear_curhp() {
  curhp_ = 0;
  clear_has_curhp();
}
inline ::google::protobuf::int32 MapCharInfo::curhp() const {
  return curhp_;
}
inline void MapCharInfo::set_curhp(::google::protobuf::int32 value) {
  set_has_curhp();
  curhp_ = value;
}

// optional int32 maxhp = 6;
inline bool MapCharInfo::has_maxhp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapCharInfo::set_has_maxhp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapCharInfo::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapCharInfo::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 MapCharInfo::maxhp() const {
  return maxhp_;
}
inline void MapCharInfo::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
}

// optional int32 curmp = 7;
inline bool MapCharInfo::has_curmp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapCharInfo::set_has_curmp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapCharInfo::clear_has_curmp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapCharInfo::clear_curmp() {
  curmp_ = 0;
  clear_has_curmp();
}
inline ::google::protobuf::int32 MapCharInfo::curmp() const {
  return curmp_;
}
inline void MapCharInfo::set_curmp(::google::protobuf::int32 value) {
  set_has_curmp();
  curmp_ = value;
}

// optional int32 maxmp = 8;
inline bool MapCharInfo::has_maxmp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapCharInfo::set_has_maxmp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapCharInfo::clear_has_maxmp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapCharInfo::clear_maxmp() {
  maxmp_ = 0;
  clear_has_maxmp();
}
inline ::google::protobuf::int32 MapCharInfo::maxmp() const {
  return maxmp_;
}
inline void MapCharInfo::set_maxmp(::google::protobuf::int32 value) {
  set_has_maxmp();
  maxmp_ = value;
}

// optional int32 x = 9;
inline bool MapCharInfo::has_x() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapCharInfo::set_has_x() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapCharInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapCharInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapCharInfo::x() const {
  return x_;
}
inline void MapCharInfo::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 10;
inline bool MapCharInfo::has_y() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapCharInfo::set_has_y() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapCharInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapCharInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapCharInfo::y() const {
  return y_;
}
inline void MapCharInfo::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 tx = 11;
inline bool MapCharInfo::has_tx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapCharInfo::set_has_tx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapCharInfo::clear_has_tx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapCharInfo::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
inline ::google::protobuf::int32 MapCharInfo::tx() const {
  return tx_;
}
inline void MapCharInfo::set_tx(::google::protobuf::int32 value) {
  set_has_tx();
  tx_ = value;
}

// optional int32 ty = 12;
inline bool MapCharInfo::has_ty() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapCharInfo::set_has_ty() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapCharInfo::clear_has_ty() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapCharInfo::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline ::google::protobuf::int32 MapCharInfo::ty() const {
  return ty_;
}
inline void MapCharInfo::set_ty(::google::protobuf::int32 value) {
  set_has_ty();
  ty_ = value;
}

// optional int32 direction = 13;
inline bool MapCharInfo::has_direction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MapCharInfo::set_has_direction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MapCharInfo::clear_has_direction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MapCharInfo::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 MapCharInfo::direction() const {
  return direction_;
}
inline void MapCharInfo::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional int32 race = 14;
inline bool MapCharInfo::has_race() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MapCharInfo::set_has_race() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MapCharInfo::clear_has_race() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MapCharInfo::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::google::protobuf::int32 MapCharInfo::race() const {
  return race_;
}
inline void MapCharInfo::set_race(::google::protobuf::int32 value) {
  set_has_race();
  race_ = value;
}

// optional int32 move_speed = 15;
inline bool MapCharInfo::has_move_speed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MapCharInfo::set_has_move_speed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MapCharInfo::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MapCharInfo::clear_move_speed() {
  move_speed_ = 0;
  clear_has_move_speed();
}
inline ::google::protobuf::int32 MapCharInfo::move_speed() const {
  return move_speed_;
}
inline void MapCharInfo::set_move_speed(::google::protobuf::int32 value) {
  set_has_move_speed();
  move_speed_ = value;
}

// optional .ObjectState state = 16;
inline bool MapCharInfo::has_state() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MapCharInfo::set_has_state() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MapCharInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MapCharInfo::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::ObjectState MapCharInfo::state() const {
  return static_cast< ::ObjectState >(state_);
}
inline void MapCharInfo::set_state(::ObjectState value) {
  assert(::ObjectState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated int32 looks = 17;
inline int MapCharInfo::looks_size() const {
  return looks_.size();
}
inline void MapCharInfo::clear_looks() {
  looks_.Clear();
}
inline ::google::protobuf::int32 MapCharInfo::looks(int index) const {
  return looks_.Get(index);
}
inline void MapCharInfo::set_looks(int index, ::google::protobuf::int32 value) {
  looks_.Set(index, value);
}
inline void MapCharInfo::add_looks(::google::protobuf::int32 value) {
  looks_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MapCharInfo::looks() const {
  return looks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MapCharInfo::mutable_looks() {
  return &looks_;
}

// repeated .SkillBuffData skill_buffs = 18;
inline int MapCharInfo::skill_buffs_size() const {
  return skill_buffs_.size();
}
inline void MapCharInfo::clear_skill_buffs() {
  skill_buffs_.Clear();
}
inline const ::SkillBuffData& MapCharInfo::skill_buffs(int index) const {
  return skill_buffs_.Get(index);
}
inline ::SkillBuffData* MapCharInfo::mutable_skill_buffs(int index) {
  return skill_buffs_.Mutable(index);
}
inline ::SkillBuffData* MapCharInfo::add_skill_buffs() {
  return skill_buffs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkillBuffData >&
MapCharInfo::skill_buffs() const {
  return skill_buffs_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkillBuffData >*
MapCharInfo::mutable_skill_buffs() {
  return &skill_buffs_;
}

// -------------------------------------------------------------------

// MapMonsterInfo

// optional int32 id = 1;
inline bool MapMonsterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapMonsterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapMonsterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapMonsterInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapMonsterInfo::id() const {
  return id_;
}
inline void MapMonsterInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 curhp = 2;
inline bool MapMonsterInfo::has_curhp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapMonsterInfo::set_has_curhp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapMonsterInfo::clear_has_curhp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapMonsterInfo::clear_curhp() {
  curhp_ = 0;
  clear_has_curhp();
}
inline ::google::protobuf::int32 MapMonsterInfo::curhp() const {
  return curhp_;
}
inline void MapMonsterInfo::set_curhp(::google::protobuf::int32 value) {
  set_has_curhp();
  curhp_ = value;
}

// optional int32 maxhp = 3;
inline bool MapMonsterInfo::has_maxhp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapMonsterInfo::set_has_maxhp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapMonsterInfo::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapMonsterInfo::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 MapMonsterInfo::maxhp() const {
  return maxhp_;
}
inline void MapMonsterInfo::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
}

// optional int32 x = 4;
inline bool MapMonsterInfo::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapMonsterInfo::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapMonsterInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapMonsterInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapMonsterInfo::x() const {
  return x_;
}
inline void MapMonsterInfo::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 5;
inline bool MapMonsterInfo::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapMonsterInfo::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapMonsterInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapMonsterInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapMonsterInfo::y() const {
  return y_;
}
inline void MapMonsterInfo::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 monid = 6;
inline bool MapMonsterInfo::has_monid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapMonsterInfo::set_has_monid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapMonsterInfo::clear_has_monid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapMonsterInfo::clear_monid() {
  monid_ = 0;
  clear_has_monid();
}
inline ::google::protobuf::int32 MapMonsterInfo::monid() const {
  return monid_;
}
inline void MapMonsterInfo::set_monid(::google::protobuf::int32 value) {
  set_has_monid();
  monid_ = value;
}

// optional int32 move_speed = 7;
inline bool MapMonsterInfo::has_move_speed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapMonsterInfo::set_has_move_speed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapMonsterInfo::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapMonsterInfo::clear_move_speed() {
  move_speed_ = 0;
  clear_has_move_speed();
}
inline ::google::protobuf::int32 MapMonsterInfo::move_speed() const {
  return move_speed_;
}
inline void MapMonsterInfo::set_move_speed(::google::protobuf::int32 value) {
  set_has_move_speed();
  move_speed_ = value;
}

// optional .ObjectState state = 8;
inline bool MapMonsterInfo::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapMonsterInfo::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapMonsterInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapMonsterInfo::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::ObjectState MapMonsterInfo::state() const {
  return static_cast< ::ObjectState >(state_);
}
inline void MapMonsterInfo::set_state(::ObjectState value) {
  assert(::ObjectState_IsValid(value));
  set_has_state();
  state_ = value;
}

// repeated .SkillBuffData skill_buffs = 9;
inline int MapMonsterInfo::skill_buffs_size() const {
  return skill_buffs_.size();
}
inline void MapMonsterInfo::clear_skill_buffs() {
  skill_buffs_.Clear();
}
inline const ::SkillBuffData& MapMonsterInfo::skill_buffs(int index) const {
  return skill_buffs_.Get(index);
}
inline ::SkillBuffData* MapMonsterInfo::mutable_skill_buffs(int index) {
  return skill_buffs_.Mutable(index);
}
inline ::SkillBuffData* MapMonsterInfo::add_skill_buffs() {
  return skill_buffs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SkillBuffData >&
MapMonsterInfo::skill_buffs() const {
  return skill_buffs_;
}
inline ::google::protobuf::RepeatedPtrField< ::SkillBuffData >*
MapMonsterInfo::mutable_skill_buffs() {
  return &skill_buffs_;
}

// -------------------------------------------------------------------

// MapNpcInfo

// optional int32 id = 1;
inline bool MapNpcInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapNpcInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapNpcInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapNpcInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapNpcInfo::id() const {
  return id_;
}
inline void MapNpcInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool MapNpcInfo::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapNpcInfo::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapNpcInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapNpcInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MapNpcInfo::x() const {
  return x_;
}
inline void MapNpcInfo::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool MapNpcInfo::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapNpcInfo::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapNpcInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapNpcInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MapNpcInfo::y() const {
  return y_;
}
inline void MapNpcInfo::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 npcid = 4;
inline bool MapNpcInfo::has_npcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapNpcInfo::set_has_npcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapNpcInfo::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapNpcInfo::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 MapNpcInfo::npcid() const {
  return npcid_;
}
inline void MapNpcInfo::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
}

// optional int32 func = 5;
inline bool MapNpcInfo::has_func() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapNpcInfo::set_has_func() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapNpcInfo::clear_has_func() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapNpcInfo::clear_func() {
  func_ = 0;
  clear_has_func();
}
inline ::google::protobuf::int32 MapNpcInfo::func() const {
  return func_;
}
inline void MapNpcInfo::set_func(::google::protobuf::int32 value) {
  set_has_func();
  func_ = value;
}

// -------------------------------------------------------------------

// ItemLoc

// optional int32 pkg = 1;
inline bool ItemLoc::has_pkg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemLoc::set_has_pkg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemLoc::clear_has_pkg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemLoc::clear_pkg() {
  pkg_ = 0;
  clear_has_pkg();
}
inline ::google::protobuf::int32 ItemLoc::pkg() const {
  return pkg_;
}
inline void ItemLoc::set_pkg(::google::protobuf::int32 value) {
  set_has_pkg();
  pkg_ = value;
}

// optional int32 slot = 2;
inline bool ItemLoc::has_slot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemLoc::set_has_slot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemLoc::clear_has_slot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemLoc::clear_slot() {
  slot_ = 0;
  clear_has_slot();
}
inline ::google::protobuf::int32 ItemLoc::slot() const {
  return slot_;
}
inline void ItemLoc::set_slot(::google::protobuf::int32 value) {
  set_has_slot();
  slot_ = value;
}

// -------------------------------------------------------------------

// ItemLocData

// optional .ItemLoc loc = 1;
inline bool ItemLocData::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemLocData::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemLocData::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemLocData::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& ItemLocData::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* ItemLocData::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* ItemLocData::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void ItemLocData::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// optional .ItemData item = 2;
inline bool ItemLocData::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemLocData::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemLocData::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemLocData::clear_item() {
  if (item_ != NULL) item_->::ItemData::Clear();
  clear_has_item();
}
inline const ::ItemData& ItemLocData::item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::ItemData* ItemLocData::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::ItemData;
  return item_;
}
inline ::ItemData* ItemLocData::release_item() {
  clear_has_item();
  ::ItemData* temp = item_;
  item_ = NULL;
  return temp;
}
inline void ItemLocData::set_allocated_item(::ItemData* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// ItemLocNum

// optional .ItemLoc loc = 1;
inline bool ItemLocNum::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemLocNum::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemLocNum::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemLocNum::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& ItemLocNum::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* ItemLocNum::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* ItemLocNum::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void ItemLocNum::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// optional uint32 num = 2;
inline bool ItemLocNum::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemLocNum::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemLocNum::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemLocNum::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 ItemLocNum::num() const {
  return num_;
}
inline void ItemLocNum::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoGameData_2eproto__INCLUDED
