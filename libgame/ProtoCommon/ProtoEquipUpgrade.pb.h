// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoEquipUpgrade.proto

#ifndef PROTOBUF_ProtoEquipUpgrade_2eproto__INCLUDED
#define PROTOBUF_ProtoEquipUpgrade_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

class RequestUpgradeEquip;
class ResponseUpgradeEquip;
class RequestAddEquipGroove;
class ResponseAddEquipGroove;
class RequestFillEquipGroove;
class ResponseFillEquipGroove;
class RequestRemoveEquipJewel;
class ResponseRemoveEquipJewel;
class RequestUpgradeJewel;
class ResponseUpgradeJewel;

enum EquipUpgradeOpCode {
  OP_EQUIP_UPGRADE = 1,
  OP_EQUIP_ADD_GROOVE = 2,
  OP_EQUIP_FILL_GROOVE = 3,
  OP_EQUIP_REMOVE_JEWEL = 4,
  OP_JEWEL_UPGRADE = 5
};
bool EquipUpgradeOpCode_IsValid(int value);
const EquipUpgradeOpCode EquipUpgradeOpCode_MIN = OP_EQUIP_UPGRADE;
const EquipUpgradeOpCode EquipUpgradeOpCode_MAX = OP_JEWEL_UPGRADE;
const int EquipUpgradeOpCode_ARRAYSIZE = EquipUpgradeOpCode_MAX + 1;

// ===================================================================

class RequestUpgradeEquip : public ::google::protobuf::MessageLite {
 public:
  RequestUpgradeEquip();
  virtual ~RequestUpgradeEquip();

  RequestUpgradeEquip(const RequestUpgradeEquip& from);

  inline RequestUpgradeEquip& operator=(const RequestUpgradeEquip& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestUpgradeEquip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpgradeEquip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpgradeEquip* other);

  // implements Message ----------------------------------------------

  RequestUpgradeEquip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpgradeEquip& from);
  void MergeFrom(const RequestUpgradeEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc equip_loc = 1;
  inline bool has_equip_loc() const;
  inline void clear_equip_loc();
  static const int kEquipLocFieldNumber = 1;
  inline const ::ItemLoc& equip_loc() const;
  inline ::ItemLoc* mutable_equip_loc();
  inline ::ItemLoc* release_equip_loc();
  inline void set_allocated_equip_loc(::ItemLoc* equip_loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestUpgradeEquip)
 private:
  inline void set_has_equip_loc();
  inline void clear_has_equip_loc();

  ::ItemLoc* equip_loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static RequestUpgradeEquip* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUpgradeEquip : public ::google::protobuf::MessageLite {
 public:
  ResponseUpgradeEquip();
  virtual ~ResponseUpgradeEquip();

  ResponseUpgradeEquip(const ResponseUpgradeEquip& from);

  inline ResponseUpgradeEquip& operator=(const ResponseUpgradeEquip& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseUpgradeEquip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseUpgradeEquip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseUpgradeEquip* other);

  // implements Message ----------------------------------------------

  ResponseUpgradeEquip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseUpgradeEquip& from);
  void MergeFrom(const ResponseUpgradeEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseUpgradeEquip)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static ResponseUpgradeEquip* default_instance_;
};
// -------------------------------------------------------------------

class RequestAddEquipGroove : public ::google::protobuf::MessageLite {
 public:
  RequestAddEquipGroove();
  virtual ~RequestAddEquipGroove();

  RequestAddEquipGroove(const RequestAddEquipGroove& from);

  inline RequestAddEquipGroove& operator=(const RequestAddEquipGroove& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestAddEquipGroove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestAddEquipGroove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestAddEquipGroove* other);

  // implements Message ----------------------------------------------

  RequestAddEquipGroove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestAddEquipGroove& from);
  void MergeFrom(const RequestAddEquipGroove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc equip_loc = 1;
  inline bool has_equip_loc() const;
  inline void clear_equip_loc();
  static const int kEquipLocFieldNumber = 1;
  inline const ::ItemLoc& equip_loc() const;
  inline ::ItemLoc* mutable_equip_loc();
  inline ::ItemLoc* release_equip_loc();
  inline void set_allocated_equip_loc(::ItemLoc* equip_loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestAddEquipGroove)
 private:
  inline void set_has_equip_loc();
  inline void clear_has_equip_loc();

  ::ItemLoc* equip_loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static RequestAddEquipGroove* default_instance_;
};
// -------------------------------------------------------------------

class ResponseAddEquipGroove : public ::google::protobuf::MessageLite {
 public:
  ResponseAddEquipGroove();
  virtual ~ResponseAddEquipGroove();

  ResponseAddEquipGroove(const ResponseAddEquipGroove& from);

  inline ResponseAddEquipGroove& operator=(const ResponseAddEquipGroove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseAddEquipGroove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseAddEquipGroove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseAddEquipGroove* other);

  // implements Message ----------------------------------------------

  ResponseAddEquipGroove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseAddEquipGroove& from);
  void MergeFrom(const ResponseAddEquipGroove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseAddEquipGroove)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static ResponseAddEquipGroove* default_instance_;
};
// -------------------------------------------------------------------

class RequestFillEquipGroove : public ::google::protobuf::MessageLite {
 public:
  RequestFillEquipGroove();
  virtual ~RequestFillEquipGroove();

  RequestFillEquipGroove(const RequestFillEquipGroove& from);

  inline RequestFillEquipGroove& operator=(const RequestFillEquipGroove& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestFillEquipGroove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestFillEquipGroove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestFillEquipGroove* other);

  // implements Message ----------------------------------------------

  RequestFillEquipGroove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestFillEquipGroove& from);
  void MergeFrom(const RequestFillEquipGroove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc equip_loc = 1;
  inline bool has_equip_loc() const;
  inline void clear_equip_loc();
  static const int kEquipLocFieldNumber = 1;
  inline const ::ItemLoc& equip_loc() const;
  inline ::ItemLoc* mutable_equip_loc();
  inline ::ItemLoc* release_equip_loc();
  inline void set_allocated_equip_loc(::ItemLoc* equip_loc);

  // optional .ItemLoc stuff_loc = 2;
  inline bool has_stuff_loc() const;
  inline void clear_stuff_loc();
  static const int kStuffLocFieldNumber = 2;
  inline const ::ItemLoc& stuff_loc() const;
  inline ::ItemLoc* mutable_stuff_loc();
  inline ::ItemLoc* release_stuff_loc();
  inline void set_allocated_stuff_loc(::ItemLoc* stuff_loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestFillEquipGroove)
 private:
  inline void set_has_equip_loc();
  inline void clear_has_equip_loc();
  inline void set_has_stuff_loc();
  inline void clear_has_stuff_loc();

  ::ItemLoc* equip_loc_;
  ::ItemLoc* stuff_loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static RequestFillEquipGroove* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFillEquipGroove : public ::google::protobuf::MessageLite {
 public:
  ResponseFillEquipGroove();
  virtual ~ResponseFillEquipGroove();

  ResponseFillEquipGroove(const ResponseFillEquipGroove& from);

  inline ResponseFillEquipGroove& operator=(const ResponseFillEquipGroove& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseFillEquipGroove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseFillEquipGroove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseFillEquipGroove* other);

  // implements Message ----------------------------------------------

  ResponseFillEquipGroove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseFillEquipGroove& from);
  void MergeFrom(const ResponseFillEquipGroove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseFillEquipGroove)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static ResponseFillEquipGroove* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoveEquipJewel : public ::google::protobuf::MessageLite {
 public:
  RequestRemoveEquipJewel();
  virtual ~RequestRemoveEquipJewel();

  RequestRemoveEquipJewel(const RequestRemoveEquipJewel& from);

  inline RequestRemoveEquipJewel& operator=(const RequestRemoveEquipJewel& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestRemoveEquipJewel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoveEquipJewel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoveEquipJewel* other);

  // implements Message ----------------------------------------------

  RequestRemoveEquipJewel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoveEquipJewel& from);
  void MergeFrom(const RequestRemoveEquipJewel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc equip_loc = 1;
  inline bool has_equip_loc() const;
  inline void clear_equip_loc();
  static const int kEquipLocFieldNumber = 1;
  inline const ::ItemLoc& equip_loc() const;
  inline ::ItemLoc* mutable_equip_loc();
  inline ::ItemLoc* release_equip_loc();
  inline void set_allocated_equip_loc(::ItemLoc* equip_loc);

  // optional int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional bool destroy = 3;
  inline bool has_destroy() const;
  inline void clear_destroy();
  static const int kDestroyFieldNumber = 3;
  inline bool destroy() const;
  inline void set_destroy(bool value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestRemoveEquipJewel)
 private:
  inline void set_has_equip_loc();
  inline void clear_has_equip_loc();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_destroy();
  inline void clear_has_destroy();

  ::ItemLoc* equip_loc_;
  ::google::protobuf::int32 index_;
  bool destroy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoveEquipJewel* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRemoveEquipJewel : public ::google::protobuf::MessageLite {
 public:
  ResponseRemoveEquipJewel();
  virtual ~ResponseRemoveEquipJewel();

  ResponseRemoveEquipJewel(const ResponseRemoveEquipJewel& from);

  inline ResponseRemoveEquipJewel& operator=(const ResponseRemoveEquipJewel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseRemoveEquipJewel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseRemoveEquipJewel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseRemoveEquipJewel* other);

  // implements Message ----------------------------------------------

  ResponseRemoveEquipJewel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseRemoveEquipJewel& from);
  void MergeFrom(const ResponseRemoveEquipJewel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseRemoveEquipJewel)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static ResponseRemoveEquipJewel* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpgradeJewel : public ::google::protobuf::MessageLite {
 public:
  RequestUpgradeJewel();
  virtual ~RequestUpgradeJewel();

  RequestUpgradeJewel(const RequestUpgradeJewel& from);

  inline RequestUpgradeJewel& operator=(const RequestUpgradeJewel& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestUpgradeJewel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUpgradeJewel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUpgradeJewel* other);

  // implements Message ----------------------------------------------

  RequestUpgradeJewel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUpgradeJewel& from);
  void MergeFrom(const RequestUpgradeJewel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestUpgradeJewel)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();

  ::ItemLoc* loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static RequestUpgradeJewel* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUpgradeJewel : public ::google::protobuf::MessageLite {
 public:
  ResponseUpgradeJewel();
  virtual ~ResponseUpgradeJewel();

  ResponseUpgradeJewel(const ResponseUpgradeJewel& from);

  inline ResponseUpgradeJewel& operator=(const ResponseUpgradeJewel& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseUpgradeJewel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseUpgradeJewel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseUpgradeJewel* other);

  // implements Message ----------------------------------------------

  ResponseUpgradeJewel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseUpgradeJewel& from);
  void MergeFrom(const ResponseUpgradeJewel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseUpgradeJewel)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoEquipUpgrade_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoEquipUpgrade_2eproto();
  friend void protobuf_ShutdownFile_ProtoEquipUpgrade_2eproto();

  void InitAsDefaultInstance();
  static ResponseUpgradeJewel* default_instance_;
};
// ===================================================================


// ===================================================================

// RequestUpgradeEquip

// optional .ItemLoc equip_loc = 1;
inline bool RequestUpgradeEquip::has_equip_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpgradeEquip::set_has_equip_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpgradeEquip::clear_has_equip_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpgradeEquip::clear_equip_loc() {
  if (equip_loc_ != NULL) equip_loc_->::ItemLoc::Clear();
  clear_has_equip_loc();
}
inline const ::ItemLoc& RequestUpgradeEquip::equip_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance().equip_loc_;
#else
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance_->equip_loc_;
#endif
}
inline ::ItemLoc* RequestUpgradeEquip::mutable_equip_loc() {
  set_has_equip_loc();
  if (equip_loc_ == NULL) equip_loc_ = new ::ItemLoc;
  return equip_loc_;
}
inline ::ItemLoc* RequestUpgradeEquip::release_equip_loc() {
  clear_has_equip_loc();
  ::ItemLoc* temp = equip_loc_;
  equip_loc_ = NULL;
  return temp;
}
inline void RequestUpgradeEquip::set_allocated_equip_loc(::ItemLoc* equip_loc) {
  delete equip_loc_;
  equip_loc_ = equip_loc;
  if (equip_loc) {
    set_has_equip_loc();
  } else {
    clear_has_equip_loc();
  }
}

// -------------------------------------------------------------------

// ResponseUpgradeEquip

// optional int32 result = 1;
inline bool ResponseUpgradeEquip::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUpgradeEquip::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUpgradeEquip::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUpgradeEquip::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseUpgradeEquip::result() const {
  return result_;
}
inline void ResponseUpgradeEquip::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestAddEquipGroove

// optional .ItemLoc equip_loc = 1;
inline bool RequestAddEquipGroove::has_equip_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestAddEquipGroove::set_has_equip_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestAddEquipGroove::clear_has_equip_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestAddEquipGroove::clear_equip_loc() {
  if (equip_loc_ != NULL) equip_loc_->::ItemLoc::Clear();
  clear_has_equip_loc();
}
inline const ::ItemLoc& RequestAddEquipGroove::equip_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance().equip_loc_;
#else
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance_->equip_loc_;
#endif
}
inline ::ItemLoc* RequestAddEquipGroove::mutable_equip_loc() {
  set_has_equip_loc();
  if (equip_loc_ == NULL) equip_loc_ = new ::ItemLoc;
  return equip_loc_;
}
inline ::ItemLoc* RequestAddEquipGroove::release_equip_loc() {
  clear_has_equip_loc();
  ::ItemLoc* temp = equip_loc_;
  equip_loc_ = NULL;
  return temp;
}
inline void RequestAddEquipGroove::set_allocated_equip_loc(::ItemLoc* equip_loc) {
  delete equip_loc_;
  equip_loc_ = equip_loc;
  if (equip_loc) {
    set_has_equip_loc();
  } else {
    clear_has_equip_loc();
  }
}

// -------------------------------------------------------------------

// ResponseAddEquipGroove

// optional int32 result = 1;
inline bool ResponseAddEquipGroove::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseAddEquipGroove::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseAddEquipGroove::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseAddEquipGroove::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseAddEquipGroove::result() const {
  return result_;
}
inline void ResponseAddEquipGroove::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestFillEquipGroove

// optional .ItemLoc equip_loc = 1;
inline bool RequestFillEquipGroove::has_equip_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFillEquipGroove::set_has_equip_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFillEquipGroove::clear_has_equip_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFillEquipGroove::clear_equip_loc() {
  if (equip_loc_ != NULL) equip_loc_->::ItemLoc::Clear();
  clear_has_equip_loc();
}
inline const ::ItemLoc& RequestFillEquipGroove::equip_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance().equip_loc_;
#else
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance_->equip_loc_;
#endif
}
inline ::ItemLoc* RequestFillEquipGroove::mutable_equip_loc() {
  set_has_equip_loc();
  if (equip_loc_ == NULL) equip_loc_ = new ::ItemLoc;
  return equip_loc_;
}
inline ::ItemLoc* RequestFillEquipGroove::release_equip_loc() {
  clear_has_equip_loc();
  ::ItemLoc* temp = equip_loc_;
  equip_loc_ = NULL;
  return temp;
}
inline void RequestFillEquipGroove::set_allocated_equip_loc(::ItemLoc* equip_loc) {
  delete equip_loc_;
  equip_loc_ = equip_loc;
  if (equip_loc) {
    set_has_equip_loc();
  } else {
    clear_has_equip_loc();
  }
}

// optional .ItemLoc stuff_loc = 2;
inline bool RequestFillEquipGroove::has_stuff_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestFillEquipGroove::set_has_stuff_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestFillEquipGroove::clear_has_stuff_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestFillEquipGroove::clear_stuff_loc() {
  if (stuff_loc_ != NULL) stuff_loc_->::ItemLoc::Clear();
  clear_has_stuff_loc();
}
inline const ::ItemLoc& RequestFillEquipGroove::stuff_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stuff_loc_ != NULL ? *stuff_loc_ : *default_instance().stuff_loc_;
#else
  return stuff_loc_ != NULL ? *stuff_loc_ : *default_instance_->stuff_loc_;
#endif
}
inline ::ItemLoc* RequestFillEquipGroove::mutable_stuff_loc() {
  set_has_stuff_loc();
  if (stuff_loc_ == NULL) stuff_loc_ = new ::ItemLoc;
  return stuff_loc_;
}
inline ::ItemLoc* RequestFillEquipGroove::release_stuff_loc() {
  clear_has_stuff_loc();
  ::ItemLoc* temp = stuff_loc_;
  stuff_loc_ = NULL;
  return temp;
}
inline void RequestFillEquipGroove::set_allocated_stuff_loc(::ItemLoc* stuff_loc) {
  delete stuff_loc_;
  stuff_loc_ = stuff_loc;
  if (stuff_loc) {
    set_has_stuff_loc();
  } else {
    clear_has_stuff_loc();
  }
}

// -------------------------------------------------------------------

// ResponseFillEquipGroove

// optional int32 result = 1;
inline bool ResponseFillEquipGroove::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseFillEquipGroove::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseFillEquipGroove::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseFillEquipGroove::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseFillEquipGroove::result() const {
  return result_;
}
inline void ResponseFillEquipGroove::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestRemoveEquipJewel

// optional .ItemLoc equip_loc = 1;
inline bool RequestRemoveEquipJewel::has_equip_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRemoveEquipJewel::set_has_equip_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRemoveEquipJewel::clear_has_equip_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRemoveEquipJewel::clear_equip_loc() {
  if (equip_loc_ != NULL) equip_loc_->::ItemLoc::Clear();
  clear_has_equip_loc();
}
inline const ::ItemLoc& RequestRemoveEquipJewel::equip_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance().equip_loc_;
#else
  return equip_loc_ != NULL ? *equip_loc_ : *default_instance_->equip_loc_;
#endif
}
inline ::ItemLoc* RequestRemoveEquipJewel::mutable_equip_loc() {
  set_has_equip_loc();
  if (equip_loc_ == NULL) equip_loc_ = new ::ItemLoc;
  return equip_loc_;
}
inline ::ItemLoc* RequestRemoveEquipJewel::release_equip_loc() {
  clear_has_equip_loc();
  ::ItemLoc* temp = equip_loc_;
  equip_loc_ = NULL;
  return temp;
}
inline void RequestRemoveEquipJewel::set_allocated_equip_loc(::ItemLoc* equip_loc) {
  delete equip_loc_;
  equip_loc_ = equip_loc;
  if (equip_loc) {
    set_has_equip_loc();
  } else {
    clear_has_equip_loc();
  }
}

// optional int32 index = 2;
inline bool RequestRemoveEquipJewel::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRemoveEquipJewel::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRemoveEquipJewel::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRemoveEquipJewel::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 RequestRemoveEquipJewel::index() const {
  return index_;
}
inline void RequestRemoveEquipJewel::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional bool destroy = 3;
inline bool RequestRemoveEquipJewel::has_destroy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRemoveEquipJewel::set_has_destroy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRemoveEquipJewel::clear_has_destroy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRemoveEquipJewel::clear_destroy() {
  destroy_ = false;
  clear_has_destroy();
}
inline bool RequestRemoveEquipJewel::destroy() const {
  return destroy_;
}
inline void RequestRemoveEquipJewel::set_destroy(bool value) {
  set_has_destroy();
  destroy_ = value;
}

// -------------------------------------------------------------------

// ResponseRemoveEquipJewel

// optional int32 result = 1;
inline bool ResponseRemoveEquipJewel::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRemoveEquipJewel::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRemoveEquipJewel::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRemoveEquipJewel::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseRemoveEquipJewel::result() const {
  return result_;
}
inline void ResponseRemoveEquipJewel::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestUpgradeJewel

// optional .ItemLoc loc = 1;
inline bool RequestUpgradeJewel::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpgradeJewel::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpgradeJewel::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpgradeJewel::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& RequestUpgradeJewel::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* RequestUpgradeJewel::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* RequestUpgradeJewel::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void RequestUpgradeJewel::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// -------------------------------------------------------------------

// ResponseUpgradeJewel

// optional int32 result = 1;
inline bool ResponseUpgradeJewel::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUpgradeJewel::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUpgradeJewel::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUpgradeJewel::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseUpgradeJewel::result() const {
  return result_;
}
inline void ResponseUpgradeJewel::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoEquipUpgrade_2eproto__INCLUDED
