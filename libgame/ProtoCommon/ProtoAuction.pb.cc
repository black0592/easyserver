// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoAuction.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoAuction.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace Protocol {

void protobuf_ShutdownFile_ProtoAuction_2eproto() {
  delete AuctionMoneyInfo::default_instance_;
  delete AuctionItemInfo::default_instance_;
  delete RequestAuctionGetMoneyList::default_instance_;
  delete ResponseAuctionGetMoneyList::default_instance_;
  delete RequestAuctionSellMoney::default_instance_;
  delete ResponseAuctionSellMoney::default_instance_;
  delete RequestAuctionBuyMoney::default_instance_;
  delete ResponseAuctionBuyMoney::default_instance_;
  delete RequestAuctionBackoutMoney::default_instance_;
  delete ResponseAuctionBackoutMoney::default_instance_;
  delete RequestAuctionGetSelfMoneyList::default_instance_;
  delete ResponseAuctionGetSelfMoneyList::default_instance_;
  delete RequestAuctionGetItemList::default_instance_;
  delete ResponseAuctionGetItemList::default_instance_;
  delete RequestAuctionSellItem::default_instance_;
  delete ResponseAuctionSellItem::default_instance_;
  delete RequestAuctionGetItemDetail::default_instance_;
  delete ResponseAuctionGetItemDetail::default_instance_;
  delete RequestAuctionBuyItem::default_instance_;
  delete ResponseAuctionBuyItem::default_instance_;
  delete RequestAuctionBackoutItem::default_instance_;
  delete ResponseAuctionBackoutItem::default_instance_;
  delete RequestAuctionGetSelfItemList::default_instance_;
  delete ResponseAuctionGetSelfItemList::default_instance_;
  delete NotifyAuctionUpdateParam::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoAuction_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoAuction_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoGameData_2eproto();
  AuctionMoneyInfo::default_instance_ = new AuctionMoneyInfo();
  AuctionItemInfo::default_instance_ = new AuctionItemInfo();
  RequestAuctionGetMoneyList::default_instance_ = new RequestAuctionGetMoneyList();
  ResponseAuctionGetMoneyList::default_instance_ = new ResponseAuctionGetMoneyList();
  RequestAuctionSellMoney::default_instance_ = new RequestAuctionSellMoney();
  ResponseAuctionSellMoney::default_instance_ = new ResponseAuctionSellMoney();
  RequestAuctionBuyMoney::default_instance_ = new RequestAuctionBuyMoney();
  ResponseAuctionBuyMoney::default_instance_ = new ResponseAuctionBuyMoney();
  RequestAuctionBackoutMoney::default_instance_ = new RequestAuctionBackoutMoney();
  ResponseAuctionBackoutMoney::default_instance_ = new ResponseAuctionBackoutMoney();
  RequestAuctionGetSelfMoneyList::default_instance_ = new RequestAuctionGetSelfMoneyList();
  ResponseAuctionGetSelfMoneyList::default_instance_ = new ResponseAuctionGetSelfMoneyList();
  RequestAuctionGetItemList::default_instance_ = new RequestAuctionGetItemList();
  ResponseAuctionGetItemList::default_instance_ = new ResponseAuctionGetItemList();
  RequestAuctionSellItem::default_instance_ = new RequestAuctionSellItem();
  ResponseAuctionSellItem::default_instance_ = new ResponseAuctionSellItem();
  RequestAuctionGetItemDetail::default_instance_ = new RequestAuctionGetItemDetail();
  ResponseAuctionGetItemDetail::default_instance_ = new ResponseAuctionGetItemDetail();
  RequestAuctionBuyItem::default_instance_ = new RequestAuctionBuyItem();
  ResponseAuctionBuyItem::default_instance_ = new ResponseAuctionBuyItem();
  RequestAuctionBackoutItem::default_instance_ = new RequestAuctionBackoutItem();
  ResponseAuctionBackoutItem::default_instance_ = new ResponseAuctionBackoutItem();
  RequestAuctionGetSelfItemList::default_instance_ = new RequestAuctionGetSelfItemList();
  ResponseAuctionGetSelfItemList::default_instance_ = new ResponseAuctionGetSelfItemList();
  NotifyAuctionUpdateParam::default_instance_ = new NotifyAuctionUpdateParam();
  AuctionMoneyInfo::default_instance_->InitAsDefaultInstance();
  AuctionItemInfo::default_instance_->InitAsDefaultInstance();
  RequestAuctionGetMoneyList::default_instance_->InitAsDefaultInstance();
  ResponseAuctionGetMoneyList::default_instance_->InitAsDefaultInstance();
  RequestAuctionSellMoney::default_instance_->InitAsDefaultInstance();
  ResponseAuctionSellMoney::default_instance_->InitAsDefaultInstance();
  RequestAuctionBuyMoney::default_instance_->InitAsDefaultInstance();
  ResponseAuctionBuyMoney::default_instance_->InitAsDefaultInstance();
  RequestAuctionBackoutMoney::default_instance_->InitAsDefaultInstance();
  ResponseAuctionBackoutMoney::default_instance_->InitAsDefaultInstance();
  RequestAuctionGetSelfMoneyList::default_instance_->InitAsDefaultInstance();
  ResponseAuctionGetSelfMoneyList::default_instance_->InitAsDefaultInstance();
  RequestAuctionGetItemList::default_instance_->InitAsDefaultInstance();
  ResponseAuctionGetItemList::default_instance_->InitAsDefaultInstance();
  RequestAuctionSellItem::default_instance_->InitAsDefaultInstance();
  ResponseAuctionSellItem::default_instance_->InitAsDefaultInstance();
  RequestAuctionGetItemDetail::default_instance_->InitAsDefaultInstance();
  ResponseAuctionGetItemDetail::default_instance_->InitAsDefaultInstance();
  RequestAuctionBuyItem::default_instance_->InitAsDefaultInstance();
  ResponseAuctionBuyItem::default_instance_->InitAsDefaultInstance();
  RequestAuctionBackoutItem::default_instance_->InitAsDefaultInstance();
  ResponseAuctionBackoutItem::default_instance_->InitAsDefaultInstance();
  RequestAuctionGetSelfItemList::default_instance_->InitAsDefaultInstance();
  ResponseAuctionGetSelfItemList::default_instance_->InitAsDefaultInstance();
  NotifyAuctionUpdateParam::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoAuction_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoAuction_2eproto_once_);
void protobuf_AddDesc_ProtoAuction_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoAuction_2eproto_once_,
                 &protobuf_AddDesc_ProtoAuction_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoAuction_2eproto {
  StaticDescriptorInitializer_ProtoAuction_2eproto() {
    protobuf_AddDesc_ProtoAuction_2eproto();
  }
} static_descriptor_initializer_ProtoAuction_2eproto_;
#endif
bool AuctionOpCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

bool AuctionSort_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int AuctionMoneyInfo::kAuctionIdFieldNumber;
const int AuctionMoneyInfo::kRequireGoldFieldNumber;
const int AuctionMoneyInfo::kTotalMoneyFieldNumber;
const int AuctionMoneyInfo::kUnitMoneyFieldNumber;
const int AuctionMoneyInfo::kTimeFieldNumber;
#endif  // !_MSC_VER

AuctionMoneyInfo::AuctionMoneyInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AuctionMoneyInfo::InitAsDefaultInstance() {
}

AuctionMoneyInfo::AuctionMoneyInfo(const AuctionMoneyInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AuctionMoneyInfo::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  require_gold_ = 0;
  total_money_ = 0;
  unit_money_ = 0;
  time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuctionMoneyInfo::~AuctionMoneyInfo() {
  SharedDtor();
}

void AuctionMoneyInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AuctionMoneyInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AuctionMoneyInfo& AuctionMoneyInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

AuctionMoneyInfo* AuctionMoneyInfo::default_instance_ = NULL;

AuctionMoneyInfo* AuctionMoneyInfo::New() const {
  return new AuctionMoneyInfo;
}

void AuctionMoneyInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
    require_gold_ = 0;
    total_money_ = 0;
    unit_money_ = 0;
    time_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AuctionMoneyInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_require_gold;
        break;
      }

      // optional int32 require_gold = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_require_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &require_gold_)));
          set_has_require_gold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_total_money;
        break;
      }

      // optional int32 total_money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_total_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &total_money_)));
          set_has_total_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_unit_money;
        break;
      }

      // optional int32 unit_money = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_unit_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &unit_money_)));
          set_has_unit_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_time;
        break;
      }

      // optional int32 time = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuctionMoneyInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 1;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->auction_id(), output);
  }

  // optional int32 require_gold = 2;
  if (has_require_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->require_gold(), output);
  }

  // optional int32 total_money = 3;
  if (has_total_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->total_money(), output);
  }

  // optional int32 unit_money = 4;
  if (has_unit_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->unit_money(), output);
  }

  // optional int32 time = 5;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->time(), output);
  }

}

int AuctionMoneyInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 1;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

    // optional int32 require_gold = 2;
    if (has_require_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->require_gold());
    }

    // optional int32 total_money = 3;
    if (has_total_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->total_money());
    }

    // optional int32 unit_money = 4;
    if (has_unit_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->unit_money());
    }

    // optional int32 time = 5;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuctionMoneyInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AuctionMoneyInfo*>(&from));
}

void AuctionMoneyInfo::MergeFrom(const AuctionMoneyInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
    if (from.has_require_gold()) {
      set_require_gold(from.require_gold());
    }
    if (from.has_total_money()) {
      set_total_money(from.total_money());
    }
    if (from.has_unit_money()) {
      set_unit_money(from.unit_money());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void AuctionMoneyInfo::CopyFrom(const AuctionMoneyInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuctionMoneyInfo::IsInitialized() const {

  return true;
}

void AuctionMoneyInfo::Swap(AuctionMoneyInfo* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(require_gold_, other->require_gold_);
    std::swap(total_money_, other->total_money_);
    std::swap(unit_money_, other->unit_money_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AuctionMoneyInfo::GetTypeName() const {
  return "Protocol.AuctionMoneyInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int AuctionItemInfo::kAuctionIdFieldNumber;
const int AuctionItemInfo::kRequireMoneyFieldNumber;
const int AuctionItemInfo::kItemIdFieldNumber;
const int AuctionItemInfo::kItemLevelFieldNumber;
const int AuctionItemInfo::kItemOverlayFieldNumber;
const int AuctionItemInfo::kItemStarFieldNumber;
const int AuctionItemInfo::kTimeFieldNumber;
#endif  // !_MSC_VER

AuctionItemInfo::AuctionItemInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void AuctionItemInfo::InitAsDefaultInstance() {
}

AuctionItemInfo::AuctionItemInfo(const AuctionItemInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void AuctionItemInfo::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  require_money_ = 0;
  item_id_ = 0;
  item_level_ = 0;
  item_overlay_ = 0;
  item_star_ = 0;
  time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AuctionItemInfo::~AuctionItemInfo() {
  SharedDtor();
}

void AuctionItemInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AuctionItemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AuctionItemInfo& AuctionItemInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

AuctionItemInfo* AuctionItemInfo::default_instance_ = NULL;

AuctionItemInfo* AuctionItemInfo::New() const {
  return new AuctionItemInfo;
}

void AuctionItemInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
    require_money_ = 0;
    item_id_ = 0;
    item_level_ = 0;
    item_overlay_ = 0;
    item_star_ = 0;
    time_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool AuctionItemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_require_money;
        break;
      }

      // optional int32 require_money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_require_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &require_money_)));
          set_has_require_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_item_id;
        break;
      }

      // optional int32 item_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_id_)));
          set_has_item_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_item_level;
        break;
      }

      // optional int32 item_level = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_level_)));
          set_has_item_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_item_overlay;
        break;
      }

      // optional int32 item_overlay = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_overlay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_overlay_)));
          set_has_item_overlay();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_item_star;
        break;
      }

      // optional int32 item_star = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_item_star:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &item_star_)));
          set_has_item_star();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_time;
        break;
      }

      // optional int32 time = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AuctionItemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 1;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->auction_id(), output);
  }

  // optional int32 require_money = 2;
  if (has_require_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->require_money(), output);
  }

  // optional int32 item_id = 3;
  if (has_item_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->item_id(), output);
  }

  // optional int32 item_level = 4;
  if (has_item_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->item_level(), output);
  }

  // optional int32 item_overlay = 5;
  if (has_item_overlay()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->item_overlay(), output);
  }

  // optional int32 item_star = 6;
  if (has_item_star()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->item_star(), output);
  }

  // optional int32 time = 7;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->time(), output);
  }

}

int AuctionItemInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 1;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

    // optional int32 require_money = 2;
    if (has_require_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->require_money());
    }

    // optional int32 item_id = 3;
    if (has_item_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_id());
    }

    // optional int32 item_level = 4;
    if (has_item_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_level());
    }

    // optional int32 item_overlay = 5;
    if (has_item_overlay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_overlay());
    }

    // optional int32 item_star = 6;
    if (has_item_star()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->item_star());
    }

    // optional int32 time = 7;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AuctionItemInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AuctionItemInfo*>(&from));
}

void AuctionItemInfo::MergeFrom(const AuctionItemInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
    if (from.has_require_money()) {
      set_require_money(from.require_money());
    }
    if (from.has_item_id()) {
      set_item_id(from.item_id());
    }
    if (from.has_item_level()) {
      set_item_level(from.item_level());
    }
    if (from.has_item_overlay()) {
      set_item_overlay(from.item_overlay());
    }
    if (from.has_item_star()) {
      set_item_star(from.item_star());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
  }
}

void AuctionItemInfo::CopyFrom(const AuctionItemInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AuctionItemInfo::IsInitialized() const {

  return true;
}

void AuctionItemInfo::Swap(AuctionItemInfo* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(require_money_, other->require_money_);
    std::swap(item_id_, other->item_id_);
    std::swap(item_level_, other->item_level_);
    std::swap(item_overlay_, other->item_overlay_);
    std::swap(item_star_, other->item_star_);
    std::swap(time_, other->time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string AuctionItemInfo::GetTypeName() const {
  return "Protocol.AuctionItemInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionGetMoneyList::kPageFieldNumber;
const int RequestAuctionGetMoneyList::kSortTotalMoneyFieldNumber;
const int RequestAuctionGetMoneyList::kSortUnitMoneyFieldNumber;
const int RequestAuctionGetMoneyList::kSortRequireGoldFieldNumber;
const int RequestAuctionGetMoneyList::kFilterMoneyMinFieldNumber;
const int RequestAuctionGetMoneyList::kFilterMoneyMaxFieldNumber;
#endif  // !_MSC_VER

RequestAuctionGetMoneyList::RequestAuctionGetMoneyList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionGetMoneyList::InitAsDefaultInstance() {
}

RequestAuctionGetMoneyList::RequestAuctionGetMoneyList(const RequestAuctionGetMoneyList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionGetMoneyList::SharedCtor() {
  _cached_size_ = 0;
  page_ = 1;
  sort_total_money_ = 0;
  sort_unit_money_ = 0;
  sort_require_gold_ = 0;
  filter_money_min_ = 0;
  filter_money_max_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionGetMoneyList::~RequestAuctionGetMoneyList() {
  SharedDtor();
}

void RequestAuctionGetMoneyList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionGetMoneyList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionGetMoneyList& RequestAuctionGetMoneyList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionGetMoneyList* RequestAuctionGetMoneyList::default_instance_ = NULL;

RequestAuctionGetMoneyList* RequestAuctionGetMoneyList::New() const {
  return new RequestAuctionGetMoneyList;
}

void RequestAuctionGetMoneyList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 1;
    sort_total_money_ = 0;
    sort_unit_money_ = 0;
    sort_require_gold_ = 0;
    filter_money_min_ = 0;
    filter_money_max_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionGetMoneyList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 page = 1 [default = 1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sort_total_money;
        break;
      }

      // optional .Protocol.AuctionSort sort_total_money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sort_total_money:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::AuctionSort_IsValid(value)) {
            set_sort_total_money(static_cast< ::Protocol::AuctionSort >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sort_unit_money;
        break;
      }

      // optional .Protocol.AuctionSort sort_unit_money = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sort_unit_money:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::AuctionSort_IsValid(value)) {
            set_sort_unit_money(static_cast< ::Protocol::AuctionSort >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sort_require_gold;
        break;
      }

      // optional .Protocol.AuctionSort sort_require_gold = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sort_require_gold:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::AuctionSort_IsValid(value)) {
            set_sort_require_gold(static_cast< ::Protocol::AuctionSort >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_filter_money_min;
        break;
      }

      // optional int32 filter_money_min = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_money_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &filter_money_min_)));
          set_has_filter_money_min();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_filter_money_max;
        break;
      }

      // optional int32 filter_money_max = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_money_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &filter_money_max_)));
          set_has_filter_money_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionGetMoneyList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 page = 1 [default = 1];
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  // optional .Protocol.AuctionSort sort_total_money = 2;
  if (has_sort_total_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->sort_total_money(), output);
  }

  // optional .Protocol.AuctionSort sort_unit_money = 3;
  if (has_sort_unit_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->sort_unit_money(), output);
  }

  // optional .Protocol.AuctionSort sort_require_gold = 4;
  if (has_sort_require_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->sort_require_gold(), output);
  }

  // optional int32 filter_money_min = 5;
  if (has_filter_money_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->filter_money_min(), output);
  }

  // optional int32 filter_money_max = 6;
  if (has_filter_money_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->filter_money_max(), output);
  }

}

int RequestAuctionGetMoneyList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 page = 1 [default = 1];
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

    // optional .Protocol.AuctionSort sort_total_money = 2;
    if (has_sort_total_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sort_total_money());
    }

    // optional .Protocol.AuctionSort sort_unit_money = 3;
    if (has_sort_unit_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sort_unit_money());
    }

    // optional .Protocol.AuctionSort sort_require_gold = 4;
    if (has_sort_require_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sort_require_gold());
    }

    // optional int32 filter_money_min = 5;
    if (has_filter_money_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->filter_money_min());
    }

    // optional int32 filter_money_max = 6;
    if (has_filter_money_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->filter_money_max());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionGetMoneyList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionGetMoneyList*>(&from));
}

void RequestAuctionGetMoneyList::MergeFrom(const RequestAuctionGetMoneyList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_sort_total_money()) {
      set_sort_total_money(from.sort_total_money());
    }
    if (from.has_sort_unit_money()) {
      set_sort_unit_money(from.sort_unit_money());
    }
    if (from.has_sort_require_gold()) {
      set_sort_require_gold(from.sort_require_gold());
    }
    if (from.has_filter_money_min()) {
      set_filter_money_min(from.filter_money_min());
    }
    if (from.has_filter_money_max()) {
      set_filter_money_max(from.filter_money_max());
    }
  }
}

void RequestAuctionGetMoneyList::CopyFrom(const RequestAuctionGetMoneyList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionGetMoneyList::IsInitialized() const {

  return true;
}

void RequestAuctionGetMoneyList::Swap(RequestAuctionGetMoneyList* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(sort_total_money_, other->sort_total_money_);
    std::swap(sort_unit_money_, other->sort_unit_money_);
    std::swap(sort_require_gold_, other->sort_require_gold_);
    std::swap(filter_money_min_, other->filter_money_min_);
    std::swap(filter_money_max_, other->filter_money_max_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionGetMoneyList::GetTypeName() const {
  return "Protocol.RequestAuctionGetMoneyList";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionGetMoneyList::kPageFieldNumber;
const int ResponseAuctionGetMoneyList::kMaxPageFieldNumber;
const int ResponseAuctionGetMoneyList::kAuctionListFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionGetMoneyList::ResponseAuctionGetMoneyList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionGetMoneyList::InitAsDefaultInstance() {
}

ResponseAuctionGetMoneyList::ResponseAuctionGetMoneyList(const ResponseAuctionGetMoneyList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionGetMoneyList::SharedCtor() {
  _cached_size_ = 0;
  page_ = 0;
  max_page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionGetMoneyList::~ResponseAuctionGetMoneyList() {
  SharedDtor();
}

void ResponseAuctionGetMoneyList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionGetMoneyList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionGetMoneyList& ResponseAuctionGetMoneyList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionGetMoneyList* ResponseAuctionGetMoneyList::default_instance_ = NULL;

ResponseAuctionGetMoneyList* ResponseAuctionGetMoneyList::New() const {
  return new ResponseAuctionGetMoneyList;
}

void ResponseAuctionGetMoneyList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 0;
    max_page_ = 0;
  }
  auction_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionGetMoneyList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 page = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_max_page;
        break;
      }

      // optional int32 max_page = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_page_)));
          set_has_max_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_auction_list;
        break;
      }

      // repeated .Protocol.AuctionMoneyInfo auction_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auction_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_auction_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_auction_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionGetMoneyList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  // optional int32 max_page = 2;
  if (has_max_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_page(), output);
  }

  // repeated .Protocol.AuctionMoneyInfo auction_list = 3;
  for (int i = 0; i < this->auction_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->auction_list(i), output);
  }

}

int ResponseAuctionGetMoneyList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

    // optional int32 max_page = 2;
    if (has_max_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_page());
    }

  }
  // repeated .Protocol.AuctionMoneyInfo auction_list = 3;
  total_size += 1 * this->auction_list_size();
  for (int i = 0; i < this->auction_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->auction_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionGetMoneyList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionGetMoneyList*>(&from));
}

void ResponseAuctionGetMoneyList::MergeFrom(const ResponseAuctionGetMoneyList& from) {
  GOOGLE_CHECK_NE(&from, this);
  auction_list_.MergeFrom(from.auction_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_max_page()) {
      set_max_page(from.max_page());
    }
  }
}

void ResponseAuctionGetMoneyList::CopyFrom(const ResponseAuctionGetMoneyList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionGetMoneyList::IsInitialized() const {

  return true;
}

void ResponseAuctionGetMoneyList::Swap(ResponseAuctionGetMoneyList* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(max_page_, other->max_page_);
    auction_list_.Swap(&other->auction_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionGetMoneyList::GetTypeName() const {
  return "Protocol.ResponseAuctionGetMoneyList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionSellMoney::kMoneyFieldNumber;
const int RequestAuctionSellMoney::kRequireGoldFieldNumber;
#endif  // !_MSC_VER

RequestAuctionSellMoney::RequestAuctionSellMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionSellMoney::InitAsDefaultInstance() {
}

RequestAuctionSellMoney::RequestAuctionSellMoney(const RequestAuctionSellMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionSellMoney::SharedCtor() {
  _cached_size_ = 0;
  money_ = 0;
  require_gold_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionSellMoney::~RequestAuctionSellMoney() {
  SharedDtor();
}

void RequestAuctionSellMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionSellMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionSellMoney& RequestAuctionSellMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionSellMoney* RequestAuctionSellMoney::default_instance_ = NULL;

RequestAuctionSellMoney* RequestAuctionSellMoney::New() const {
  return new RequestAuctionSellMoney;
}

void RequestAuctionSellMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    money_ = 0;
    require_gold_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionSellMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 money = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_require_gold;
        break;
      }

      // optional int32 require_gold = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_require_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &require_gold_)));
          set_has_require_gold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionSellMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 money = 1;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->money(), output);
  }

  // optional int32 require_gold = 2;
  if (has_require_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->require_gold(), output);
  }

}

int RequestAuctionSellMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 money = 1;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 require_gold = 2;
    if (has_require_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->require_gold());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionSellMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionSellMoney*>(&from));
}

void RequestAuctionSellMoney::MergeFrom(const RequestAuctionSellMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_require_gold()) {
      set_require_gold(from.require_gold());
    }
  }
}

void RequestAuctionSellMoney::CopyFrom(const RequestAuctionSellMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionSellMoney::IsInitialized() const {

  return true;
}

void RequestAuctionSellMoney::Swap(RequestAuctionSellMoney* other) {
  if (other != this) {
    std::swap(money_, other->money_);
    std::swap(require_gold_, other->require_gold_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionSellMoney::GetTypeName() const {
  return "Protocol.RequestAuctionSellMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionSellMoney::kResultFieldNumber;
const int ResponseAuctionSellMoney::kInfoFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionSellMoney::ResponseAuctionSellMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionSellMoney::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::Protocol::AuctionMoneyInfo*>(
      ::Protocol::AuctionMoneyInfo::internal_default_instance());
#else
  info_ = const_cast< ::Protocol::AuctionMoneyInfo*>(&::Protocol::AuctionMoneyInfo::default_instance());
#endif
}

ResponseAuctionSellMoney::ResponseAuctionSellMoney(const ResponseAuctionSellMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionSellMoney::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionSellMoney::~ResponseAuctionSellMoney() {
  SharedDtor();
}

void ResponseAuctionSellMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
  }
}

void ResponseAuctionSellMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionSellMoney& ResponseAuctionSellMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionSellMoney* ResponseAuctionSellMoney::default_instance_ = NULL;

ResponseAuctionSellMoney* ResponseAuctionSellMoney::New() const {
  return new ResponseAuctionSellMoney;
}

void ResponseAuctionSellMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_info()) {
      if (info_ != NULL) info_->::Protocol::AuctionMoneyInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionSellMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // optional .Protocol.AuctionMoneyInfo info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionSellMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .Protocol.AuctionMoneyInfo info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->info(), output);
  }

}

int ResponseAuctionSellMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .Protocol.AuctionMoneyInfo info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionSellMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionSellMoney*>(&from));
}

void ResponseAuctionSellMoney::MergeFrom(const ResponseAuctionSellMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_info()) {
      mutable_info()->::Protocol::AuctionMoneyInfo::MergeFrom(from.info());
    }
  }
}

void ResponseAuctionSellMoney::CopyFrom(const ResponseAuctionSellMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionSellMoney::IsInitialized() const {

  return true;
}

void ResponseAuctionSellMoney::Swap(ResponseAuctionSellMoney* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionSellMoney::GetTypeName() const {
  return "Protocol.ResponseAuctionSellMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionBuyMoney::kAuctionIdFieldNumber;
#endif  // !_MSC_VER

RequestAuctionBuyMoney::RequestAuctionBuyMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionBuyMoney::InitAsDefaultInstance() {
}

RequestAuctionBuyMoney::RequestAuctionBuyMoney(const RequestAuctionBuyMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionBuyMoney::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionBuyMoney::~RequestAuctionBuyMoney() {
  SharedDtor();
}

void RequestAuctionBuyMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionBuyMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionBuyMoney& RequestAuctionBuyMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionBuyMoney* RequestAuctionBuyMoney::default_instance_ = NULL;

RequestAuctionBuyMoney* RequestAuctionBuyMoney::New() const {
  return new RequestAuctionBuyMoney;
}

void RequestAuctionBuyMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionBuyMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionBuyMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 1;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->auction_id(), output);
  }

}

int RequestAuctionBuyMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 1;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionBuyMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionBuyMoney*>(&from));
}

void RequestAuctionBuyMoney::MergeFrom(const RequestAuctionBuyMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
  }
}

void RequestAuctionBuyMoney::CopyFrom(const RequestAuctionBuyMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionBuyMoney::IsInitialized() const {

  return true;
}

void RequestAuctionBuyMoney::Swap(RequestAuctionBuyMoney* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionBuyMoney::GetTypeName() const {
  return "Protocol.RequestAuctionBuyMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionBuyMoney::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionBuyMoney::ResponseAuctionBuyMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionBuyMoney::InitAsDefaultInstance() {
}

ResponseAuctionBuyMoney::ResponseAuctionBuyMoney(const ResponseAuctionBuyMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionBuyMoney::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionBuyMoney::~ResponseAuctionBuyMoney() {
  SharedDtor();
}

void ResponseAuctionBuyMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionBuyMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionBuyMoney& ResponseAuctionBuyMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionBuyMoney* ResponseAuctionBuyMoney::default_instance_ = NULL;

ResponseAuctionBuyMoney* ResponseAuctionBuyMoney::New() const {
  return new ResponseAuctionBuyMoney;
}

void ResponseAuctionBuyMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionBuyMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionBuyMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseAuctionBuyMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionBuyMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionBuyMoney*>(&from));
}

void ResponseAuctionBuyMoney::MergeFrom(const ResponseAuctionBuyMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseAuctionBuyMoney::CopyFrom(const ResponseAuctionBuyMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionBuyMoney::IsInitialized() const {

  return true;
}

void ResponseAuctionBuyMoney::Swap(ResponseAuctionBuyMoney* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionBuyMoney::GetTypeName() const {
  return "Protocol.ResponseAuctionBuyMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionBackoutMoney::kAuctionIdFieldNumber;
#endif  // !_MSC_VER

RequestAuctionBackoutMoney::RequestAuctionBackoutMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionBackoutMoney::InitAsDefaultInstance() {
}

RequestAuctionBackoutMoney::RequestAuctionBackoutMoney(const RequestAuctionBackoutMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionBackoutMoney::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionBackoutMoney::~RequestAuctionBackoutMoney() {
  SharedDtor();
}

void RequestAuctionBackoutMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionBackoutMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionBackoutMoney& RequestAuctionBackoutMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionBackoutMoney* RequestAuctionBackoutMoney::default_instance_ = NULL;

RequestAuctionBackoutMoney* RequestAuctionBackoutMoney::New() const {
  return new RequestAuctionBackoutMoney;
}

void RequestAuctionBackoutMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionBackoutMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionBackoutMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 1;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->auction_id(), output);
  }

}

int RequestAuctionBackoutMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 1;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionBackoutMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionBackoutMoney*>(&from));
}

void RequestAuctionBackoutMoney::MergeFrom(const RequestAuctionBackoutMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
  }
}

void RequestAuctionBackoutMoney::CopyFrom(const RequestAuctionBackoutMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionBackoutMoney::IsInitialized() const {

  return true;
}

void RequestAuctionBackoutMoney::Swap(RequestAuctionBackoutMoney* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionBackoutMoney::GetTypeName() const {
  return "Protocol.RequestAuctionBackoutMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionBackoutMoney::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionBackoutMoney::ResponseAuctionBackoutMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionBackoutMoney::InitAsDefaultInstance() {
}

ResponseAuctionBackoutMoney::ResponseAuctionBackoutMoney(const ResponseAuctionBackoutMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionBackoutMoney::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionBackoutMoney::~ResponseAuctionBackoutMoney() {
  SharedDtor();
}

void ResponseAuctionBackoutMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionBackoutMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionBackoutMoney& ResponseAuctionBackoutMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionBackoutMoney* ResponseAuctionBackoutMoney::default_instance_ = NULL;

ResponseAuctionBackoutMoney* ResponseAuctionBackoutMoney::New() const {
  return new ResponseAuctionBackoutMoney;
}

void ResponseAuctionBackoutMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionBackoutMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionBackoutMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseAuctionBackoutMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionBackoutMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionBackoutMoney*>(&from));
}

void ResponseAuctionBackoutMoney::MergeFrom(const ResponseAuctionBackoutMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseAuctionBackoutMoney::CopyFrom(const ResponseAuctionBackoutMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionBackoutMoney::IsInitialized() const {

  return true;
}

void ResponseAuctionBackoutMoney::Swap(ResponseAuctionBackoutMoney* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionBackoutMoney::GetTypeName() const {
  return "Protocol.ResponseAuctionBackoutMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionGetSelfMoneyList::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestAuctionGetSelfMoneyList::RequestAuctionGetSelfMoneyList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionGetSelfMoneyList::InitAsDefaultInstance() {
}

RequestAuctionGetSelfMoneyList::RequestAuctionGetSelfMoneyList(const RequestAuctionGetSelfMoneyList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionGetSelfMoneyList::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionGetSelfMoneyList::~RequestAuctionGetSelfMoneyList() {
  SharedDtor();
}

void RequestAuctionGetSelfMoneyList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionGetSelfMoneyList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionGetSelfMoneyList& RequestAuctionGetSelfMoneyList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionGetSelfMoneyList* RequestAuctionGetSelfMoneyList::default_instance_ = NULL;

RequestAuctionGetSelfMoneyList* RequestAuctionGetSelfMoneyList::New() const {
  return new RequestAuctionGetSelfMoneyList;
}

void RequestAuctionGetSelfMoneyList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionGetSelfMoneyList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionGetSelfMoneyList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestAuctionGetSelfMoneyList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionGetSelfMoneyList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionGetSelfMoneyList*>(&from));
}

void RequestAuctionGetSelfMoneyList::MergeFrom(const RequestAuctionGetSelfMoneyList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestAuctionGetSelfMoneyList::CopyFrom(const RequestAuctionGetSelfMoneyList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionGetSelfMoneyList::IsInitialized() const {

  return true;
}

void RequestAuctionGetSelfMoneyList::Swap(RequestAuctionGetSelfMoneyList* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionGetSelfMoneyList::GetTypeName() const {
  return "Protocol.RequestAuctionGetSelfMoneyList";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionGetSelfMoneyList::kAuctionListFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionGetSelfMoneyList::ResponseAuctionGetSelfMoneyList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionGetSelfMoneyList::InitAsDefaultInstance() {
}

ResponseAuctionGetSelfMoneyList::ResponseAuctionGetSelfMoneyList(const ResponseAuctionGetSelfMoneyList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionGetSelfMoneyList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionGetSelfMoneyList::~ResponseAuctionGetSelfMoneyList() {
  SharedDtor();
}

void ResponseAuctionGetSelfMoneyList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionGetSelfMoneyList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionGetSelfMoneyList& ResponseAuctionGetSelfMoneyList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionGetSelfMoneyList* ResponseAuctionGetSelfMoneyList::default_instance_ = NULL;

ResponseAuctionGetSelfMoneyList* ResponseAuctionGetSelfMoneyList::New() const {
  return new ResponseAuctionGetSelfMoneyList;
}

void ResponseAuctionGetSelfMoneyList::Clear() {
  auction_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionGetSelfMoneyList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.AuctionMoneyInfo auction_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auction_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_auction_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_auction_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionGetSelfMoneyList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.AuctionMoneyInfo auction_list = 1;
  for (int i = 0; i < this->auction_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->auction_list(i), output);
  }

}

int ResponseAuctionGetSelfMoneyList::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.AuctionMoneyInfo auction_list = 1;
  total_size += 1 * this->auction_list_size();
  for (int i = 0; i < this->auction_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->auction_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionGetSelfMoneyList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionGetSelfMoneyList*>(&from));
}

void ResponseAuctionGetSelfMoneyList::MergeFrom(const ResponseAuctionGetSelfMoneyList& from) {
  GOOGLE_CHECK_NE(&from, this);
  auction_list_.MergeFrom(from.auction_list_);
}

void ResponseAuctionGetSelfMoneyList::CopyFrom(const ResponseAuctionGetSelfMoneyList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionGetSelfMoneyList::IsInitialized() const {

  return true;
}

void ResponseAuctionGetSelfMoneyList::Swap(ResponseAuctionGetSelfMoneyList* other) {
  if (other != this) {
    auction_list_.Swap(&other->auction_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionGetSelfMoneyList::GetTypeName() const {
  return "Protocol.ResponseAuctionGetSelfMoneyList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionGetItemList::kPageFieldNumber;
const int RequestAuctionGetItemList::kSortQualityFieldNumber;
const int RequestAuctionGetItemList::kSortLevelFieldNumber;
const int RequestAuctionGetItemList::kSortOverlayFieldNumber;
const int RequestAuctionGetItemList::kSortRequireMoneyFieldNumber;
const int RequestAuctionGetItemList::kFilterItemMainTypeFieldNumber;
const int RequestAuctionGetItemList::kFilterItemSubTypeFieldNumber;
const int RequestAuctionGetItemList::kFilterItemLevelFieldNumber;
const int RequestAuctionGetItemList::kFilterItemNameFieldNumber;
#endif  // !_MSC_VER

RequestAuctionGetItemList::RequestAuctionGetItemList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionGetItemList::InitAsDefaultInstance() {
}

RequestAuctionGetItemList::RequestAuctionGetItemList(const RequestAuctionGetItemList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionGetItemList::SharedCtor() {
  _cached_size_ = 0;
  page_ = 1;
  sort_quality_ = 0;
  sort_level_ = 0;
  sort_overlay_ = 0;
  sort_require_money_ = 0;
  filter_item_main_type_ = 0;
  filter_item_sub_type_ = 0;
  filter_item_level_ = 0;
  filter_item_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionGetItemList::~RequestAuctionGetItemList() {
  SharedDtor();
}

void RequestAuctionGetItemList::SharedDtor() {
  if (filter_item_name_ != &::google::protobuf::internal::kEmptyString) {
    delete filter_item_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionGetItemList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionGetItemList& RequestAuctionGetItemList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionGetItemList* RequestAuctionGetItemList::default_instance_ = NULL;

RequestAuctionGetItemList* RequestAuctionGetItemList::New() const {
  return new RequestAuctionGetItemList;
}

void RequestAuctionGetItemList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 1;
    sort_quality_ = 0;
    sort_level_ = 0;
    sort_overlay_ = 0;
    sort_require_money_ = 0;
    filter_item_main_type_ = 0;
    filter_item_sub_type_ = 0;
    filter_item_level_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_filter_item_name()) {
      if (filter_item_name_ != &::google::protobuf::internal::kEmptyString) {
        filter_item_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionGetItemList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 page = 1 [default = 1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sort_quality;
        break;
      }

      // optional .Protocol.AuctionSort sort_quality = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sort_quality:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::AuctionSort_IsValid(value)) {
            set_sort_quality(static_cast< ::Protocol::AuctionSort >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sort_level;
        break;
      }

      // optional .Protocol.AuctionSort sort_level = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sort_level:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::AuctionSort_IsValid(value)) {
            set_sort_level(static_cast< ::Protocol::AuctionSort >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sort_overlay;
        break;
      }

      // optional .Protocol.AuctionSort sort_overlay = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sort_overlay:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::AuctionSort_IsValid(value)) {
            set_sort_overlay(static_cast< ::Protocol::AuctionSort >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_sort_require_money;
        break;
      }

      // optional .Protocol.AuctionSort sort_require_money = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sort_require_money:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::AuctionSort_IsValid(value)) {
            set_sort_require_money(static_cast< ::Protocol::AuctionSort >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_filter_item_main_type;
        break;
      }

      // optional int32 filter_item_main_type = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_item_main_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &filter_item_main_type_)));
          set_has_filter_item_main_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_filter_item_sub_type;
        break;
      }

      // optional int32 filter_item_sub_type = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_item_sub_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &filter_item_sub_type_)));
          set_has_filter_item_sub_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_filter_item_level;
        break;
      }

      // optional int32 filter_item_level = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_filter_item_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &filter_item_level_)));
          set_has_filter_item_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_filter_item_name;
        break;
      }

      // optional string filter_item_name = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filter_item_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filter_item_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionGetItemList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 page = 1 [default = 1];
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  // optional .Protocol.AuctionSort sort_quality = 2;
  if (has_sort_quality()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->sort_quality(), output);
  }

  // optional .Protocol.AuctionSort sort_level = 3;
  if (has_sort_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->sort_level(), output);
  }

  // optional .Protocol.AuctionSort sort_overlay = 4;
  if (has_sort_overlay()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->sort_overlay(), output);
  }

  // optional .Protocol.AuctionSort sort_require_money = 5;
  if (has_sort_require_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->sort_require_money(), output);
  }

  // optional int32 filter_item_main_type = 6;
  if (has_filter_item_main_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->filter_item_main_type(), output);
  }

  // optional int32 filter_item_sub_type = 7;
  if (has_filter_item_sub_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->filter_item_sub_type(), output);
  }

  // optional int32 filter_item_level = 8;
  if (has_filter_item_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->filter_item_level(), output);
  }

  // optional string filter_item_name = 9;
  if (has_filter_item_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->filter_item_name(), output);
  }

}

int RequestAuctionGetItemList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 page = 1 [default = 1];
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

    // optional .Protocol.AuctionSort sort_quality = 2;
    if (has_sort_quality()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sort_quality());
    }

    // optional .Protocol.AuctionSort sort_level = 3;
    if (has_sort_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sort_level());
    }

    // optional .Protocol.AuctionSort sort_overlay = 4;
    if (has_sort_overlay()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sort_overlay());
    }

    // optional .Protocol.AuctionSort sort_require_money = 5;
    if (has_sort_require_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sort_require_money());
    }

    // optional int32 filter_item_main_type = 6;
    if (has_filter_item_main_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->filter_item_main_type());
    }

    // optional int32 filter_item_sub_type = 7;
    if (has_filter_item_sub_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->filter_item_sub_type());
    }

    // optional int32 filter_item_level = 8;
    if (has_filter_item_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->filter_item_level());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string filter_item_name = 9;
    if (has_filter_item_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filter_item_name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionGetItemList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionGetItemList*>(&from));
}

void RequestAuctionGetItemList::MergeFrom(const RequestAuctionGetItemList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_sort_quality()) {
      set_sort_quality(from.sort_quality());
    }
    if (from.has_sort_level()) {
      set_sort_level(from.sort_level());
    }
    if (from.has_sort_overlay()) {
      set_sort_overlay(from.sort_overlay());
    }
    if (from.has_sort_require_money()) {
      set_sort_require_money(from.sort_require_money());
    }
    if (from.has_filter_item_main_type()) {
      set_filter_item_main_type(from.filter_item_main_type());
    }
    if (from.has_filter_item_sub_type()) {
      set_filter_item_sub_type(from.filter_item_sub_type());
    }
    if (from.has_filter_item_level()) {
      set_filter_item_level(from.filter_item_level());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_filter_item_name()) {
      set_filter_item_name(from.filter_item_name());
    }
  }
}

void RequestAuctionGetItemList::CopyFrom(const RequestAuctionGetItemList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionGetItemList::IsInitialized() const {

  return true;
}

void RequestAuctionGetItemList::Swap(RequestAuctionGetItemList* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(sort_quality_, other->sort_quality_);
    std::swap(sort_level_, other->sort_level_);
    std::swap(sort_overlay_, other->sort_overlay_);
    std::swap(sort_require_money_, other->sort_require_money_);
    std::swap(filter_item_main_type_, other->filter_item_main_type_);
    std::swap(filter_item_sub_type_, other->filter_item_sub_type_);
    std::swap(filter_item_level_, other->filter_item_level_);
    std::swap(filter_item_name_, other->filter_item_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionGetItemList::GetTypeName() const {
  return "Protocol.RequestAuctionGetItemList";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionGetItemList::kPageFieldNumber;
const int ResponseAuctionGetItemList::kMaxPageFieldNumber;
const int ResponseAuctionGetItemList::kAuctionListFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionGetItemList::ResponseAuctionGetItemList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionGetItemList::InitAsDefaultInstance() {
}

ResponseAuctionGetItemList::ResponseAuctionGetItemList(const ResponseAuctionGetItemList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionGetItemList::SharedCtor() {
  _cached_size_ = 0;
  page_ = 0;
  max_page_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionGetItemList::~ResponseAuctionGetItemList() {
  SharedDtor();
}

void ResponseAuctionGetItemList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionGetItemList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionGetItemList& ResponseAuctionGetItemList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionGetItemList* ResponseAuctionGetItemList::default_instance_ = NULL;

ResponseAuctionGetItemList* ResponseAuctionGetItemList::New() const {
  return new ResponseAuctionGetItemList;
}

void ResponseAuctionGetItemList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    page_ = 0;
    max_page_ = 0;
  }
  auction_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionGetItemList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 page = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_max_page;
        break;
      }

      // optional int32 max_page = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_page:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_page_)));
          set_has_max_page();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_auction_list;
        break;
      }

      // repeated .Protocol.AuctionItemInfo auction_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auction_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_auction_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_auction_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionGetItemList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->page(), output);
  }

  // optional int32 max_page = 2;
  if (has_max_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max_page(), output);
  }

  // repeated .Protocol.AuctionItemInfo auction_list = 3;
  for (int i = 0; i < this->auction_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->auction_list(i), output);
  }

}

int ResponseAuctionGetItemList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->page());
    }

    // optional int32 max_page = 2;
    if (has_max_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_page());
    }

  }
  // repeated .Protocol.AuctionItemInfo auction_list = 3;
  total_size += 1 * this->auction_list_size();
  for (int i = 0; i < this->auction_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->auction_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionGetItemList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionGetItemList*>(&from));
}

void ResponseAuctionGetItemList::MergeFrom(const ResponseAuctionGetItemList& from) {
  GOOGLE_CHECK_NE(&from, this);
  auction_list_.MergeFrom(from.auction_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_max_page()) {
      set_max_page(from.max_page());
    }
  }
}

void ResponseAuctionGetItemList::CopyFrom(const ResponseAuctionGetItemList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionGetItemList::IsInitialized() const {

  return true;
}

void ResponseAuctionGetItemList::Swap(ResponseAuctionGetItemList* other) {
  if (other != this) {
    std::swap(page_, other->page_);
    std::swap(max_page_, other->max_page_);
    auction_list_.Swap(&other->auction_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionGetItemList::GetTypeName() const {
  return "Protocol.ResponseAuctionGetItemList";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionSellItem::kLocNumFieldNumber;
const int RequestAuctionSellItem::kRequireMoneyFieldNumber;
#endif  // !_MSC_VER

RequestAuctionSellItem::RequestAuctionSellItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionSellItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  loc_num_ = const_cast< ::ItemLocNum*>(
      ::ItemLocNum::internal_default_instance());
#else
  loc_num_ = const_cast< ::ItemLocNum*>(&::ItemLocNum::default_instance());
#endif
}

RequestAuctionSellItem::RequestAuctionSellItem(const RequestAuctionSellItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionSellItem::SharedCtor() {
  _cached_size_ = 0;
  loc_num_ = NULL;
  require_money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionSellItem::~RequestAuctionSellItem() {
  SharedDtor();
}

void RequestAuctionSellItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete loc_num_;
  }
}

void RequestAuctionSellItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionSellItem& RequestAuctionSellItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionSellItem* RequestAuctionSellItem::default_instance_ = NULL;

RequestAuctionSellItem* RequestAuctionSellItem::New() const {
  return new RequestAuctionSellItem;
}

void RequestAuctionSellItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_loc_num()) {
      if (loc_num_ != NULL) loc_num_->::ItemLocNum::Clear();
    }
    require_money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionSellItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ItemLocNum loc_num = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_loc_num()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_require_money;
        break;
      }

      // optional int32 require_money = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_require_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &require_money_)));
          set_has_require_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionSellItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ItemLocNum loc_num = 1;
  if (has_loc_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->loc_num(), output);
  }

  // optional int32 require_money = 2;
  if (has_require_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->require_money(), output);
  }

}

int RequestAuctionSellItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ItemLocNum loc_num = 1;
    if (has_loc_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->loc_num());
    }

    // optional int32 require_money = 2;
    if (has_require_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->require_money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionSellItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionSellItem*>(&from));
}

void RequestAuctionSellItem::MergeFrom(const RequestAuctionSellItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_loc_num()) {
      mutable_loc_num()->::ItemLocNum::MergeFrom(from.loc_num());
    }
    if (from.has_require_money()) {
      set_require_money(from.require_money());
    }
  }
}

void RequestAuctionSellItem::CopyFrom(const RequestAuctionSellItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionSellItem::IsInitialized() const {

  return true;
}

void RequestAuctionSellItem::Swap(RequestAuctionSellItem* other) {
  if (other != this) {
    std::swap(loc_num_, other->loc_num_);
    std::swap(require_money_, other->require_money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionSellItem::GetTypeName() const {
  return "Protocol.RequestAuctionSellItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionSellItem::kResultFieldNumber;
const int ResponseAuctionSellItem::kInfoFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionSellItem::ResponseAuctionSellItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionSellItem::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  info_ = const_cast< ::Protocol::AuctionItemInfo*>(
      ::Protocol::AuctionItemInfo::internal_default_instance());
#else
  info_ = const_cast< ::Protocol::AuctionItemInfo*>(&::Protocol::AuctionItemInfo::default_instance());
#endif
}

ResponseAuctionSellItem::ResponseAuctionSellItem(const ResponseAuctionSellItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionSellItem::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionSellItem::~ResponseAuctionSellItem() {
  SharedDtor();
}

void ResponseAuctionSellItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete info_;
  }
}

void ResponseAuctionSellItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionSellItem& ResponseAuctionSellItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionSellItem* ResponseAuctionSellItem::default_instance_ = NULL;

ResponseAuctionSellItem* ResponseAuctionSellItem::New() const {
  return new ResponseAuctionSellItem;
}

void ResponseAuctionSellItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
    if (has_info()) {
      if (info_ != NULL) info_->::Protocol::AuctionItemInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionSellItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // optional .Protocol.AuctionItemInfo info = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionSellItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

  // optional .Protocol.AuctionItemInfo info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->info(), output);
  }

}

int ResponseAuctionSellItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

    // optional .Protocol.AuctionItemInfo info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionSellItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionSellItem*>(&from));
}

void ResponseAuctionSellItem::MergeFrom(const ResponseAuctionSellItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_info()) {
      mutable_info()->::Protocol::AuctionItemInfo::MergeFrom(from.info());
    }
  }
}

void ResponseAuctionSellItem::CopyFrom(const ResponseAuctionSellItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionSellItem::IsInitialized() const {

  return true;
}

void ResponseAuctionSellItem::Swap(ResponseAuctionSellItem* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(info_, other->info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionSellItem::GetTypeName() const {
  return "Protocol.ResponseAuctionSellItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionGetItemDetail::kAuctionIdFieldNumber;
#endif  // !_MSC_VER

RequestAuctionGetItemDetail::RequestAuctionGetItemDetail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionGetItemDetail::InitAsDefaultInstance() {
}

RequestAuctionGetItemDetail::RequestAuctionGetItemDetail(const RequestAuctionGetItemDetail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionGetItemDetail::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionGetItemDetail::~RequestAuctionGetItemDetail() {
  SharedDtor();
}

void RequestAuctionGetItemDetail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionGetItemDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionGetItemDetail& RequestAuctionGetItemDetail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionGetItemDetail* RequestAuctionGetItemDetail::default_instance_ = NULL;

RequestAuctionGetItemDetail* RequestAuctionGetItemDetail::New() const {
  return new RequestAuctionGetItemDetail;
}

void RequestAuctionGetItemDetail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionGetItemDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionGetItemDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 2;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->auction_id(), output);
  }

}

int RequestAuctionGetItemDetail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 2;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionGetItemDetail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionGetItemDetail*>(&from));
}

void RequestAuctionGetItemDetail::MergeFrom(const RequestAuctionGetItemDetail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
  }
}

void RequestAuctionGetItemDetail::CopyFrom(const RequestAuctionGetItemDetail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionGetItemDetail::IsInitialized() const {

  return true;
}

void RequestAuctionGetItemDetail::Swap(RequestAuctionGetItemDetail* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionGetItemDetail::GetTypeName() const {
  return "Protocol.RequestAuctionGetItemDetail";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionGetItemDetail::kAuctionIdFieldNumber;
const int ResponseAuctionGetItemDetail::kItemFieldNumber;
const int ResponseAuctionGetItemDetail::kSellerFieldNumber;
const int ResponseAuctionGetItemDetail::kRequireMoneyFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionGetItemDetail::ResponseAuctionGetItemDetail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionGetItemDetail::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  item_ = const_cast< ::ItemData*>(
      ::ItemData::internal_default_instance());
#else
  item_ = const_cast< ::ItemData*>(&::ItemData::default_instance());
#endif
}

ResponseAuctionGetItemDetail::ResponseAuctionGetItemDetail(const ResponseAuctionGetItemDetail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionGetItemDetail::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  item_ = NULL;
  seller_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  require_money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionGetItemDetail::~ResponseAuctionGetItemDetail() {
  SharedDtor();
}

void ResponseAuctionGetItemDetail::SharedDtor() {
  if (seller_ != &::google::protobuf::internal::kEmptyString) {
    delete seller_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete item_;
  }
}

void ResponseAuctionGetItemDetail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionGetItemDetail& ResponseAuctionGetItemDetail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionGetItemDetail* ResponseAuctionGetItemDetail::default_instance_ = NULL;

ResponseAuctionGetItemDetail* ResponseAuctionGetItemDetail::New() const {
  return new ResponseAuctionGetItemDetail;
}

void ResponseAuctionGetItemDetail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
    if (has_item()) {
      if (item_ != NULL) item_->::ItemData::Clear();
    }
    if (has_seller()) {
      if (seller_ != &::google::protobuf::internal::kEmptyString) {
        seller_->clear();
      }
    }
    require_money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionGetItemDetail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_item;
        break;
      }

      // optional .ItemData item = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_seller;
        break;
      }

      // optional string seller = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_seller:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_seller()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_require_money;
        break;
      }

      // optional int32 require_money = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_require_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &require_money_)));
          set_has_require_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionGetItemDetail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 1;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->auction_id(), output);
  }

  // optional .ItemData item = 2;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->item(), output);
  }

  // optional string seller = 3;
  if (has_seller()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->seller(), output);
  }

  // optional int32 require_money = 4;
  if (has_require_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->require_money(), output);
  }

}

int ResponseAuctionGetItemDetail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 1;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

    // optional .ItemData item = 2;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

    // optional string seller = 3;
    if (has_seller()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->seller());
    }

    // optional int32 require_money = 4;
    if (has_require_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->require_money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionGetItemDetail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionGetItemDetail*>(&from));
}

void ResponseAuctionGetItemDetail::MergeFrom(const ResponseAuctionGetItemDetail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
    if (from.has_item()) {
      mutable_item()->::ItemData::MergeFrom(from.item());
    }
    if (from.has_seller()) {
      set_seller(from.seller());
    }
    if (from.has_require_money()) {
      set_require_money(from.require_money());
    }
  }
}

void ResponseAuctionGetItemDetail::CopyFrom(const ResponseAuctionGetItemDetail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionGetItemDetail::IsInitialized() const {

  return true;
}

void ResponseAuctionGetItemDetail::Swap(ResponseAuctionGetItemDetail* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(item_, other->item_);
    std::swap(seller_, other->seller_);
    std::swap(require_money_, other->require_money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionGetItemDetail::GetTypeName() const {
  return "Protocol.ResponseAuctionGetItemDetail";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionBuyItem::kAuctionIdFieldNumber;
#endif  // !_MSC_VER

RequestAuctionBuyItem::RequestAuctionBuyItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionBuyItem::InitAsDefaultInstance() {
}

RequestAuctionBuyItem::RequestAuctionBuyItem(const RequestAuctionBuyItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionBuyItem::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionBuyItem::~RequestAuctionBuyItem() {
  SharedDtor();
}

void RequestAuctionBuyItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionBuyItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionBuyItem& RequestAuctionBuyItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionBuyItem* RequestAuctionBuyItem::default_instance_ = NULL;

RequestAuctionBuyItem* RequestAuctionBuyItem::New() const {
  return new RequestAuctionBuyItem;
}

void RequestAuctionBuyItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionBuyItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionBuyItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 1;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->auction_id(), output);
  }

}

int RequestAuctionBuyItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 1;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionBuyItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionBuyItem*>(&from));
}

void RequestAuctionBuyItem::MergeFrom(const RequestAuctionBuyItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
  }
}

void RequestAuctionBuyItem::CopyFrom(const RequestAuctionBuyItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionBuyItem::IsInitialized() const {

  return true;
}

void RequestAuctionBuyItem::Swap(RequestAuctionBuyItem* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionBuyItem::GetTypeName() const {
  return "Protocol.RequestAuctionBuyItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionBuyItem::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionBuyItem::ResponseAuctionBuyItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionBuyItem::InitAsDefaultInstance() {
}

ResponseAuctionBuyItem::ResponseAuctionBuyItem(const ResponseAuctionBuyItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionBuyItem::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionBuyItem::~ResponseAuctionBuyItem() {
  SharedDtor();
}

void ResponseAuctionBuyItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionBuyItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionBuyItem& ResponseAuctionBuyItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionBuyItem* ResponseAuctionBuyItem::default_instance_ = NULL;

ResponseAuctionBuyItem* ResponseAuctionBuyItem::New() const {
  return new ResponseAuctionBuyItem;
}

void ResponseAuctionBuyItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionBuyItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionBuyItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseAuctionBuyItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionBuyItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionBuyItem*>(&from));
}

void ResponseAuctionBuyItem::MergeFrom(const ResponseAuctionBuyItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseAuctionBuyItem::CopyFrom(const ResponseAuctionBuyItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionBuyItem::IsInitialized() const {

  return true;
}

void ResponseAuctionBuyItem::Swap(ResponseAuctionBuyItem* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionBuyItem::GetTypeName() const {
  return "Protocol.ResponseAuctionBuyItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionBackoutItem::kAuctionIdFieldNumber;
#endif  // !_MSC_VER

RequestAuctionBackoutItem::RequestAuctionBackoutItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionBackoutItem::InitAsDefaultInstance() {
}

RequestAuctionBackoutItem::RequestAuctionBackoutItem(const RequestAuctionBackoutItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionBackoutItem::SharedCtor() {
  _cached_size_ = 0;
  auction_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionBackoutItem::~RequestAuctionBackoutItem() {
  SharedDtor();
}

void RequestAuctionBackoutItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionBackoutItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionBackoutItem& RequestAuctionBackoutItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionBackoutItem* RequestAuctionBackoutItem::default_instance_ = NULL;

RequestAuctionBackoutItem* RequestAuctionBackoutItem::New() const {
  return new RequestAuctionBackoutItem;
}

void RequestAuctionBackoutItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    auction_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionBackoutItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 auction_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &auction_id_)));
          set_has_auction_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionBackoutItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 auction_id = 1;
  if (has_auction_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->auction_id(), output);
  }

}

int RequestAuctionBackoutItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 auction_id = 1;
    if (has_auction_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->auction_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionBackoutItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionBackoutItem*>(&from));
}

void RequestAuctionBackoutItem::MergeFrom(const RequestAuctionBackoutItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_auction_id()) {
      set_auction_id(from.auction_id());
    }
  }
}

void RequestAuctionBackoutItem::CopyFrom(const RequestAuctionBackoutItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionBackoutItem::IsInitialized() const {

  return true;
}

void RequestAuctionBackoutItem::Swap(RequestAuctionBackoutItem* other) {
  if (other != this) {
    std::swap(auction_id_, other->auction_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionBackoutItem::GetTypeName() const {
  return "Protocol.RequestAuctionBackoutItem";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionBackoutItem::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionBackoutItem::ResponseAuctionBackoutItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionBackoutItem::InitAsDefaultInstance() {
}

ResponseAuctionBackoutItem::ResponseAuctionBackoutItem(const ResponseAuctionBackoutItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionBackoutItem::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionBackoutItem::~ResponseAuctionBackoutItem() {
  SharedDtor();
}

void ResponseAuctionBackoutItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionBackoutItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionBackoutItem& ResponseAuctionBackoutItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionBackoutItem* ResponseAuctionBackoutItem::default_instance_ = NULL;

ResponseAuctionBackoutItem* ResponseAuctionBackoutItem::New() const {
  return new ResponseAuctionBackoutItem;
}

void ResponseAuctionBackoutItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionBackoutItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionBackoutItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseAuctionBackoutItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionBackoutItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionBackoutItem*>(&from));
}

void ResponseAuctionBackoutItem::MergeFrom(const ResponseAuctionBackoutItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseAuctionBackoutItem::CopyFrom(const ResponseAuctionBackoutItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionBackoutItem::IsInitialized() const {

  return true;
}

void ResponseAuctionBackoutItem::Swap(ResponseAuctionBackoutItem* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionBackoutItem::GetTypeName() const {
  return "Protocol.ResponseAuctionBackoutItem";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestAuctionGetSelfItemList::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestAuctionGetSelfItemList::RequestAuctionGetSelfItemList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestAuctionGetSelfItemList::InitAsDefaultInstance() {
}

RequestAuctionGetSelfItemList::RequestAuctionGetSelfItemList(const RequestAuctionGetSelfItemList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestAuctionGetSelfItemList::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestAuctionGetSelfItemList::~RequestAuctionGetSelfItemList() {
  SharedDtor();
}

void RequestAuctionGetSelfItemList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestAuctionGetSelfItemList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestAuctionGetSelfItemList& RequestAuctionGetSelfItemList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

RequestAuctionGetSelfItemList* RequestAuctionGetSelfItemList::default_instance_ = NULL;

RequestAuctionGetSelfItemList* RequestAuctionGetSelfItemList::New() const {
  return new RequestAuctionGetSelfItemList;
}

void RequestAuctionGetSelfItemList::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestAuctionGetSelfItemList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestAuctionGetSelfItemList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestAuctionGetSelfItemList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestAuctionGetSelfItemList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestAuctionGetSelfItemList*>(&from));
}

void RequestAuctionGetSelfItemList::MergeFrom(const RequestAuctionGetSelfItemList& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestAuctionGetSelfItemList::CopyFrom(const RequestAuctionGetSelfItemList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestAuctionGetSelfItemList::IsInitialized() const {

  return true;
}

void RequestAuctionGetSelfItemList::Swap(RequestAuctionGetSelfItemList* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestAuctionGetSelfItemList::GetTypeName() const {
  return "Protocol.RequestAuctionGetSelfItemList";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseAuctionGetSelfItemList::kAuctionListFieldNumber;
#endif  // !_MSC_VER

ResponseAuctionGetSelfItemList::ResponseAuctionGetSelfItemList()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseAuctionGetSelfItemList::InitAsDefaultInstance() {
}

ResponseAuctionGetSelfItemList::ResponseAuctionGetSelfItemList(const ResponseAuctionGetSelfItemList& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseAuctionGetSelfItemList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseAuctionGetSelfItemList::~ResponseAuctionGetSelfItemList() {
  SharedDtor();
}

void ResponseAuctionGetSelfItemList::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseAuctionGetSelfItemList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseAuctionGetSelfItemList& ResponseAuctionGetSelfItemList::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

ResponseAuctionGetSelfItemList* ResponseAuctionGetSelfItemList::default_instance_ = NULL;

ResponseAuctionGetSelfItemList* ResponseAuctionGetSelfItemList::New() const {
  return new ResponseAuctionGetSelfItemList;
}

void ResponseAuctionGetSelfItemList::Clear() {
  auction_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseAuctionGetSelfItemList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.AuctionItemInfo auction_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_auction_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_auction_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_auction_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseAuctionGetSelfItemList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.AuctionItemInfo auction_list = 1;
  for (int i = 0; i < this->auction_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->auction_list(i), output);
  }

}

int ResponseAuctionGetSelfItemList::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.AuctionItemInfo auction_list = 1;
  total_size += 1 * this->auction_list_size();
  for (int i = 0; i < this->auction_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->auction_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseAuctionGetSelfItemList::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseAuctionGetSelfItemList*>(&from));
}

void ResponseAuctionGetSelfItemList::MergeFrom(const ResponseAuctionGetSelfItemList& from) {
  GOOGLE_CHECK_NE(&from, this);
  auction_list_.MergeFrom(from.auction_list_);
}

void ResponseAuctionGetSelfItemList::CopyFrom(const ResponseAuctionGetSelfItemList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseAuctionGetSelfItemList::IsInitialized() const {

  return true;
}

void ResponseAuctionGetSelfItemList::Swap(ResponseAuctionGetSelfItemList* other) {
  if (other != this) {
    auction_list_.Swap(&other->auction_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseAuctionGetSelfItemList::GetTypeName() const {
  return "Protocol.ResponseAuctionGetSelfItemList";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyAuctionUpdateParam::kSellItemCostFieldNumber;
const int NotifyAuctionUpdateParam::kSellMoneyTaxFieldNumber;
const int NotifyAuctionUpdateParam::kSellItemTaxFieldNumber;
const int NotifyAuctionUpdateParam::kSellMoneyMaxFieldNumber;
const int NotifyAuctionUpdateParam::kSellItemMaxFieldNumber;
#endif  // !_MSC_VER

NotifyAuctionUpdateParam::NotifyAuctionUpdateParam()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyAuctionUpdateParam::InitAsDefaultInstance() {
}

NotifyAuctionUpdateParam::NotifyAuctionUpdateParam(const NotifyAuctionUpdateParam& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyAuctionUpdateParam::SharedCtor() {
  _cached_size_ = 0;
  sell_item_cost_ = 0;
  sell_money_tax_ = 0;
  sell_item_tax_ = 0;
  sell_money_max_ = 0;
  sell_item_max_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyAuctionUpdateParam::~NotifyAuctionUpdateParam() {
  SharedDtor();
}

void NotifyAuctionUpdateParam::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyAuctionUpdateParam::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyAuctionUpdateParam& NotifyAuctionUpdateParam::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoAuction_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoAuction_2eproto();
#endif
  return *default_instance_;
}

NotifyAuctionUpdateParam* NotifyAuctionUpdateParam::default_instance_ = NULL;

NotifyAuctionUpdateParam* NotifyAuctionUpdateParam::New() const {
  return new NotifyAuctionUpdateParam;
}

void NotifyAuctionUpdateParam::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sell_item_cost_ = 0;
    sell_money_tax_ = 0;
    sell_item_tax_ = 0;
    sell_money_max_ = 0;
    sell_item_max_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyAuctionUpdateParam::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 sell_item_cost = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sell_item_cost_)));
          set_has_sell_item_cost();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_sell_money_tax;
        break;
      }

      // optional int32 sell_money_tax = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sell_money_tax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sell_money_tax_)));
          set_has_sell_money_tax();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_sell_item_tax;
        break;
      }

      // optional int32 sell_item_tax = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sell_item_tax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sell_item_tax_)));
          set_has_sell_item_tax();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sell_money_max;
        break;
      }

      // optional int32 sell_money_max = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sell_money_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sell_money_max_)));
          set_has_sell_money_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_sell_item_max;
        break;
      }

      // optional int32 sell_item_max = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sell_item_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sell_item_max_)));
          set_has_sell_item_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyAuctionUpdateParam::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 sell_item_cost = 1;
  if (has_sell_item_cost()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->sell_item_cost(), output);
  }

  // optional int32 sell_money_tax = 2;
  if (has_sell_money_tax()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->sell_money_tax(), output);
  }

  // optional int32 sell_item_tax = 3;
  if (has_sell_item_tax()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->sell_item_tax(), output);
  }

  // optional int32 sell_money_max = 4;
  if (has_sell_money_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->sell_money_max(), output);
  }

  // optional int32 sell_item_max = 5;
  if (has_sell_item_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->sell_item_max(), output);
  }

}

int NotifyAuctionUpdateParam::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 sell_item_cost = 1;
    if (has_sell_item_cost()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sell_item_cost());
    }

    // optional int32 sell_money_tax = 2;
    if (has_sell_money_tax()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sell_money_tax());
    }

    // optional int32 sell_item_tax = 3;
    if (has_sell_item_tax()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sell_item_tax());
    }

    // optional int32 sell_money_max = 4;
    if (has_sell_money_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sell_money_max());
    }

    // optional int32 sell_item_max = 5;
    if (has_sell_item_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sell_item_max());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyAuctionUpdateParam::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyAuctionUpdateParam*>(&from));
}

void NotifyAuctionUpdateParam::MergeFrom(const NotifyAuctionUpdateParam& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sell_item_cost()) {
      set_sell_item_cost(from.sell_item_cost());
    }
    if (from.has_sell_money_tax()) {
      set_sell_money_tax(from.sell_money_tax());
    }
    if (from.has_sell_item_tax()) {
      set_sell_item_tax(from.sell_item_tax());
    }
    if (from.has_sell_money_max()) {
      set_sell_money_max(from.sell_money_max());
    }
    if (from.has_sell_item_max()) {
      set_sell_item_max(from.sell_item_max());
    }
  }
}

void NotifyAuctionUpdateParam::CopyFrom(const NotifyAuctionUpdateParam& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyAuctionUpdateParam::IsInitialized() const {

  return true;
}

void NotifyAuctionUpdateParam::Swap(NotifyAuctionUpdateParam* other) {
  if (other != this) {
    std::swap(sell_item_cost_, other->sell_item_cost_);
    std::swap(sell_money_tax_, other->sell_money_tax_);
    std::swap(sell_item_tax_, other->sell_item_tax_);
    std::swap(sell_money_max_, other->sell_money_max_);
    std::swap(sell_item_max_, other->sell_item_max_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyAuctionUpdateParam::GetTypeName() const {
  return "Protocol.NotifyAuctionUpdateParam";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)
