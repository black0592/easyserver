// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoItem.proto

#ifndef PROTOBUF_ProtoItem_2eproto__INCLUDED
#define PROTOBUF_ProtoItem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoItem_2eproto();
void protobuf_AssignDesc_ProtoItem_2eproto();
void protobuf_ShutdownFile_ProtoItem_2eproto();

class DropItemInfo;
class NotifyCreateDropItem;
class NotifyMonsterDropItem;
class RequestCharDropItem;
class NotifyCharDropItem;
class NotifyRemoveItemFromMap;
class RequestPickupItem;
class NotifyPickupItem;
class RequestEquipItem;
class ResponseEquipItem;
class NotifyAddItem;
class NotifyRemoveItem;
class NotifyReplaceItem;
class NotifyRefreshPackage;
class RequestUseItem;
class ResponseUseItem;
class RequestGetBuyPackagePrice;
class ResponseGetBuyPackagePrice;
class RequestBuyPackageSize;
class ResponseBuyPackageSize;
class RequestSortPackage;
class StoreItem;
class RequestGetStoreItem;
class ResponseGetStoreItem;
class RequestBuyStoreItem;
class ResponseBuyStoreItem;
class SellItemInfo;
class RequestSellItem;
class ResponseSellItem;
class RequestGetSafeItems;
class RequestDepositMoney;
class RequestWithdrawMoney;
class RequestDepositItem;
class RequestWithdrawItem;
class CashShopItem;
class RequestGetCashShopItem;
class ResponseGetCashShopItem;
class RequestBuyCashShopItem;
class ResponseBuyCashShopItem;
class RequestRemoteOpenEquipRepair;
class RequestGetEquipRepairMoney;
class ResponseGetEquipRepairMoney;
class RequestEquipRepair;
class ResponseEquipRepair;
class RequestEquipGetResetExpiredCost;
class ResponseEquipGetResetExpiredCost;
class RequestEquipResetExpiredTime;
class ResponseEquipResetExpiredTime;
class RequestBuybackGetItem;
class RequestBuybackBuyItem;

enum ItemOpCode {
  OP_CREATE_DROP_ITEM = 1,
  OP_MONSTER_DROP_ITEM = 2,
  OP_CHAR_DROP_ITEM = 3,
  OP_REMOVE_ITEM_FROM_MAP = 4,
  OP_PICKUP_ITEM = 5,
  OP_EQUIP_ITEM = 6,
  OP_ADD_ITEM = 7,
  OP_REMOVE_ITEM = 8,
  OP_REPLACE_ITEM = 9,
  OP_STORE_GET_ITEMS = 10,
  OP_STORE_BUY_ITEMS = 11,
  OP_STORE_SELL_ITEMS = 12,
  OP_USE_ITEM = 13,
  OP_GET_BUY_PACKAGE_PRICE = 14,
  OP_BUY_PACKAGE_SIZE = 15,
  OP_SORT_PACKAGE = 16,
  OP_REFRESH_PACKAGE = 17,
  OP_SAFE_GET_ITEMS = 20,
  OP_SAFE_DEPOSIT_MONEY = 21,
  OP_SAFE_WITHDRAW_MONEY = 22,
  OP_SAFE_DEPOSIT_ITEM = 23,
  OP_SAFE_WITHDRAW_ITEM = 24,
  OP_CASHSHOP_GET_ITEMS = 30,
  OP_CASHSHOP_BUY_ITEMS = 31,
  OP_EQUIP_REPAIR_REMOTE_OPEN = 40,
  OP_EQUIP_REPAIR_GET_MONEY = 41,
  OP_EQUIP_REPAIR = 42,
  OP_EQUIP_GET_RESET_EXPIRED_COST = 43,
  OP_EQUIP_RESET_EXPIRED_TIME = 44,
  OP_BUYBACK_GET_ITEMS = 45,
  OP_BUYBACK_BUY_ITEMS = 46
};
bool ItemOpCode_IsValid(int value);
const ItemOpCode ItemOpCode_MIN = OP_CREATE_DROP_ITEM;
const ItemOpCode ItemOpCode_MAX = OP_BUYBACK_BUY_ITEMS;
const int ItemOpCode_ARRAYSIZE = ItemOpCode_MAX + 1;

enum StoreCurrencyType {
  Money = 0,
  GuildCredits = 1
};
bool StoreCurrencyType_IsValid(int value);
const StoreCurrencyType StoreCurrencyType_MIN = Money;
const StoreCurrencyType StoreCurrencyType_MAX = GuildCredits;
const int StoreCurrencyType_ARRAYSIZE = StoreCurrencyType_MAX + 1;

enum EquipRepairType {
  REPAIR_EUIQP = 0,
  REPAIR_ALL = 1
};
bool EquipRepairType_IsValid(int value);
const EquipRepairType EquipRepairType_MIN = REPAIR_EUIQP;
const EquipRepairType EquipRepairType_MAX = REPAIR_ALL;
const int EquipRepairType_ARRAYSIZE = EquipRepairType_MAX + 1;

// ===================================================================

class DropItemInfo : public ::google::protobuf::MessageLite {
 public:
  DropItemInfo();
  virtual ~DropItemInfo();

  DropItemInfo(const DropItemInfo& from);

  inline DropItemInfo& operator=(const DropItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const DropItemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DropItemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DropItemInfo* other);

  // implements Message ----------------------------------------------

  DropItemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DropItemInfo& from);
  void MergeFrom(const DropItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 owner_id = 1;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 1;
  inline ::google::protobuf::int32 owner_id() const;
  inline void set_owner_id(::google::protobuf::int32 value);

  // optional int32 item_id = 2;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // optional int32 item_num = 3 [default = 1];
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 3;
  inline ::google::protobuf::int32 item_num() const;
  inline void set_item_num(::google::protobuf::int32 value);

  // optional int32 map_x = 4;
  inline bool has_map_x() const;
  inline void clear_map_x();
  static const int kMapXFieldNumber = 4;
  inline ::google::protobuf::int32 map_x() const;
  inline void set_map_x(::google::protobuf::int32 value);

  // optional int32 map_y = 5;
  inline bool has_map_y() const;
  inline void clear_map_y();
  static const int kMapYFieldNumber = 5;
  inline ::google::protobuf::int32 map_y() const;
  inline void set_map_y(::google::protobuf::int32 value);

  // optional int32 color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline ::google::protobuf::int32 color() const;
  inline void set_color(::google::protobuf::int32 value);

  // optional int32 quality = 7;
  inline bool has_quality() const;
  inline void clear_quality();
  static const int kQualityFieldNumber = 7;
  inline ::google::protobuf::int32 quality() const;
  inline void set_quality(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.DropItemInfo)
 private:
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_item_id();
  inline void clear_has_item_id();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_map_x();
  inline void clear_has_map_x();
  inline void set_has_map_y();
  inline void clear_has_map_y();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_quality();
  inline void clear_has_quality();

  ::google::protobuf::int32 owner_id_;
  ::google::protobuf::int32 item_id_;
  ::google::protobuf::int32 item_num_;
  ::google::protobuf::int32 map_x_;
  ::google::protobuf::int32 map_y_;
  ::google::protobuf::int32 color_;
  ::google::protobuf::int32 quality_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static DropItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCreateDropItem : public ::google::protobuf::MessageLite {
 public:
  NotifyCreateDropItem();
  virtual ~NotifyCreateDropItem();

  NotifyCreateDropItem(const NotifyCreateDropItem& from);

  inline NotifyCreateDropItem& operator=(const NotifyCreateDropItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCreateDropItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCreateDropItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCreateDropItem* other);

  // implements Message ----------------------------------------------

  NotifyCreateDropItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCreateDropItem& from);
  void MergeFrom(const NotifyCreateDropItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.DropItemInfo item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::Protocol::DropItemInfo& item_list(int index) const;
  inline ::Protocol::DropItemInfo* mutable_item_list(int index);
  inline ::Protocol::DropItemInfo* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCreateDropItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyCreateDropItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyMonsterDropItem : public ::google::protobuf::MessageLite {
 public:
  NotifyMonsterDropItem();
  virtual ~NotifyMonsterDropItem();

  NotifyMonsterDropItem(const NotifyMonsterDropItem& from);

  inline NotifyMonsterDropItem& operator=(const NotifyMonsterDropItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyMonsterDropItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyMonsterDropItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyMonsterDropItem* other);

  // implements Message ----------------------------------------------

  NotifyMonsterDropItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyMonsterDropItem& from);
  void MergeFrom(const NotifyMonsterDropItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.DropItemInfo item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::Protocol::DropItemInfo& item_list(int index) const;
  inline ::Protocol::DropItemInfo* mutable_item_list(int index);
  inline ::Protocol::DropItemInfo* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyMonsterDropItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyMonsterDropItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestCharDropItem : public ::google::protobuf::MessageLite {
 public:
  RequestCharDropItem();
  virtual ~RequestCharDropItem();

  RequestCharDropItem(const RequestCharDropItem& from);

  inline RequestCharDropItem& operator=(const RequestCharDropItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestCharDropItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCharDropItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCharDropItem* other);

  // implements Message ----------------------------------------------

  RequestCharDropItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCharDropItem& from);
  void MergeFrom(const RequestCharDropItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc src_loc = 1;
  inline bool has_src_loc() const;
  inline void clear_src_loc();
  static const int kSrcLocFieldNumber = 1;
  inline const ::ItemLoc& src_loc() const;
  inline ::ItemLoc* mutable_src_loc();
  inline ::ItemLoc* release_src_loc();
  inline void set_allocated_src_loc(::ItemLoc* src_loc);

  // optional int32 item_num = 2;
  inline bool has_item_num() const;
  inline void clear_item_num();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::int32 item_num() const;
  inline void set_item_num(::google::protobuf::int32 value);

  // optional int32 map_x = 3;
  inline bool has_map_x() const;
  inline void clear_map_x();
  static const int kMapXFieldNumber = 3;
  inline ::google::protobuf::int32 map_x() const;
  inline void set_map_x(::google::protobuf::int32 value);

  // optional int32 map_y = 4;
  inline bool has_map_y() const;
  inline void clear_map_y();
  static const int kMapYFieldNumber = 4;
  inline ::google::protobuf::int32 map_y() const;
  inline void set_map_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestCharDropItem)
 private:
  inline void set_has_src_loc();
  inline void clear_has_src_loc();
  inline void set_has_item_num();
  inline void clear_has_item_num();
  inline void set_has_map_x();
  inline void clear_has_map_x();
  inline void set_has_map_y();
  inline void clear_has_map_y();

  ::ItemLoc* src_loc_;
  ::google::protobuf::int32 item_num_;
  ::google::protobuf::int32 map_x_;
  ::google::protobuf::int32 map_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestCharDropItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCharDropItem : public ::google::protobuf::MessageLite {
 public:
  NotifyCharDropItem();
  virtual ~NotifyCharDropItem();

  NotifyCharDropItem(const NotifyCharDropItem& from);

  inline NotifyCharDropItem& operator=(const NotifyCharDropItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCharDropItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCharDropItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCharDropItem* other);

  // implements Message ----------------------------------------------

  NotifyCharDropItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCharDropItem& from);
  void MergeFrom(const NotifyCharDropItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.DropItemInfo item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::Protocol::DropItemInfo& item() const;
  inline ::Protocol::DropItemInfo* mutable_item();
  inline ::Protocol::DropItemInfo* release_item();
  inline void set_allocated_item(::Protocol::DropItemInfo* item);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCharDropItem)
 private:
  inline void set_has_item();
  inline void clear_has_item();

  ::Protocol::DropItemInfo* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyCharDropItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRemoveItemFromMap : public ::google::protobuf::MessageLite {
 public:
  NotifyRemoveItemFromMap();
  virtual ~NotifyRemoveItemFromMap();

  NotifyRemoveItemFromMap(const NotifyRemoveItemFromMap& from);

  inline NotifyRemoveItemFromMap& operator=(const NotifyRemoveItemFromMap& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyRemoveItemFromMap& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRemoveItemFromMap* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRemoveItemFromMap* other);

  // implements Message ----------------------------------------------

  NotifyRemoveItemFromMap* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRemoveItemFromMap& from);
  void MergeFrom(const NotifyRemoveItemFromMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 map_x = 1;
  inline bool has_map_x() const;
  inline void clear_map_x();
  static const int kMapXFieldNumber = 1;
  inline ::google::protobuf::int32 map_x() const;
  inline void set_map_x(::google::protobuf::int32 value);

  // optional int32 map_y = 2;
  inline bool has_map_y() const;
  inline void clear_map_y();
  static const int kMapYFieldNumber = 2;
  inline ::google::protobuf::int32 map_y() const;
  inline void set_map_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyRemoveItemFromMap)
 private:
  inline void set_has_map_x();
  inline void clear_has_map_x();
  inline void set_has_map_y();
  inline void clear_has_map_y();

  ::google::protobuf::int32 map_x_;
  ::google::protobuf::int32 map_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyRemoveItemFromMap* default_instance_;
};
// -------------------------------------------------------------------

class RequestPickupItem : public ::google::protobuf::MessageLite {
 public:
  RequestPickupItem();
  virtual ~RequestPickupItem();

  RequestPickupItem(const RequestPickupItem& from);

  inline RequestPickupItem& operator=(const RequestPickupItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestPickupItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestPickupItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestPickupItem* other);

  // implements Message ----------------------------------------------

  RequestPickupItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestPickupItem& from);
  void MergeFrom(const RequestPickupItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 map_x = 1;
  inline bool has_map_x() const;
  inline void clear_map_x();
  static const int kMapXFieldNumber = 1;
  inline ::google::protobuf::int32 map_x() const;
  inline void set_map_x(::google::protobuf::int32 value);

  // optional int32 map_y = 2;
  inline bool has_map_y() const;
  inline void clear_map_y();
  static const int kMapYFieldNumber = 2;
  inline ::google::protobuf::int32 map_y() const;
  inline void set_map_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestPickupItem)
 private:
  inline void set_has_map_x();
  inline void clear_has_map_x();
  inline void set_has_map_y();
  inline void clear_has_map_y();

  ::google::protobuf::int32 map_x_;
  ::google::protobuf::int32 map_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestPickupItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyPickupItem : public ::google::protobuf::MessageLite {
 public:
  NotifyPickupItem();
  virtual ~NotifyPickupItem();

  NotifyPickupItem(const NotifyPickupItem& from);

  inline NotifyPickupItem& operator=(const NotifyPickupItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyPickupItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyPickupItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyPickupItem* other);

  // implements Message ----------------------------------------------

  NotifyPickupItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyPickupItem& from);
  void MergeFrom(const NotifyPickupItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 char_id = 1;
  inline bool has_char_id() const;
  inline void clear_char_id();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::int32 char_id() const;
  inline void set_char_id(::google::protobuf::int32 value);

  // optional int32 map_x = 2;
  inline bool has_map_x() const;
  inline void clear_map_x();
  static const int kMapXFieldNumber = 2;
  inline ::google::protobuf::int32 map_x() const;
  inline void set_map_x(::google::protobuf::int32 value);

  // optional int32 map_y = 3;
  inline bool has_map_y() const;
  inline void clear_map_y();
  static const int kMapYFieldNumber = 3;
  inline ::google::protobuf::int32 map_y() const;
  inline void set_map_y(::google::protobuf::int32 value);

  // optional int32 item_id = 4;
  inline bool has_item_id() const;
  inline void clear_item_id();
  static const int kItemIdFieldNumber = 4;
  inline ::google::protobuf::int32 item_id() const;
  inline void set_item_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyPickupItem)
 private:
  inline void set_has_char_id();
  inline void clear_has_char_id();
  inline void set_has_map_x();
  inline void clear_has_map_x();
  inline void set_has_map_y();
  inline void clear_has_map_y();
  inline void set_has_item_id();
  inline void clear_has_item_id();

  ::google::protobuf::int32 char_id_;
  ::google::protobuf::int32 map_x_;
  ::google::protobuf::int32 map_y_;
  ::google::protobuf::int32 item_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyPickupItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestEquipItem : public ::google::protobuf::MessageLite {
 public:
  RequestEquipItem();
  virtual ~RequestEquipItem();

  RequestEquipItem(const RequestEquipItem& from);

  inline RequestEquipItem& operator=(const RequestEquipItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestEquipItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestEquipItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestEquipItem* other);

  // implements Message ----------------------------------------------

  RequestEquipItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestEquipItem& from);
  void MergeFrom(const RequestEquipItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc src_loc = 1;
  inline bool has_src_loc() const;
  inline void clear_src_loc();
  static const int kSrcLocFieldNumber = 1;
  inline const ::ItemLoc& src_loc() const;
  inline ::ItemLoc* mutable_src_loc();
  inline ::ItemLoc* release_src_loc();
  inline void set_allocated_src_loc(::ItemLoc* src_loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestEquipItem)
 private:
  inline void set_has_src_loc();
  inline void clear_has_src_loc();

  ::ItemLoc* src_loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestEquipItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseEquipItem : public ::google::protobuf::MessageLite {
 public:
  ResponseEquipItem();
  virtual ~ResponseEquipItem();

  ResponseEquipItem(const ResponseEquipItem& from);

  inline ResponseEquipItem& operator=(const ResponseEquipItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseEquipItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseEquipItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseEquipItem* other);

  // implements Message ----------------------------------------------

  ResponseEquipItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseEquipItem& from);
  void MergeFrom(const ResponseEquipItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc src_loc = 1;
  inline bool has_src_loc() const;
  inline void clear_src_loc();
  static const int kSrcLocFieldNumber = 1;
  inline const ::ItemLoc& src_loc() const;
  inline ::ItemLoc* mutable_src_loc();
  inline ::ItemLoc* release_src_loc();
  inline void set_allocated_src_loc(::ItemLoc* src_loc);

  // optional .ItemLoc dest_loc = 2;
  inline bool has_dest_loc() const;
  inline void clear_dest_loc();
  static const int kDestLocFieldNumber = 2;
  inline const ::ItemLoc& dest_loc() const;
  inline ::ItemLoc* mutable_dest_loc();
  inline ::ItemLoc* release_dest_loc();
  inline void set_allocated_dest_loc(::ItemLoc* dest_loc);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseEquipItem)
 private:
  inline void set_has_src_loc();
  inline void clear_has_src_loc();
  inline void set_has_dest_loc();
  inline void clear_has_dest_loc();

  ::ItemLoc* src_loc_;
  ::ItemLoc* dest_loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseEquipItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyAddItem : public ::google::protobuf::MessageLite {
 public:
  NotifyAddItem();
  virtual ~NotifyAddItem();

  NotifyAddItem(const NotifyAddItem& from);

  inline NotifyAddItem& operator=(const NotifyAddItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyAddItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyAddItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyAddItem* other);

  // implements Message ----------------------------------------------

  NotifyAddItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyAddItem& from);
  void MergeFrom(const NotifyAddItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ItemLocData item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::ItemLocData& item_list(int index) const;
  inline ::ItemLocData* mutable_item_list(int index);
  inline ::ItemLocData* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemLocData >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemLocData >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyAddItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::ItemLocData > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyAddItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRemoveItem : public ::google::protobuf::MessageLite {
 public:
  NotifyRemoveItem();
  virtual ~NotifyRemoveItem();

  NotifyRemoveItem(const NotifyRemoveItem& from);

  inline NotifyRemoveItem& operator=(const NotifyRemoveItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyRemoveItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRemoveItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRemoveItem* other);

  // implements Message ----------------------------------------------

  NotifyRemoveItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRemoveItem& from);
  void MergeFrom(const NotifyRemoveItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ItemLoc loc_list = 1;
  inline int loc_list_size() const;
  inline void clear_loc_list();
  static const int kLocListFieldNumber = 1;
  inline const ::ItemLoc& loc_list(int index) const;
  inline ::ItemLoc* mutable_loc_list(int index);
  inline ::ItemLoc* add_loc_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemLoc >&
      loc_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemLoc >*
      mutable_loc_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyRemoveItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::ItemLoc > loc_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyRemoveItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyReplaceItem : public ::google::protobuf::MessageLite {
 public:
  NotifyReplaceItem();
  virtual ~NotifyReplaceItem();

  NotifyReplaceItem(const NotifyReplaceItem& from);

  inline NotifyReplaceItem& operator=(const NotifyReplaceItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyReplaceItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyReplaceItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyReplaceItem* other);

  // implements Message ----------------------------------------------

  NotifyReplaceItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyReplaceItem& from);
  void MergeFrom(const NotifyReplaceItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ItemLocData item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::ItemLocData& item_list(int index) const;
  inline ::ItemLocData* mutable_item_list(int index);
  inline ::ItemLocData* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemLocData >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemLocData >*
      mutable_item_list();

  // optional bool is_new_item = 2 [default = true];
  inline bool has_is_new_item() const;
  inline void clear_is_new_item();
  static const int kIsNewItemFieldNumber = 2;
  inline bool is_new_item() const;
  inline void set_is_new_item(bool value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyReplaceItem)
 private:
  inline void set_has_is_new_item();
  inline void clear_has_is_new_item();

  ::google::protobuf::RepeatedPtrField< ::ItemLocData > item_list_;
  bool is_new_item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyReplaceItem* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRefreshPackage : public ::google::protobuf::MessageLite {
 public:
  NotifyRefreshPackage();
  virtual ~NotifyRefreshPackage();

  NotifyRefreshPackage(const NotifyRefreshPackage& from);

  inline NotifyRefreshPackage& operator=(const NotifyRefreshPackage& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyRefreshPackage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRefreshPackage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRefreshPackage* other);

  // implements Message ----------------------------------------------

  NotifyRefreshPackage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRefreshPackage& from);
  void MergeFrom(const NotifyRefreshPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pkg = 1;
  inline bool has_pkg() const;
  inline void clear_pkg();
  static const int kPkgFieldNumber = 1;
  inline ::google::protobuf::int32 pkg() const;
  inline void set_pkg(::google::protobuf::int32 value);

  // repeated .ItemData item_list = 2;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 2;
  inline const ::ItemData& item_list(int index) const;
  inline ::ItemData* mutable_item_list(int index);
  inline ::ItemData* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyRefreshPackage)
 private:
  inline void set_has_pkg();
  inline void clear_has_pkg();

  ::google::protobuf::RepeatedPtrField< ::ItemData > item_list_;
  ::google::protobuf::int32 pkg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static NotifyRefreshPackage* default_instance_;
};
// -------------------------------------------------------------------

class RequestUseItem : public ::google::protobuf::MessageLite {
 public:
  RequestUseItem();
  virtual ~RequestUseItem();

  RequestUseItem(const RequestUseItem& from);

  inline RequestUseItem& operator=(const RequestUseItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestUseItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUseItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUseItem* other);

  // implements Message ----------------------------------------------

  RequestUseItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUseItem& from);
  void MergeFrom(const RequestUseItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestUseItem)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();

  ::ItemLoc* loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestUseItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUseItem : public ::google::protobuf::MessageLite {
 public:
  ResponseUseItem();
  virtual ~ResponseUseItem();

  ResponseUseItem(const ResponseUseItem& from);

  inline ResponseUseItem& operator=(const ResponseUseItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseUseItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseUseItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseUseItem* other);

  // implements Message ----------------------------------------------

  ResponseUseItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseUseItem& from);
  void MergeFrom(const ResponseUseItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseUseItem)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();

  ::ItemLoc* loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseUseItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBuyPackagePrice : public ::google::protobuf::MessageLite {
 public:
  RequestGetBuyPackagePrice();
  virtual ~RequestGetBuyPackagePrice();

  RequestGetBuyPackagePrice(const RequestGetBuyPackagePrice& from);

  inline RequestGetBuyPackagePrice& operator=(const RequestGetBuyPackagePrice& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetBuyPackagePrice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBuyPackagePrice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBuyPackagePrice* other);

  // implements Message ----------------------------------------------

  RequestGetBuyPackagePrice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBuyPackagePrice& from);
  void MergeFrom(const RequestGetBuyPackagePrice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pkg = 1;
  inline bool has_pkg() const;
  inline void clear_pkg();
  static const int kPkgFieldNumber = 1;
  inline ::google::protobuf::int32 pkg() const;
  inline void set_pkg(::google::protobuf::int32 value);

  // optional int32 buy_num = 2;
  inline bool has_buy_num() const;
  inline void clear_buy_num();
  static const int kBuyNumFieldNumber = 2;
  inline ::google::protobuf::int32 buy_num() const;
  inline void set_buy_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetBuyPackagePrice)
 private:
  inline void set_has_pkg();
  inline void clear_has_pkg();
  inline void set_has_buy_num();
  inline void clear_has_buy_num();

  ::google::protobuf::int32 pkg_;
  ::google::protobuf::int32 buy_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBuyPackagePrice* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetBuyPackagePrice : public ::google::protobuf::MessageLite {
 public:
  ResponseGetBuyPackagePrice();
  virtual ~ResponseGetBuyPackagePrice();

  ResponseGetBuyPackagePrice(const ResponseGetBuyPackagePrice& from);

  inline ResponseGetBuyPackagePrice& operator=(const ResponseGetBuyPackagePrice& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetBuyPackagePrice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetBuyPackagePrice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetBuyPackagePrice* other);

  // implements Message ----------------------------------------------

  ResponseGetBuyPackagePrice* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetBuyPackagePrice& from);
  void MergeFrom(const ResponseGetBuyPackagePrice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pkg = 1;
  inline bool has_pkg() const;
  inline void clear_pkg();
  static const int kPkgFieldNumber = 1;
  inline ::google::protobuf::int32 pkg() const;
  inline void set_pkg(::google::protobuf::int32 value);

  // optional int32 buy_num = 2;
  inline bool has_buy_num() const;
  inline void clear_buy_num();
  static const int kBuyNumFieldNumber = 2;
  inline ::google::protobuf::int32 buy_num() const;
  inline void set_buy_num(::google::protobuf::int32 value);

  // optional int32 price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetBuyPackagePrice)
 private:
  inline void set_has_pkg();
  inline void clear_has_pkg();
  inline void set_has_buy_num();
  inline void clear_has_buy_num();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::int32 pkg_;
  ::google::protobuf::int32 buy_num_;
  ::google::protobuf::int32 price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetBuyPackagePrice* default_instance_;
};
// -------------------------------------------------------------------

class RequestBuyPackageSize : public ::google::protobuf::MessageLite {
 public:
  RequestBuyPackageSize();
  virtual ~RequestBuyPackageSize();

  RequestBuyPackageSize(const RequestBuyPackageSize& from);

  inline RequestBuyPackageSize& operator=(const RequestBuyPackageSize& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestBuyPackageSize& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBuyPackageSize* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBuyPackageSize* other);

  // implements Message ----------------------------------------------

  RequestBuyPackageSize* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBuyPackageSize& from);
  void MergeFrom(const RequestBuyPackageSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pkg = 1;
  inline bool has_pkg() const;
  inline void clear_pkg();
  static const int kPkgFieldNumber = 1;
  inline ::google::protobuf::int32 pkg() const;
  inline void set_pkg(::google::protobuf::int32 value);

  // optional int32 buy_num = 2;
  inline bool has_buy_num() const;
  inline void clear_buy_num();
  static const int kBuyNumFieldNumber = 2;
  inline ::google::protobuf::int32 buy_num() const;
  inline void set_buy_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestBuyPackageSize)
 private:
  inline void set_has_pkg();
  inline void clear_has_pkg();
  inline void set_has_buy_num();
  inline void clear_has_buy_num();

  ::google::protobuf::int32 pkg_;
  ::google::protobuf::int32 buy_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestBuyPackageSize* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBuyPackageSize : public ::google::protobuf::MessageLite {
 public:
  ResponseBuyPackageSize();
  virtual ~ResponseBuyPackageSize();

  ResponseBuyPackageSize(const ResponseBuyPackageSize& from);

  inline ResponseBuyPackageSize& operator=(const ResponseBuyPackageSize& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseBuyPackageSize& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseBuyPackageSize* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseBuyPackageSize* other);

  // implements Message ----------------------------------------------

  ResponseBuyPackageSize* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseBuyPackageSize& from);
  void MergeFrom(const ResponseBuyPackageSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 pkg = 2;
  inline bool has_pkg() const;
  inline void clear_pkg();
  static const int kPkgFieldNumber = 2;
  inline ::google::protobuf::int32 pkg() const;
  inline void set_pkg(::google::protobuf::int32 value);

  // optional int32 cur_num = 3;
  inline bool has_cur_num() const;
  inline void clear_cur_num();
  static const int kCurNumFieldNumber = 3;
  inline ::google::protobuf::int32 cur_num() const;
  inline void set_cur_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseBuyPackageSize)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_pkg();
  inline void clear_has_pkg();
  inline void set_has_cur_num();
  inline void clear_has_cur_num();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 pkg_;
  ::google::protobuf::int32 cur_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseBuyPackageSize* default_instance_;
};
// -------------------------------------------------------------------

class RequestSortPackage : public ::google::protobuf::MessageLite {
 public:
  RequestSortPackage();
  virtual ~RequestSortPackage();

  RequestSortPackage(const RequestSortPackage& from);

  inline RequestSortPackage& operator=(const RequestSortPackage& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestSortPackage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSortPackage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSortPackage* other);

  // implements Message ----------------------------------------------

  RequestSortPackage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSortPackage& from);
  void MergeFrom(const RequestSortPackage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pkg = 1;
  inline bool has_pkg() const;
  inline void clear_pkg();
  static const int kPkgFieldNumber = 1;
  inline ::google::protobuf::int32 pkg() const;
  inline void set_pkg(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestSortPackage)
 private:
  inline void set_has_pkg();
  inline void clear_has_pkg();

  ::google::protobuf::int32 pkg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestSortPackage* default_instance_;
};
// -------------------------------------------------------------------

class StoreItem : public ::google::protobuf::MessageLite {
 public:
  StoreItem();
  virtual ~StoreItem();

  StoreItem(const StoreItem& from);

  inline StoreItem& operator=(const StoreItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const StoreItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StoreItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StoreItem* other);

  // implements Message ----------------------------------------------

  StoreItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StoreItem& from);
  void MergeFrom(const StoreItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.StoreItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_price();
  inline void clear_has_price();

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static StoreItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetStoreItem : public ::google::protobuf::MessageLite {
 public:
  RequestGetStoreItem();
  virtual ~RequestGetStoreItem();

  RequestGetStoreItem(const RequestGetStoreItem& from);

  inline RequestGetStoreItem& operator=(const RequestGetStoreItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetStoreItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetStoreItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetStoreItem* other);

  // implements Message ----------------------------------------------

  RequestGetStoreItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetStoreItem& from);
  void MergeFrom(const RequestGetStoreItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 npcid = 1;
  inline bool has_npcid() const;
  inline void clear_npcid();
  static const int kNpcidFieldNumber = 1;
  inline ::google::protobuf::int32 npcid() const;
  inline void set_npcid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetStoreItem)
 private:
  inline void set_has_npcid();
  inline void clear_has_npcid();

  ::google::protobuf::int32 npcid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestGetStoreItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetStoreItem : public ::google::protobuf::MessageLite {
 public:
  ResponseGetStoreItem();
  virtual ~ResponseGetStoreItem();

  ResponseGetStoreItem(const ResponseGetStoreItem& from);

  inline ResponseGetStoreItem& operator=(const ResponseGetStoreItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetStoreItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetStoreItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetStoreItem* other);

  // implements Message ----------------------------------------------

  ResponseGetStoreItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetStoreItem& from);
  void MergeFrom(const ResponseGetStoreItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.StoreCurrencyType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Protocol::StoreCurrencyType type() const;
  inline void set_type(::Protocol::StoreCurrencyType value);

  // repeated .Protocol.StoreItem item_list = 2;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 2;
  inline const ::Protocol::StoreItem& item_list(int index) const;
  inline ::Protocol::StoreItem* mutable_item_list(int index);
  inline ::Protocol::StoreItem* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::StoreItem >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::StoreItem >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetStoreItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::RepeatedPtrField< ::Protocol::StoreItem > item_list_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetStoreItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestBuyStoreItem : public ::google::protobuf::MessageLite {
 public:
  RequestBuyStoreItem();
  virtual ~RequestBuyStoreItem();

  RequestBuyStoreItem(const RequestBuyStoreItem& from);

  inline RequestBuyStoreItem& operator=(const RequestBuyStoreItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestBuyStoreItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBuyStoreItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBuyStoreItem* other);

  // implements Message ----------------------------------------------

  RequestBuyStoreItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBuyStoreItem& from);
  void MergeFrom(const RequestBuyStoreItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 itemid = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional int32 money = 3;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 3;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestBuyStoreItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestBuyStoreItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBuyStoreItem : public ::google::protobuf::MessageLite {
 public:
  ResponseBuyStoreItem();
  virtual ~ResponseBuyStoreItem();

  ResponseBuyStoreItem(const ResponseBuyStoreItem& from);

  inline ResponseBuyStoreItem& operator=(const ResponseBuyStoreItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseBuyStoreItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseBuyStoreItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseBuyStoreItem* other);

  // implements Message ----------------------------------------------

  ResponseBuyStoreItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseBuyStoreItem& from);
  void MergeFrom(const ResponseBuyStoreItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseBuyStoreItem)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseBuyStoreItem* default_instance_;
};
// -------------------------------------------------------------------

class SellItemInfo : public ::google::protobuf::MessageLite {
 public:
  SellItemInfo();
  virtual ~SellItemInfo();

  SellItemInfo(const SellItemInfo& from);

  inline SellItemInfo& operator=(const SellItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SellItemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SellItemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SellItemInfo* other);

  // implements Message ----------------------------------------------

  SellItemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SellItemInfo& from);
  void MergeFrom(const SellItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.SellItemInfo)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();
  inline void set_has_num();
  inline void clear_has_num();

  ::ItemLoc* loc_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static SellItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestSellItem : public ::google::protobuf::MessageLite {
 public:
  RequestSellItem();
  virtual ~RequestSellItem();

  RequestSellItem(const RequestSellItem& from);

  inline RequestSellItem& operator=(const RequestSellItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestSellItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSellItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSellItem* other);

  // implements Message ----------------------------------------------

  RequestSellItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSellItem& from);
  void MergeFrom(const RequestSellItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.SellItemInfo item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::Protocol::SellItemInfo& item_list(int index) const;
  inline ::Protocol::SellItemInfo* mutable_item_list(int index);
  inline ::Protocol::SellItemInfo* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::SellItemInfo >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::SellItemInfo >*
      mutable_item_list();

  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestSellItem)
 private:
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::RepeatedPtrField< ::Protocol::SellItemInfo > item_list_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestSellItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseSellItem : public ::google::protobuf::MessageLite {
 public:
  ResponseSellItem();
  virtual ~ResponseSellItem();

  ResponseSellItem(const ResponseSellItem& from);

  inline ResponseSellItem& operator=(const ResponseSellItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseSellItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseSellItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseSellItem* other);

  // implements Message ----------------------------------------------

  ResponseSellItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseSellItem& from);
  void MergeFrom(const ResponseSellItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseSellItem)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseSellItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetSafeItems : public ::google::protobuf::MessageLite {
 public:
  RequestGetSafeItems();
  virtual ~RequestGetSafeItems();

  RequestGetSafeItems(const RequestGetSafeItems& from);

  inline RequestGetSafeItems& operator=(const RequestGetSafeItems& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetSafeItems& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetSafeItems* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetSafeItems* other);

  // implements Message ----------------------------------------------

  RequestGetSafeItems* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetSafeItems& from);
  void MergeFrom(const RequestGetSafeItems& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetSafeItems)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestGetSafeItems* default_instance_;
};
// -------------------------------------------------------------------

class RequestDepositMoney : public ::google::protobuf::MessageLite {
 public:
  RequestDepositMoney();
  virtual ~RequestDepositMoney();

  RequestDepositMoney(const RequestDepositMoney& from);

  inline RequestDepositMoney& operator=(const RequestDepositMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestDepositMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestDepositMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestDepositMoney* other);

  // implements Message ----------------------------------------------

  RequestDepositMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestDepositMoney& from);
  void MergeFrom(const RequestDepositMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 money = 1;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 1;
  inline ::google::protobuf::uint64 money() const;
  inline void set_money(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestDepositMoney)
 private:
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::uint64 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestDepositMoney* default_instance_;
};
// -------------------------------------------------------------------

class RequestWithdrawMoney : public ::google::protobuf::MessageLite {
 public:
  RequestWithdrawMoney();
  virtual ~RequestWithdrawMoney();

  RequestWithdrawMoney(const RequestWithdrawMoney& from);

  inline RequestWithdrawMoney& operator=(const RequestWithdrawMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestWithdrawMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestWithdrawMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestWithdrawMoney* other);

  // implements Message ----------------------------------------------

  RequestWithdrawMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestWithdrawMoney& from);
  void MergeFrom(const RequestWithdrawMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 money = 1;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 1;
  inline ::google::protobuf::uint64 money() const;
  inline void set_money(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestWithdrawMoney)
 private:
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::uint64 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestWithdrawMoney* default_instance_;
};
// -------------------------------------------------------------------

class RequestDepositItem : public ::google::protobuf::MessageLite {
 public:
  RequestDepositItem();
  virtual ~RequestDepositItem();

  RequestDepositItem(const RequestDepositItem& from);

  inline RequestDepositItem& operator=(const RequestDepositItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestDepositItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestDepositItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestDepositItem* other);

  // implements Message ----------------------------------------------

  RequestDepositItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestDepositItem& from);
  void MergeFrom(const RequestDepositItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ItemLocNum loc_list = 1;
  inline int loc_list_size() const;
  inline void clear_loc_list();
  static const int kLocListFieldNumber = 1;
  inline const ::ItemLocNum& loc_list(int index) const;
  inline ::ItemLocNum* mutable_loc_list(int index);
  inline ::ItemLocNum* add_loc_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemLocNum >&
      loc_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemLocNum >*
      mutable_loc_list();

  // @@protoc_insertion_point(class_scope:Protocol.RequestDepositItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::ItemLocNum > loc_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestDepositItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestWithdrawItem : public ::google::protobuf::MessageLite {
 public:
  RequestWithdrawItem();
  virtual ~RequestWithdrawItem();

  RequestWithdrawItem(const RequestWithdrawItem& from);

  inline RequestWithdrawItem& operator=(const RequestWithdrawItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestWithdrawItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestWithdrawItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestWithdrawItem* other);

  // implements Message ----------------------------------------------

  RequestWithdrawItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestWithdrawItem& from);
  void MergeFrom(const RequestWithdrawItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ItemLocNum loc_list = 1;
  inline int loc_list_size() const;
  inline void clear_loc_list();
  static const int kLocListFieldNumber = 1;
  inline const ::ItemLocNum& loc_list(int index) const;
  inline ::ItemLocNum* mutable_loc_list(int index);
  inline ::ItemLocNum* add_loc_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemLocNum >&
      loc_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemLocNum >*
      mutable_loc_list();

  // @@protoc_insertion_point(class_scope:Protocol.RequestWithdrawItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::ItemLocNum > loc_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestWithdrawItem* default_instance_;
};
// -------------------------------------------------------------------

class CashShopItem : public ::google::protobuf::MessageLite {
 public:
  CashShopItem();
  virtual ~CashShopItem();

  CashShopItem(const CashShopItem& from);

  inline CashShopItem& operator=(const CashShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const CashShopItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CashShopItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CashShopItem* other);

  // implements Message ----------------------------------------------

  CashShopItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CashShopItem& from);
  void MergeFrom(const CashShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cashid = 1;
  inline bool has_cashid() const;
  inline void clear_cashid();
  static const int kCashidFieldNumber = 1;
  inline ::google::protobuf::int32 cashid() const;
  inline void set_cashid(::google::protobuf::int32 value);

  // optional int32 group = 2;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline ::google::protobuf::int32 group() const;
  inline void set_group(::google::protobuf::int32 value);

  // optional int32 recommend = 3;
  inline bool has_recommend() const;
  inline void clear_recommend();
  static const int kRecommendFieldNumber = 3;
  inline ::google::protobuf::int32 recommend() const;
  inline void set_recommend(::google::protobuf::int32 value);

  // optional int32 itemid = 4;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 4;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // optional int32 itemnum = 5 [default = 1];
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemnumFieldNumber = 5;
  inline ::google::protobuf::int32 itemnum() const;
  inline void set_itemnum(::google::protobuf::int32 value);

  // optional int32 original_price = 6;
  inline bool has_original_price() const;
  inline void clear_original_price();
  static const int kOriginalPriceFieldNumber = 6;
  inline ::google::protobuf::int32 original_price() const;
  inline void set_original_price(::google::protobuf::int32 value);

  // optional int32 discount_price = 7;
  inline bool has_discount_price() const;
  inline void clear_discount_price();
  static const int kDiscountPriceFieldNumber = 7;
  inline ::google::protobuf::int32 discount_price() const;
  inline void set_discount_price(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.CashShopItem)
 private:
  inline void set_has_cashid();
  inline void clear_has_cashid();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_recommend();
  inline void clear_has_recommend();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_original_price();
  inline void clear_has_original_price();
  inline void set_has_discount_price();
  inline void clear_has_discount_price();

  ::google::protobuf::int32 cashid_;
  ::google::protobuf::int32 group_;
  ::google::protobuf::int32 recommend_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 itemnum_;
  ::google::protobuf::int32 original_price_;
  ::google::protobuf::int32 discount_price_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static CashShopItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetCashShopItem : public ::google::protobuf::MessageLite {
 public:
  RequestGetCashShopItem();
  virtual ~RequestGetCashShopItem();

  RequestGetCashShopItem(const RequestGetCashShopItem& from);

  inline RequestGetCashShopItem& operator=(const RequestGetCashShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetCashShopItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetCashShopItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetCashShopItem* other);

  // implements Message ----------------------------------------------

  RequestGetCashShopItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetCashShopItem& from);
  void MergeFrom(const RequestGetCashShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetCashShopItem)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestGetCashShopItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetCashShopItem : public ::google::protobuf::MessageLite {
 public:
  ResponseGetCashShopItem();
  virtual ~ResponseGetCashShopItem();

  ResponseGetCashShopItem(const ResponseGetCashShopItem& from);

  inline ResponseGetCashShopItem& operator=(const ResponseGetCashShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetCashShopItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetCashShopItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetCashShopItem* other);

  // implements Message ----------------------------------------------

  ResponseGetCashShopItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetCashShopItem& from);
  void MergeFrom(const ResponseGetCashShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.CashShopItem item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::Protocol::CashShopItem& item_list(int index) const;
  inline ::Protocol::CashShopItem* mutable_item_list(int index);
  inline ::Protocol::CashShopItem* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::CashShopItem >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::CashShopItem >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetCashShopItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::CashShopItem > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetCashShopItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestBuyCashShopItem : public ::google::protobuf::MessageLite {
 public:
  RequestBuyCashShopItem();
  virtual ~RequestBuyCashShopItem();

  RequestBuyCashShopItem(const RequestBuyCashShopItem& from);

  inline RequestBuyCashShopItem& operator=(const RequestBuyCashShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestBuyCashShopItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBuyCashShopItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBuyCashShopItem* other);

  // implements Message ----------------------------------------------

  RequestBuyCashShopItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBuyCashShopItem& from);
  void MergeFrom(const RequestBuyCashShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cashid = 1;
  inline bool has_cashid() const;
  inline void clear_cashid();
  static const int kCashidFieldNumber = 1;
  inline ::google::protobuf::int32 cashid() const;
  inline void set_cashid(::google::protobuf::int32 value);

  // optional int32 num = 2 [default = 1];
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional string charname = 3;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 3;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 gold = 4;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 4;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestBuyCashShopItem)
 private:
  inline void set_has_cashid();
  inline void clear_has_cashid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_gold();
  inline void clear_has_gold();

  ::google::protobuf::int32 cashid_;
  ::google::protobuf::int32 num_;
  ::std::string* charname_;
  ::google::protobuf::int32 gold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestBuyCashShopItem* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBuyCashShopItem : public ::google::protobuf::MessageLite {
 public:
  ResponseBuyCashShopItem();
  virtual ~ResponseBuyCashShopItem();

  ResponseBuyCashShopItem(const ResponseBuyCashShopItem& from);

  inline ResponseBuyCashShopItem& operator=(const ResponseBuyCashShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseBuyCashShopItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseBuyCashShopItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseBuyCashShopItem* other);

  // implements Message ----------------------------------------------

  ResponseBuyCashShopItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseBuyCashShopItem& from);
  void MergeFrom(const ResponseBuyCashShopItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseBuyCashShopItem)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseBuyCashShopItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestRemoteOpenEquipRepair : public ::google::protobuf::MessageLite {
 public:
  RequestRemoteOpenEquipRepair();
  virtual ~RequestRemoteOpenEquipRepair();

  RequestRemoteOpenEquipRepair(const RequestRemoteOpenEquipRepair& from);

  inline RequestRemoteOpenEquipRepair& operator=(const RequestRemoteOpenEquipRepair& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestRemoteOpenEquipRepair& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRemoteOpenEquipRepair* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRemoteOpenEquipRepair* other);

  // implements Message ----------------------------------------------

  RequestRemoteOpenEquipRepair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRemoteOpenEquipRepair& from);
  void MergeFrom(const RequestRemoteOpenEquipRepair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestRemoteOpenEquipRepair)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestRemoteOpenEquipRepair* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetEquipRepairMoney : public ::google::protobuf::MessageLite {
 public:
  RequestGetEquipRepairMoney();
  virtual ~RequestGetEquipRepairMoney();

  RequestGetEquipRepairMoney(const RequestGetEquipRepairMoney& from);

  inline RequestGetEquipRepairMoney& operator=(const RequestGetEquipRepairMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetEquipRepairMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetEquipRepairMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetEquipRepairMoney* other);

  // implements Message ----------------------------------------------

  RequestGetEquipRepairMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetEquipRepairMoney& from);
  void MergeFrom(const RequestGetEquipRepairMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.EquipRepairType repair_type = 1;
  inline bool has_repair_type() const;
  inline void clear_repair_type();
  static const int kRepairTypeFieldNumber = 1;
  inline ::Protocol::EquipRepairType repair_type() const;
  inline void set_repair_type(::Protocol::EquipRepairType value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetEquipRepairMoney)
 private:
  inline void set_has_repair_type();
  inline void clear_has_repair_type();

  int repair_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestGetEquipRepairMoney* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetEquipRepairMoney : public ::google::protobuf::MessageLite {
 public:
  ResponseGetEquipRepairMoney();
  virtual ~ResponseGetEquipRepairMoney();

  ResponseGetEquipRepairMoney(const ResponseGetEquipRepairMoney& from);

  inline ResponseGetEquipRepairMoney& operator=(const ResponseGetEquipRepairMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetEquipRepairMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetEquipRepairMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetEquipRepairMoney* other);

  // implements Message ----------------------------------------------

  ResponseGetEquipRepairMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetEquipRepairMoney& from);
  void MergeFrom(const ResponseGetEquipRepairMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.EquipRepairType repair_type = 1;
  inline bool has_repair_type() const;
  inline void clear_repair_type();
  static const int kRepairTypeFieldNumber = 1;
  inline ::Protocol::EquipRepairType repair_type() const;
  inline void set_repair_type(::Protocol::EquipRepairType value);

  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetEquipRepairMoney)
 private:
  inline void set_has_repair_type();
  inline void clear_has_repair_type();
  inline void set_has_money();
  inline void clear_has_money();

  int repair_type_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetEquipRepairMoney* default_instance_;
};
// -------------------------------------------------------------------

class RequestEquipRepair : public ::google::protobuf::MessageLite {
 public:
  RequestEquipRepair();
  virtual ~RequestEquipRepair();

  RequestEquipRepair(const RequestEquipRepair& from);

  inline RequestEquipRepair& operator=(const RequestEquipRepair& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestEquipRepair& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestEquipRepair* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestEquipRepair* other);

  // implements Message ----------------------------------------------

  RequestEquipRepair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestEquipRepair& from);
  void MergeFrom(const RequestEquipRepair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.EquipRepairType repair_type = 1;
  inline bool has_repair_type() const;
  inline void clear_repair_type();
  static const int kRepairTypeFieldNumber = 1;
  inline ::Protocol::EquipRepairType repair_type() const;
  inline void set_repair_type(::Protocol::EquipRepairType value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestEquipRepair)
 private:
  inline void set_has_repair_type();
  inline void clear_has_repair_type();

  int repair_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestEquipRepair* default_instance_;
};
// -------------------------------------------------------------------

class ResponseEquipRepair : public ::google::protobuf::MessageLite {
 public:
  ResponseEquipRepair();
  virtual ~ResponseEquipRepair();

  ResponseEquipRepair(const ResponseEquipRepair& from);

  inline ResponseEquipRepair& operator=(const ResponseEquipRepair& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseEquipRepair& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseEquipRepair* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseEquipRepair* other);

  // implements Message ----------------------------------------------

  ResponseEquipRepair* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseEquipRepair& from);
  void MergeFrom(const ResponseEquipRepair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional .Protocol.EquipRepairType repair_type = 2;
  inline bool has_repair_type() const;
  inline void clear_repair_type();
  static const int kRepairTypeFieldNumber = 2;
  inline ::Protocol::EquipRepairType repair_type() const;
  inline void set_repair_type(::Protocol::EquipRepairType value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseEquipRepair)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_repair_type();
  inline void clear_has_repair_type();

  ::google::protobuf::int32 result_;
  int repair_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseEquipRepair* default_instance_;
};
// -------------------------------------------------------------------

class RequestEquipGetResetExpiredCost : public ::google::protobuf::MessageLite {
 public:
  RequestEquipGetResetExpiredCost();
  virtual ~RequestEquipGetResetExpiredCost();

  RequestEquipGetResetExpiredCost(const RequestEquipGetResetExpiredCost& from);

  inline RequestEquipGetResetExpiredCost& operator=(const RequestEquipGetResetExpiredCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestEquipGetResetExpiredCost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestEquipGetResetExpiredCost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestEquipGetResetExpiredCost* other);

  // implements Message ----------------------------------------------

  RequestEquipGetResetExpiredCost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestEquipGetResetExpiredCost& from);
  void MergeFrom(const RequestEquipGetResetExpiredCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestEquipGetResetExpiredCost)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();

  ::ItemLoc* loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestEquipGetResetExpiredCost* default_instance_;
};
// -------------------------------------------------------------------

class ResponseEquipGetResetExpiredCost : public ::google::protobuf::MessageLite {
 public:
  ResponseEquipGetResetExpiredCost();
  virtual ~ResponseEquipGetResetExpiredCost();

  ResponseEquipGetResetExpiredCost(const ResponseEquipGetResetExpiredCost& from);

  inline ResponseEquipGetResetExpiredCost& operator=(const ResponseEquipGetResetExpiredCost& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseEquipGetResetExpiredCost& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseEquipGetResetExpiredCost* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseEquipGetResetExpiredCost* other);

  // implements Message ----------------------------------------------

  ResponseEquipGetResetExpiredCost* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseEquipGetResetExpiredCost& from);
  void MergeFrom(const ResponseEquipGetResetExpiredCost& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // optional int32 gold = 2;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 2;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseEquipGetResetExpiredCost)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();
  inline void set_has_gold();
  inline void clear_has_gold();

  ::ItemLoc* loc_;
  ::google::protobuf::int32 gold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseEquipGetResetExpiredCost* default_instance_;
};
// -------------------------------------------------------------------

class RequestEquipResetExpiredTime : public ::google::protobuf::MessageLite {
 public:
  RequestEquipResetExpiredTime();
  virtual ~RequestEquipResetExpiredTime();

  RequestEquipResetExpiredTime(const RequestEquipResetExpiredTime& from);

  inline RequestEquipResetExpiredTime& operator=(const RequestEquipResetExpiredTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestEquipResetExpiredTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestEquipResetExpiredTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestEquipResetExpiredTime* other);

  // implements Message ----------------------------------------------

  RequestEquipResetExpiredTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestEquipResetExpiredTime& from);
  void MergeFrom(const RequestEquipResetExpiredTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // @@protoc_insertion_point(class_scope:Protocol.RequestEquipResetExpiredTime)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();

  ::ItemLoc* loc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestEquipResetExpiredTime* default_instance_;
};
// -------------------------------------------------------------------

class ResponseEquipResetExpiredTime : public ::google::protobuf::MessageLite {
 public:
  ResponseEquipResetExpiredTime();
  virtual ~ResponseEquipResetExpiredTime();

  ResponseEquipResetExpiredTime(const ResponseEquipResetExpiredTime& from);

  inline ResponseEquipResetExpiredTime& operator=(const ResponseEquipResetExpiredTime& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseEquipResetExpiredTime& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseEquipResetExpiredTime* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseEquipResetExpiredTime* other);

  // implements Message ----------------------------------------------

  ResponseEquipResetExpiredTime* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseEquipResetExpiredTime& from);
  void MergeFrom(const ResponseEquipResetExpiredTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLoc loc = 1;
  inline bool has_loc() const;
  inline void clear_loc();
  static const int kLocFieldNumber = 1;
  inline const ::ItemLoc& loc() const;
  inline ::ItemLoc* mutable_loc();
  inline ::ItemLoc* release_loc();
  inline void set_allocated_loc(::ItemLoc* loc);

  // optional int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseEquipResetExpiredTime)
 private:
  inline void set_has_loc();
  inline void clear_has_loc();
  inline void set_has_result();
  inline void clear_has_result();

  ::ItemLoc* loc_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static ResponseEquipResetExpiredTime* default_instance_;
};
// -------------------------------------------------------------------

class RequestBuybackGetItem : public ::google::protobuf::MessageLite {
 public:
  RequestBuybackGetItem();
  virtual ~RequestBuybackGetItem();

  RequestBuybackGetItem(const RequestBuybackGetItem& from);

  inline RequestBuybackGetItem& operator=(const RequestBuybackGetItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestBuybackGetItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBuybackGetItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBuybackGetItem* other);

  // implements Message ----------------------------------------------

  RequestBuybackGetItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBuybackGetItem& from);
  void MergeFrom(const RequestBuybackGetItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestBuybackGetItem)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestBuybackGetItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestBuybackBuyItem : public ::google::protobuf::MessageLite {
 public:
  RequestBuybackBuyItem();
  virtual ~RequestBuybackBuyItem();

  RequestBuybackBuyItem(const RequestBuybackBuyItem& from);

  inline RequestBuybackBuyItem& operator=(const RequestBuybackBuyItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestBuybackBuyItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestBuybackBuyItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestBuybackBuyItem* other);

  // implements Message ----------------------------------------------

  RequestBuybackBuyItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestBuybackBuyItem& from);
  void MergeFrom(const RequestBuybackBuyItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ItemLocNum loc_num = 1;
  inline bool has_loc_num() const;
  inline void clear_loc_num();
  static const int kLocNumFieldNumber = 1;
  inline const ::ItemLocNum& loc_num() const;
  inline ::ItemLocNum* mutable_loc_num();
  inline ::ItemLocNum* release_loc_num();
  inline void set_allocated_loc_num(::ItemLocNum* loc_num);

  // @@protoc_insertion_point(class_scope:Protocol.RequestBuybackBuyItem)
 private:
  inline void set_has_loc_num();
  inline void clear_has_loc_num();

  ::ItemLocNum* loc_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoItem_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoItem_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoItem_2eproto();
  friend void protobuf_ShutdownFile_ProtoItem_2eproto();

  void InitAsDefaultInstance();
  static RequestBuybackBuyItem* default_instance_;
};
// ===================================================================


// ===================================================================

// DropItemInfo

// optional int32 owner_id = 1;
inline bool DropItemInfo::has_owner_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DropItemInfo::set_has_owner_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DropItemInfo::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DropItemInfo::clear_owner_id() {
  owner_id_ = 0;
  clear_has_owner_id();
}
inline ::google::protobuf::int32 DropItemInfo::owner_id() const {
  return owner_id_;
}
inline void DropItemInfo::set_owner_id(::google::protobuf::int32 value) {
  set_has_owner_id();
  owner_id_ = value;
}

// optional int32 item_id = 2;
inline bool DropItemInfo::has_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DropItemInfo::set_has_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DropItemInfo::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DropItemInfo::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 DropItemInfo::item_id() const {
  return item_id_;
}
inline void DropItemInfo::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// optional int32 item_num = 3 [default = 1];
inline bool DropItemInfo::has_item_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DropItemInfo::set_has_item_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DropItemInfo::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DropItemInfo::clear_item_num() {
  item_num_ = 1;
  clear_has_item_num();
}
inline ::google::protobuf::int32 DropItemInfo::item_num() const {
  return item_num_;
}
inline void DropItemInfo::set_item_num(::google::protobuf::int32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional int32 map_x = 4;
inline bool DropItemInfo::has_map_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DropItemInfo::set_has_map_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DropItemInfo::clear_has_map_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DropItemInfo::clear_map_x() {
  map_x_ = 0;
  clear_has_map_x();
}
inline ::google::protobuf::int32 DropItemInfo::map_x() const {
  return map_x_;
}
inline void DropItemInfo::set_map_x(::google::protobuf::int32 value) {
  set_has_map_x();
  map_x_ = value;
}

// optional int32 map_y = 5;
inline bool DropItemInfo::has_map_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DropItemInfo::set_has_map_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DropItemInfo::clear_has_map_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DropItemInfo::clear_map_y() {
  map_y_ = 0;
  clear_has_map_y();
}
inline ::google::protobuf::int32 DropItemInfo::map_y() const {
  return map_y_;
}
inline void DropItemInfo::set_map_y(::google::protobuf::int32 value) {
  set_has_map_y();
  map_y_ = value;
}

// optional int32 color = 6;
inline bool DropItemInfo::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DropItemInfo::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DropItemInfo::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DropItemInfo::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::google::protobuf::int32 DropItemInfo::color() const {
  return color_;
}
inline void DropItemInfo::set_color(::google::protobuf::int32 value) {
  set_has_color();
  color_ = value;
}

// optional int32 quality = 7;
inline bool DropItemInfo::has_quality() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DropItemInfo::set_has_quality() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DropItemInfo::clear_has_quality() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DropItemInfo::clear_quality() {
  quality_ = 0;
  clear_has_quality();
}
inline ::google::protobuf::int32 DropItemInfo::quality() const {
  return quality_;
}
inline void DropItemInfo::set_quality(::google::protobuf::int32 value) {
  set_has_quality();
  quality_ = value;
}

// -------------------------------------------------------------------

// NotifyCreateDropItem

// repeated .Protocol.DropItemInfo item_list = 1;
inline int NotifyCreateDropItem::item_list_size() const {
  return item_list_.size();
}
inline void NotifyCreateDropItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::Protocol::DropItemInfo& NotifyCreateDropItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Protocol::DropItemInfo* NotifyCreateDropItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Protocol::DropItemInfo* NotifyCreateDropItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >&
NotifyCreateDropItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >*
NotifyCreateDropItem::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// NotifyMonsterDropItem

// repeated .Protocol.DropItemInfo item_list = 1;
inline int NotifyMonsterDropItem::item_list_size() const {
  return item_list_.size();
}
inline void NotifyMonsterDropItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::Protocol::DropItemInfo& NotifyMonsterDropItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Protocol::DropItemInfo* NotifyMonsterDropItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Protocol::DropItemInfo* NotifyMonsterDropItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >&
NotifyMonsterDropItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::DropItemInfo >*
NotifyMonsterDropItem::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// RequestCharDropItem

// optional .ItemLoc src_loc = 1;
inline bool RequestCharDropItem::has_src_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCharDropItem::set_has_src_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCharDropItem::clear_has_src_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCharDropItem::clear_src_loc() {
  if (src_loc_ != NULL) src_loc_->::ItemLoc::Clear();
  clear_has_src_loc();
}
inline const ::ItemLoc& RequestCharDropItem::src_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return src_loc_ != NULL ? *src_loc_ : *default_instance().src_loc_;
#else
  return src_loc_ != NULL ? *src_loc_ : *default_instance_->src_loc_;
#endif
}
inline ::ItemLoc* RequestCharDropItem::mutable_src_loc() {
  set_has_src_loc();
  if (src_loc_ == NULL) src_loc_ = new ::ItemLoc;
  return src_loc_;
}
inline ::ItemLoc* RequestCharDropItem::release_src_loc() {
  clear_has_src_loc();
  ::ItemLoc* temp = src_loc_;
  src_loc_ = NULL;
  return temp;
}
inline void RequestCharDropItem::set_allocated_src_loc(::ItemLoc* src_loc) {
  delete src_loc_;
  src_loc_ = src_loc;
  if (src_loc) {
    set_has_src_loc();
  } else {
    clear_has_src_loc();
  }
}

// optional int32 item_num = 2;
inline bool RequestCharDropItem::has_item_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCharDropItem::set_has_item_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCharDropItem::clear_has_item_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCharDropItem::clear_item_num() {
  item_num_ = 0;
  clear_has_item_num();
}
inline ::google::protobuf::int32 RequestCharDropItem::item_num() const {
  return item_num_;
}
inline void RequestCharDropItem::set_item_num(::google::protobuf::int32 value) {
  set_has_item_num();
  item_num_ = value;
}

// optional int32 map_x = 3;
inline bool RequestCharDropItem::has_map_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCharDropItem::set_has_map_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCharDropItem::clear_has_map_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCharDropItem::clear_map_x() {
  map_x_ = 0;
  clear_has_map_x();
}
inline ::google::protobuf::int32 RequestCharDropItem::map_x() const {
  return map_x_;
}
inline void RequestCharDropItem::set_map_x(::google::protobuf::int32 value) {
  set_has_map_x();
  map_x_ = value;
}

// optional int32 map_y = 4;
inline bool RequestCharDropItem::has_map_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestCharDropItem::set_has_map_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestCharDropItem::clear_has_map_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestCharDropItem::clear_map_y() {
  map_y_ = 0;
  clear_has_map_y();
}
inline ::google::protobuf::int32 RequestCharDropItem::map_y() const {
  return map_y_;
}
inline void RequestCharDropItem::set_map_y(::google::protobuf::int32 value) {
  set_has_map_y();
  map_y_ = value;
}

// -------------------------------------------------------------------

// NotifyCharDropItem

// optional .Protocol.DropItemInfo item = 1;
inline bool NotifyCharDropItem::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyCharDropItem::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyCharDropItem::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyCharDropItem::clear_item() {
  if (item_ != NULL) item_->::Protocol::DropItemInfo::Clear();
  clear_has_item();
}
inline const ::Protocol::DropItemInfo& NotifyCharDropItem::item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return item_ != NULL ? *item_ : *default_instance().item_;
#else
  return item_ != NULL ? *item_ : *default_instance_->item_;
#endif
}
inline ::Protocol::DropItemInfo* NotifyCharDropItem::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::Protocol::DropItemInfo;
  return item_;
}
inline ::Protocol::DropItemInfo* NotifyCharDropItem::release_item() {
  clear_has_item();
  ::Protocol::DropItemInfo* temp = item_;
  item_ = NULL;
  return temp;
}
inline void NotifyCharDropItem::set_allocated_item(::Protocol::DropItemInfo* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// NotifyRemoveItemFromMap

// optional int32 map_x = 1;
inline bool NotifyRemoveItemFromMap::has_map_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyRemoveItemFromMap::set_has_map_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyRemoveItemFromMap::clear_has_map_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyRemoveItemFromMap::clear_map_x() {
  map_x_ = 0;
  clear_has_map_x();
}
inline ::google::protobuf::int32 NotifyRemoveItemFromMap::map_x() const {
  return map_x_;
}
inline void NotifyRemoveItemFromMap::set_map_x(::google::protobuf::int32 value) {
  set_has_map_x();
  map_x_ = value;
}

// optional int32 map_y = 2;
inline bool NotifyRemoveItemFromMap::has_map_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyRemoveItemFromMap::set_has_map_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyRemoveItemFromMap::clear_has_map_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyRemoveItemFromMap::clear_map_y() {
  map_y_ = 0;
  clear_has_map_y();
}
inline ::google::protobuf::int32 NotifyRemoveItemFromMap::map_y() const {
  return map_y_;
}
inline void NotifyRemoveItemFromMap::set_map_y(::google::protobuf::int32 value) {
  set_has_map_y();
  map_y_ = value;
}

// -------------------------------------------------------------------

// RequestPickupItem

// optional int32 map_x = 1;
inline bool RequestPickupItem::has_map_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPickupItem::set_has_map_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPickupItem::clear_has_map_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPickupItem::clear_map_x() {
  map_x_ = 0;
  clear_has_map_x();
}
inline ::google::protobuf::int32 RequestPickupItem::map_x() const {
  return map_x_;
}
inline void RequestPickupItem::set_map_x(::google::protobuf::int32 value) {
  set_has_map_x();
  map_x_ = value;
}

// optional int32 map_y = 2;
inline bool RequestPickupItem::has_map_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPickupItem::set_has_map_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPickupItem::clear_has_map_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPickupItem::clear_map_y() {
  map_y_ = 0;
  clear_has_map_y();
}
inline ::google::protobuf::int32 RequestPickupItem::map_y() const {
  return map_y_;
}
inline void RequestPickupItem::set_map_y(::google::protobuf::int32 value) {
  set_has_map_y();
  map_y_ = value;
}

// -------------------------------------------------------------------

// NotifyPickupItem

// optional int32 char_id = 1;
inline bool NotifyPickupItem::has_char_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyPickupItem::set_has_char_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyPickupItem::clear_has_char_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyPickupItem::clear_char_id() {
  char_id_ = 0;
  clear_has_char_id();
}
inline ::google::protobuf::int32 NotifyPickupItem::char_id() const {
  return char_id_;
}
inline void NotifyPickupItem::set_char_id(::google::protobuf::int32 value) {
  set_has_char_id();
  char_id_ = value;
}

// optional int32 map_x = 2;
inline bool NotifyPickupItem::has_map_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyPickupItem::set_has_map_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyPickupItem::clear_has_map_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyPickupItem::clear_map_x() {
  map_x_ = 0;
  clear_has_map_x();
}
inline ::google::protobuf::int32 NotifyPickupItem::map_x() const {
  return map_x_;
}
inline void NotifyPickupItem::set_map_x(::google::protobuf::int32 value) {
  set_has_map_x();
  map_x_ = value;
}

// optional int32 map_y = 3;
inline bool NotifyPickupItem::has_map_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyPickupItem::set_has_map_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyPickupItem::clear_has_map_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyPickupItem::clear_map_y() {
  map_y_ = 0;
  clear_has_map_y();
}
inline ::google::protobuf::int32 NotifyPickupItem::map_y() const {
  return map_y_;
}
inline void NotifyPickupItem::set_map_y(::google::protobuf::int32 value) {
  set_has_map_y();
  map_y_ = value;
}

// optional int32 item_id = 4;
inline bool NotifyPickupItem::has_item_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifyPickupItem::set_has_item_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifyPickupItem::clear_has_item_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifyPickupItem::clear_item_id() {
  item_id_ = 0;
  clear_has_item_id();
}
inline ::google::protobuf::int32 NotifyPickupItem::item_id() const {
  return item_id_;
}
inline void NotifyPickupItem::set_item_id(::google::protobuf::int32 value) {
  set_has_item_id();
  item_id_ = value;
}

// -------------------------------------------------------------------

// RequestEquipItem

// optional .ItemLoc src_loc = 1;
inline bool RequestEquipItem::has_src_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestEquipItem::set_has_src_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestEquipItem::clear_has_src_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestEquipItem::clear_src_loc() {
  if (src_loc_ != NULL) src_loc_->::ItemLoc::Clear();
  clear_has_src_loc();
}
inline const ::ItemLoc& RequestEquipItem::src_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return src_loc_ != NULL ? *src_loc_ : *default_instance().src_loc_;
#else
  return src_loc_ != NULL ? *src_loc_ : *default_instance_->src_loc_;
#endif
}
inline ::ItemLoc* RequestEquipItem::mutable_src_loc() {
  set_has_src_loc();
  if (src_loc_ == NULL) src_loc_ = new ::ItemLoc;
  return src_loc_;
}
inline ::ItemLoc* RequestEquipItem::release_src_loc() {
  clear_has_src_loc();
  ::ItemLoc* temp = src_loc_;
  src_loc_ = NULL;
  return temp;
}
inline void RequestEquipItem::set_allocated_src_loc(::ItemLoc* src_loc) {
  delete src_loc_;
  src_loc_ = src_loc;
  if (src_loc) {
    set_has_src_loc();
  } else {
    clear_has_src_loc();
  }
}

// -------------------------------------------------------------------

// ResponseEquipItem

// optional .ItemLoc src_loc = 1;
inline bool ResponseEquipItem::has_src_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseEquipItem::set_has_src_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseEquipItem::clear_has_src_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseEquipItem::clear_src_loc() {
  if (src_loc_ != NULL) src_loc_->::ItemLoc::Clear();
  clear_has_src_loc();
}
inline const ::ItemLoc& ResponseEquipItem::src_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return src_loc_ != NULL ? *src_loc_ : *default_instance().src_loc_;
#else
  return src_loc_ != NULL ? *src_loc_ : *default_instance_->src_loc_;
#endif
}
inline ::ItemLoc* ResponseEquipItem::mutable_src_loc() {
  set_has_src_loc();
  if (src_loc_ == NULL) src_loc_ = new ::ItemLoc;
  return src_loc_;
}
inline ::ItemLoc* ResponseEquipItem::release_src_loc() {
  clear_has_src_loc();
  ::ItemLoc* temp = src_loc_;
  src_loc_ = NULL;
  return temp;
}
inline void ResponseEquipItem::set_allocated_src_loc(::ItemLoc* src_loc) {
  delete src_loc_;
  src_loc_ = src_loc;
  if (src_loc) {
    set_has_src_loc();
  } else {
    clear_has_src_loc();
  }
}

// optional .ItemLoc dest_loc = 2;
inline bool ResponseEquipItem::has_dest_loc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseEquipItem::set_has_dest_loc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseEquipItem::clear_has_dest_loc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseEquipItem::clear_dest_loc() {
  if (dest_loc_ != NULL) dest_loc_->::ItemLoc::Clear();
  clear_has_dest_loc();
}
inline const ::ItemLoc& ResponseEquipItem::dest_loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dest_loc_ != NULL ? *dest_loc_ : *default_instance().dest_loc_;
#else
  return dest_loc_ != NULL ? *dest_loc_ : *default_instance_->dest_loc_;
#endif
}
inline ::ItemLoc* ResponseEquipItem::mutable_dest_loc() {
  set_has_dest_loc();
  if (dest_loc_ == NULL) dest_loc_ = new ::ItemLoc;
  return dest_loc_;
}
inline ::ItemLoc* ResponseEquipItem::release_dest_loc() {
  clear_has_dest_loc();
  ::ItemLoc* temp = dest_loc_;
  dest_loc_ = NULL;
  return temp;
}
inline void ResponseEquipItem::set_allocated_dest_loc(::ItemLoc* dest_loc) {
  delete dest_loc_;
  dest_loc_ = dest_loc;
  if (dest_loc) {
    set_has_dest_loc();
  } else {
    clear_has_dest_loc();
  }
}

// -------------------------------------------------------------------

// NotifyAddItem

// repeated .ItemLocData item_list = 1;
inline int NotifyAddItem::item_list_size() const {
  return item_list_.size();
}
inline void NotifyAddItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::ItemLocData& NotifyAddItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::ItemLocData* NotifyAddItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::ItemLocData* NotifyAddItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemLocData >&
NotifyAddItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemLocData >*
NotifyAddItem::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// NotifyRemoveItem

// repeated .ItemLoc loc_list = 1;
inline int NotifyRemoveItem::loc_list_size() const {
  return loc_list_.size();
}
inline void NotifyRemoveItem::clear_loc_list() {
  loc_list_.Clear();
}
inline const ::ItemLoc& NotifyRemoveItem::loc_list(int index) const {
  return loc_list_.Get(index);
}
inline ::ItemLoc* NotifyRemoveItem::mutable_loc_list(int index) {
  return loc_list_.Mutable(index);
}
inline ::ItemLoc* NotifyRemoveItem::add_loc_list() {
  return loc_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemLoc >&
NotifyRemoveItem::loc_list() const {
  return loc_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemLoc >*
NotifyRemoveItem::mutable_loc_list() {
  return &loc_list_;
}

// -------------------------------------------------------------------

// NotifyReplaceItem

// repeated .ItemLocData item_list = 1;
inline int NotifyReplaceItem::item_list_size() const {
  return item_list_.size();
}
inline void NotifyReplaceItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::ItemLocData& NotifyReplaceItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::ItemLocData* NotifyReplaceItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::ItemLocData* NotifyReplaceItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemLocData >&
NotifyReplaceItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemLocData >*
NotifyReplaceItem::mutable_item_list() {
  return &item_list_;
}

// optional bool is_new_item = 2 [default = true];
inline bool NotifyReplaceItem::has_is_new_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyReplaceItem::set_has_is_new_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyReplaceItem::clear_has_is_new_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyReplaceItem::clear_is_new_item() {
  is_new_item_ = true;
  clear_has_is_new_item();
}
inline bool NotifyReplaceItem::is_new_item() const {
  return is_new_item_;
}
inline void NotifyReplaceItem::set_is_new_item(bool value) {
  set_has_is_new_item();
  is_new_item_ = value;
}

// -------------------------------------------------------------------

// NotifyRefreshPackage

// optional int32 pkg = 1;
inline bool NotifyRefreshPackage::has_pkg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyRefreshPackage::set_has_pkg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyRefreshPackage::clear_has_pkg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyRefreshPackage::clear_pkg() {
  pkg_ = 0;
  clear_has_pkg();
}
inline ::google::protobuf::int32 NotifyRefreshPackage::pkg() const {
  return pkg_;
}
inline void NotifyRefreshPackage::set_pkg(::google::protobuf::int32 value) {
  set_has_pkg();
  pkg_ = value;
}

// repeated .ItemData item_list = 2;
inline int NotifyRefreshPackage::item_list_size() const {
  return item_list_.size();
}
inline void NotifyRefreshPackage::clear_item_list() {
  item_list_.Clear();
}
inline const ::ItemData& NotifyRefreshPackage::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::ItemData* NotifyRefreshPackage::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::ItemData* NotifyRefreshPackage::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
NotifyRefreshPackage::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
NotifyRefreshPackage::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// RequestUseItem

// optional .ItemLoc loc = 1;
inline bool RequestUseItem::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUseItem::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUseItem::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUseItem::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& RequestUseItem::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* RequestUseItem::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* RequestUseItem::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void RequestUseItem::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// -------------------------------------------------------------------

// ResponseUseItem

// optional .ItemLoc loc = 1;
inline bool ResponseUseItem::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUseItem::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUseItem::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUseItem::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& ResponseUseItem::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* ResponseUseItem::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* ResponseUseItem::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void ResponseUseItem::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// -------------------------------------------------------------------

// RequestGetBuyPackagePrice

// optional int32 pkg = 1;
inline bool RequestGetBuyPackagePrice::has_pkg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetBuyPackagePrice::set_has_pkg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetBuyPackagePrice::clear_has_pkg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetBuyPackagePrice::clear_pkg() {
  pkg_ = 0;
  clear_has_pkg();
}
inline ::google::protobuf::int32 RequestGetBuyPackagePrice::pkg() const {
  return pkg_;
}
inline void RequestGetBuyPackagePrice::set_pkg(::google::protobuf::int32 value) {
  set_has_pkg();
  pkg_ = value;
}

// optional int32 buy_num = 2;
inline bool RequestGetBuyPackagePrice::has_buy_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetBuyPackagePrice::set_has_buy_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetBuyPackagePrice::clear_has_buy_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetBuyPackagePrice::clear_buy_num() {
  buy_num_ = 0;
  clear_has_buy_num();
}
inline ::google::protobuf::int32 RequestGetBuyPackagePrice::buy_num() const {
  return buy_num_;
}
inline void RequestGetBuyPackagePrice::set_buy_num(::google::protobuf::int32 value) {
  set_has_buy_num();
  buy_num_ = value;
}

// -------------------------------------------------------------------

// ResponseGetBuyPackagePrice

// optional int32 pkg = 1;
inline bool ResponseGetBuyPackagePrice::has_pkg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetBuyPackagePrice::set_has_pkg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetBuyPackagePrice::clear_has_pkg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetBuyPackagePrice::clear_pkg() {
  pkg_ = 0;
  clear_has_pkg();
}
inline ::google::protobuf::int32 ResponseGetBuyPackagePrice::pkg() const {
  return pkg_;
}
inline void ResponseGetBuyPackagePrice::set_pkg(::google::protobuf::int32 value) {
  set_has_pkg();
  pkg_ = value;
}

// optional int32 buy_num = 2;
inline bool ResponseGetBuyPackagePrice::has_buy_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGetBuyPackagePrice::set_has_buy_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGetBuyPackagePrice::clear_has_buy_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGetBuyPackagePrice::clear_buy_num() {
  buy_num_ = 0;
  clear_has_buy_num();
}
inline ::google::protobuf::int32 ResponseGetBuyPackagePrice::buy_num() const {
  return buy_num_;
}
inline void ResponseGetBuyPackagePrice::set_buy_num(::google::protobuf::int32 value) {
  set_has_buy_num();
  buy_num_ = value;
}

// optional int32 price = 3;
inline bool ResponseGetBuyPackagePrice::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseGetBuyPackagePrice::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseGetBuyPackagePrice::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseGetBuyPackagePrice::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 ResponseGetBuyPackagePrice::price() const {
  return price_;
}
inline void ResponseGetBuyPackagePrice::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// RequestBuyPackageSize

// optional int32 pkg = 1;
inline bool RequestBuyPackageSize::has_pkg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBuyPackageSize::set_has_pkg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBuyPackageSize::clear_has_pkg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBuyPackageSize::clear_pkg() {
  pkg_ = 0;
  clear_has_pkg();
}
inline ::google::protobuf::int32 RequestBuyPackageSize::pkg() const {
  return pkg_;
}
inline void RequestBuyPackageSize::set_pkg(::google::protobuf::int32 value) {
  set_has_pkg();
  pkg_ = value;
}

// optional int32 buy_num = 2;
inline bool RequestBuyPackageSize::has_buy_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBuyPackageSize::set_has_buy_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBuyPackageSize::clear_has_buy_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBuyPackageSize::clear_buy_num() {
  buy_num_ = 0;
  clear_has_buy_num();
}
inline ::google::protobuf::int32 RequestBuyPackageSize::buy_num() const {
  return buy_num_;
}
inline void RequestBuyPackageSize::set_buy_num(::google::protobuf::int32 value) {
  set_has_buy_num();
  buy_num_ = value;
}

// -------------------------------------------------------------------

// ResponseBuyPackageSize

// optional int32 result = 1;
inline bool ResponseBuyPackageSize::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBuyPackageSize::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBuyPackageSize::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBuyPackageSize::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseBuyPackageSize::result() const {
  return result_;
}
inline void ResponseBuyPackageSize::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 pkg = 2;
inline bool ResponseBuyPackageSize::has_pkg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseBuyPackageSize::set_has_pkg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseBuyPackageSize::clear_has_pkg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseBuyPackageSize::clear_pkg() {
  pkg_ = 0;
  clear_has_pkg();
}
inline ::google::protobuf::int32 ResponseBuyPackageSize::pkg() const {
  return pkg_;
}
inline void ResponseBuyPackageSize::set_pkg(::google::protobuf::int32 value) {
  set_has_pkg();
  pkg_ = value;
}

// optional int32 cur_num = 3;
inline bool ResponseBuyPackageSize::has_cur_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseBuyPackageSize::set_has_cur_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseBuyPackageSize::clear_has_cur_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseBuyPackageSize::clear_cur_num() {
  cur_num_ = 0;
  clear_has_cur_num();
}
inline ::google::protobuf::int32 ResponseBuyPackageSize::cur_num() const {
  return cur_num_;
}
inline void ResponseBuyPackageSize::set_cur_num(::google::protobuf::int32 value) {
  set_has_cur_num();
  cur_num_ = value;
}

// -------------------------------------------------------------------

// RequestSortPackage

// optional int32 pkg = 1;
inline bool RequestSortPackage::has_pkg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSortPackage::set_has_pkg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSortPackage::clear_has_pkg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSortPackage::clear_pkg() {
  pkg_ = 0;
  clear_has_pkg();
}
inline ::google::protobuf::int32 RequestSortPackage::pkg() const {
  return pkg_;
}
inline void RequestSortPackage::set_pkg(::google::protobuf::int32 value) {
  set_has_pkg();
  pkg_ = value;
}

// -------------------------------------------------------------------

// StoreItem

// optional int32 itemid = 1;
inline bool StoreItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StoreItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StoreItem::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 StoreItem::itemid() const {
  return itemid_;
}
inline void StoreItem::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 price = 2;
inline bool StoreItem::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreItem::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StoreItem::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StoreItem::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 StoreItem::price() const {
  return price_;
}
inline void StoreItem::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// RequestGetStoreItem

// optional int32 npcid = 1;
inline bool RequestGetStoreItem::has_npcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetStoreItem::set_has_npcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetStoreItem::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetStoreItem::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 RequestGetStoreItem::npcid() const {
  return npcid_;
}
inline void RequestGetStoreItem::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
}

// -------------------------------------------------------------------

// ResponseGetStoreItem

// optional .Protocol.StoreCurrencyType type = 1;
inline bool ResponseGetStoreItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetStoreItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetStoreItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetStoreItem::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::Protocol::StoreCurrencyType ResponseGetStoreItem::type() const {
  return static_cast< ::Protocol::StoreCurrencyType >(type_);
}
inline void ResponseGetStoreItem::set_type(::Protocol::StoreCurrencyType value) {
  assert(::Protocol::StoreCurrencyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .Protocol.StoreItem item_list = 2;
inline int ResponseGetStoreItem::item_list_size() const {
  return item_list_.size();
}
inline void ResponseGetStoreItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::Protocol::StoreItem& ResponseGetStoreItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Protocol::StoreItem* ResponseGetStoreItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Protocol::StoreItem* ResponseGetStoreItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::StoreItem >&
ResponseGetStoreItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::StoreItem >*
ResponseGetStoreItem::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// RequestBuyStoreItem

// optional int32 itemid = 1;
inline bool RequestBuyStoreItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBuyStoreItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBuyStoreItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBuyStoreItem::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 RequestBuyStoreItem::itemid() const {
  return itemid_;
}
inline void RequestBuyStoreItem::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 num = 2;
inline bool RequestBuyStoreItem::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBuyStoreItem::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBuyStoreItem::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBuyStoreItem::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 RequestBuyStoreItem::num() const {
  return num_;
}
inline void RequestBuyStoreItem::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional int32 money = 3;
inline bool RequestBuyStoreItem::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestBuyStoreItem::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestBuyStoreItem::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestBuyStoreItem::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 RequestBuyStoreItem::money() const {
  return money_;
}
inline void RequestBuyStoreItem::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// ResponseBuyStoreItem

// optional int32 result = 1;
inline bool ResponseBuyStoreItem::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBuyStoreItem::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBuyStoreItem::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBuyStoreItem::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseBuyStoreItem::result() const {
  return result_;
}
inline void ResponseBuyStoreItem::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// SellItemInfo

// optional .ItemLoc loc = 1;
inline bool SellItemInfo::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SellItemInfo::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SellItemInfo::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SellItemInfo::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& SellItemInfo::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* SellItemInfo::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* SellItemInfo::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void SellItemInfo::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// optional int32 num = 2;
inline bool SellItemInfo::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SellItemInfo::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SellItemInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SellItemInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 SellItemInfo::num() const {
  return num_;
}
inline void SellItemInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// RequestSellItem

// repeated .Protocol.SellItemInfo item_list = 1;
inline int RequestSellItem::item_list_size() const {
  return item_list_.size();
}
inline void RequestSellItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::Protocol::SellItemInfo& RequestSellItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Protocol::SellItemInfo* RequestSellItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Protocol::SellItemInfo* RequestSellItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::SellItemInfo >&
RequestSellItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::SellItemInfo >*
RequestSellItem::mutable_item_list() {
  return &item_list_;
}

// optional int32 money = 2;
inline bool RequestSellItem::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSellItem::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSellItem::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSellItem::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 RequestSellItem::money() const {
  return money_;
}
inline void RequestSellItem::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// ResponseSellItem

// optional int32 result = 1;
inline bool ResponseSellItem::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseSellItem::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseSellItem::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseSellItem::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseSellItem::result() const {
  return result_;
}
inline void ResponseSellItem::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestGetSafeItems

// optional int32 reserve = 1;
inline bool RequestGetSafeItems::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetSafeItems::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetSafeItems::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetSafeItems::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestGetSafeItems::reserve() const {
  return reserve_;
}
inline void RequestGetSafeItems::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// RequestDepositMoney

// optional uint64 money = 1;
inline bool RequestDepositMoney::has_money() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestDepositMoney::set_has_money() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestDepositMoney::clear_has_money() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestDepositMoney::clear_money() {
  money_ = GOOGLE_ULONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::uint64 RequestDepositMoney::money() const {
  return money_;
}
inline void RequestDepositMoney::set_money(::google::protobuf::uint64 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// RequestWithdrawMoney

// optional uint64 money = 1;
inline bool RequestWithdrawMoney::has_money() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestWithdrawMoney::set_has_money() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestWithdrawMoney::clear_has_money() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestWithdrawMoney::clear_money() {
  money_ = GOOGLE_ULONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::uint64 RequestWithdrawMoney::money() const {
  return money_;
}
inline void RequestWithdrawMoney::set_money(::google::protobuf::uint64 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// RequestDepositItem

// repeated .ItemLocNum loc_list = 1;
inline int RequestDepositItem::loc_list_size() const {
  return loc_list_.size();
}
inline void RequestDepositItem::clear_loc_list() {
  loc_list_.Clear();
}
inline const ::ItemLocNum& RequestDepositItem::loc_list(int index) const {
  return loc_list_.Get(index);
}
inline ::ItemLocNum* RequestDepositItem::mutable_loc_list(int index) {
  return loc_list_.Mutable(index);
}
inline ::ItemLocNum* RequestDepositItem::add_loc_list() {
  return loc_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemLocNum >&
RequestDepositItem::loc_list() const {
  return loc_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemLocNum >*
RequestDepositItem::mutable_loc_list() {
  return &loc_list_;
}

// -------------------------------------------------------------------

// RequestWithdrawItem

// repeated .ItemLocNum loc_list = 1;
inline int RequestWithdrawItem::loc_list_size() const {
  return loc_list_.size();
}
inline void RequestWithdrawItem::clear_loc_list() {
  loc_list_.Clear();
}
inline const ::ItemLocNum& RequestWithdrawItem::loc_list(int index) const {
  return loc_list_.Get(index);
}
inline ::ItemLocNum* RequestWithdrawItem::mutable_loc_list(int index) {
  return loc_list_.Mutable(index);
}
inline ::ItemLocNum* RequestWithdrawItem::add_loc_list() {
  return loc_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemLocNum >&
RequestWithdrawItem::loc_list() const {
  return loc_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemLocNum >*
RequestWithdrawItem::mutable_loc_list() {
  return &loc_list_;
}

// -------------------------------------------------------------------

// CashShopItem

// optional int32 cashid = 1;
inline bool CashShopItem::has_cashid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CashShopItem::set_has_cashid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CashShopItem::clear_has_cashid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CashShopItem::clear_cashid() {
  cashid_ = 0;
  clear_has_cashid();
}
inline ::google::protobuf::int32 CashShopItem::cashid() const {
  return cashid_;
}
inline void CashShopItem::set_cashid(::google::protobuf::int32 value) {
  set_has_cashid();
  cashid_ = value;
}

// optional int32 group = 2;
inline bool CashShopItem::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CashShopItem::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CashShopItem::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CashShopItem::clear_group() {
  group_ = 0;
  clear_has_group();
}
inline ::google::protobuf::int32 CashShopItem::group() const {
  return group_;
}
inline void CashShopItem::set_group(::google::protobuf::int32 value) {
  set_has_group();
  group_ = value;
}

// optional int32 recommend = 3;
inline bool CashShopItem::has_recommend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CashShopItem::set_has_recommend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CashShopItem::clear_has_recommend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CashShopItem::clear_recommend() {
  recommend_ = 0;
  clear_has_recommend();
}
inline ::google::protobuf::int32 CashShopItem::recommend() const {
  return recommend_;
}
inline void CashShopItem::set_recommend(::google::protobuf::int32 value) {
  set_has_recommend();
  recommend_ = value;
}

// optional int32 itemid = 4;
inline bool CashShopItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CashShopItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CashShopItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CashShopItem::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 CashShopItem::itemid() const {
  return itemid_;
}
inline void CashShopItem::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 itemnum = 5 [default = 1];
inline bool CashShopItem::has_itemnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CashShopItem::set_has_itemnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CashShopItem::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CashShopItem::clear_itemnum() {
  itemnum_ = 1;
  clear_has_itemnum();
}
inline ::google::protobuf::int32 CashShopItem::itemnum() const {
  return itemnum_;
}
inline void CashShopItem::set_itemnum(::google::protobuf::int32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional int32 original_price = 6;
inline bool CashShopItem::has_original_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CashShopItem::set_has_original_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CashShopItem::clear_has_original_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CashShopItem::clear_original_price() {
  original_price_ = 0;
  clear_has_original_price();
}
inline ::google::protobuf::int32 CashShopItem::original_price() const {
  return original_price_;
}
inline void CashShopItem::set_original_price(::google::protobuf::int32 value) {
  set_has_original_price();
  original_price_ = value;
}

// optional int32 discount_price = 7;
inline bool CashShopItem::has_discount_price() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CashShopItem::set_has_discount_price() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CashShopItem::clear_has_discount_price() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CashShopItem::clear_discount_price() {
  discount_price_ = 0;
  clear_has_discount_price();
}
inline ::google::protobuf::int32 CashShopItem::discount_price() const {
  return discount_price_;
}
inline void CashShopItem::set_discount_price(::google::protobuf::int32 value) {
  set_has_discount_price();
  discount_price_ = value;
}

// -------------------------------------------------------------------

// RequestGetCashShopItem

// optional int32 reserve = 1;
inline bool RequestGetCashShopItem::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetCashShopItem::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetCashShopItem::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetCashShopItem::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestGetCashShopItem::reserve() const {
  return reserve_;
}
inline void RequestGetCashShopItem::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// ResponseGetCashShopItem

// repeated .Protocol.CashShopItem item_list = 1;
inline int ResponseGetCashShopItem::item_list_size() const {
  return item_list_.size();
}
inline void ResponseGetCashShopItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::Protocol::CashShopItem& ResponseGetCashShopItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::Protocol::CashShopItem* ResponseGetCashShopItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::Protocol::CashShopItem* ResponseGetCashShopItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::CashShopItem >&
ResponseGetCashShopItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::CashShopItem >*
ResponseGetCashShopItem::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// RequestBuyCashShopItem

// optional int32 cashid = 1;
inline bool RequestBuyCashShopItem::has_cashid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBuyCashShopItem::set_has_cashid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBuyCashShopItem::clear_has_cashid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBuyCashShopItem::clear_cashid() {
  cashid_ = 0;
  clear_has_cashid();
}
inline ::google::protobuf::int32 RequestBuyCashShopItem::cashid() const {
  return cashid_;
}
inline void RequestBuyCashShopItem::set_cashid(::google::protobuf::int32 value) {
  set_has_cashid();
  cashid_ = value;
}

// optional int32 num = 2 [default = 1];
inline bool RequestBuyCashShopItem::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBuyCashShopItem::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBuyCashShopItem::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBuyCashShopItem::clear_num() {
  num_ = 1;
  clear_has_num();
}
inline ::google::protobuf::int32 RequestBuyCashShopItem::num() const {
  return num_;
}
inline void RequestBuyCashShopItem::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional string charname = 3;
inline bool RequestBuyCashShopItem::has_charname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestBuyCashShopItem::set_has_charname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestBuyCashShopItem::clear_has_charname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestBuyCashShopItem::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& RequestBuyCashShopItem::charname() const {
  return *charname_;
}
inline void RequestBuyCashShopItem::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void RequestBuyCashShopItem::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void RequestBuyCashShopItem::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBuyCashShopItem::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* RequestBuyCashShopItem::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestBuyCashShopItem::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gold = 4;
inline bool RequestBuyCashShopItem::has_gold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestBuyCashShopItem::set_has_gold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestBuyCashShopItem::clear_has_gold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestBuyCashShopItem::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 RequestBuyCashShopItem::gold() const {
  return gold_;
}
inline void RequestBuyCashShopItem::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// -------------------------------------------------------------------

// ResponseBuyCashShopItem

// optional int32 result = 1;
inline bool ResponseBuyCashShopItem::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBuyCashShopItem::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBuyCashShopItem::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBuyCashShopItem::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseBuyCashShopItem::result() const {
  return result_;
}
inline void ResponseBuyCashShopItem::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestRemoteOpenEquipRepair

// optional int32 reserve = 1;
inline bool RequestRemoteOpenEquipRepair::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRemoteOpenEquipRepair::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRemoteOpenEquipRepair::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRemoteOpenEquipRepair::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestRemoteOpenEquipRepair::reserve() const {
  return reserve_;
}
inline void RequestRemoteOpenEquipRepair::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// RequestGetEquipRepairMoney

// optional .Protocol.EquipRepairType repair_type = 1;
inline bool RequestGetEquipRepairMoney::has_repair_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetEquipRepairMoney::set_has_repair_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetEquipRepairMoney::clear_has_repair_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetEquipRepairMoney::clear_repair_type() {
  repair_type_ = 0;
  clear_has_repair_type();
}
inline ::Protocol::EquipRepairType RequestGetEquipRepairMoney::repair_type() const {
  return static_cast< ::Protocol::EquipRepairType >(repair_type_);
}
inline void RequestGetEquipRepairMoney::set_repair_type(::Protocol::EquipRepairType value) {
  assert(::Protocol::EquipRepairType_IsValid(value));
  set_has_repair_type();
  repair_type_ = value;
}

// -------------------------------------------------------------------

// ResponseGetEquipRepairMoney

// optional .Protocol.EquipRepairType repair_type = 1;
inline bool ResponseGetEquipRepairMoney::has_repair_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetEquipRepairMoney::set_has_repair_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetEquipRepairMoney::clear_has_repair_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetEquipRepairMoney::clear_repair_type() {
  repair_type_ = 0;
  clear_has_repair_type();
}
inline ::Protocol::EquipRepairType ResponseGetEquipRepairMoney::repair_type() const {
  return static_cast< ::Protocol::EquipRepairType >(repair_type_);
}
inline void ResponseGetEquipRepairMoney::set_repair_type(::Protocol::EquipRepairType value) {
  assert(::Protocol::EquipRepairType_IsValid(value));
  set_has_repair_type();
  repair_type_ = value;
}

// optional int32 money = 2;
inline bool ResponseGetEquipRepairMoney::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGetEquipRepairMoney::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGetEquipRepairMoney::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGetEquipRepairMoney::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 ResponseGetEquipRepairMoney::money() const {
  return money_;
}
inline void ResponseGetEquipRepairMoney::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// RequestEquipRepair

// optional .Protocol.EquipRepairType repair_type = 1;
inline bool RequestEquipRepair::has_repair_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestEquipRepair::set_has_repair_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestEquipRepair::clear_has_repair_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestEquipRepair::clear_repair_type() {
  repair_type_ = 0;
  clear_has_repair_type();
}
inline ::Protocol::EquipRepairType RequestEquipRepair::repair_type() const {
  return static_cast< ::Protocol::EquipRepairType >(repair_type_);
}
inline void RequestEquipRepair::set_repair_type(::Protocol::EquipRepairType value) {
  assert(::Protocol::EquipRepairType_IsValid(value));
  set_has_repair_type();
  repair_type_ = value;
}

// -------------------------------------------------------------------

// ResponseEquipRepair

// optional int32 result = 1;
inline bool ResponseEquipRepair::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseEquipRepair::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseEquipRepair::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseEquipRepair::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseEquipRepair::result() const {
  return result_;
}
inline void ResponseEquipRepair::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional .Protocol.EquipRepairType repair_type = 2;
inline bool ResponseEquipRepair::has_repair_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseEquipRepair::set_has_repair_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseEquipRepair::clear_has_repair_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseEquipRepair::clear_repair_type() {
  repair_type_ = 0;
  clear_has_repair_type();
}
inline ::Protocol::EquipRepairType ResponseEquipRepair::repair_type() const {
  return static_cast< ::Protocol::EquipRepairType >(repair_type_);
}
inline void ResponseEquipRepair::set_repair_type(::Protocol::EquipRepairType value) {
  assert(::Protocol::EquipRepairType_IsValid(value));
  set_has_repair_type();
  repair_type_ = value;
}

// -------------------------------------------------------------------

// RequestEquipGetResetExpiredCost

// optional .ItemLoc loc = 1;
inline bool RequestEquipGetResetExpiredCost::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestEquipGetResetExpiredCost::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestEquipGetResetExpiredCost::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestEquipGetResetExpiredCost::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& RequestEquipGetResetExpiredCost::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* RequestEquipGetResetExpiredCost::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* RequestEquipGetResetExpiredCost::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void RequestEquipGetResetExpiredCost::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// -------------------------------------------------------------------

// ResponseEquipGetResetExpiredCost

// optional .ItemLoc loc = 1;
inline bool ResponseEquipGetResetExpiredCost::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseEquipGetResetExpiredCost::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseEquipGetResetExpiredCost::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseEquipGetResetExpiredCost::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& ResponseEquipGetResetExpiredCost::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* ResponseEquipGetResetExpiredCost::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* ResponseEquipGetResetExpiredCost::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void ResponseEquipGetResetExpiredCost::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// optional int32 gold = 2;
inline bool ResponseEquipGetResetExpiredCost::has_gold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseEquipGetResetExpiredCost::set_has_gold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseEquipGetResetExpiredCost::clear_has_gold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseEquipGetResetExpiredCost::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 ResponseEquipGetResetExpiredCost::gold() const {
  return gold_;
}
inline void ResponseEquipGetResetExpiredCost::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// -------------------------------------------------------------------

// RequestEquipResetExpiredTime

// optional .ItemLoc loc = 1;
inline bool RequestEquipResetExpiredTime::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestEquipResetExpiredTime::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestEquipResetExpiredTime::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestEquipResetExpiredTime::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& RequestEquipResetExpiredTime::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* RequestEquipResetExpiredTime::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* RequestEquipResetExpiredTime::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void RequestEquipResetExpiredTime::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// -------------------------------------------------------------------

// ResponseEquipResetExpiredTime

// optional .ItemLoc loc = 1;
inline bool ResponseEquipResetExpiredTime::has_loc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseEquipResetExpiredTime::set_has_loc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseEquipResetExpiredTime::clear_has_loc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseEquipResetExpiredTime::clear_loc() {
  if (loc_ != NULL) loc_->::ItemLoc::Clear();
  clear_has_loc();
}
inline const ::ItemLoc& ResponseEquipResetExpiredTime::loc() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_ != NULL ? *loc_ : *default_instance().loc_;
#else
  return loc_ != NULL ? *loc_ : *default_instance_->loc_;
#endif
}
inline ::ItemLoc* ResponseEquipResetExpiredTime::mutable_loc() {
  set_has_loc();
  if (loc_ == NULL) loc_ = new ::ItemLoc;
  return loc_;
}
inline ::ItemLoc* ResponseEquipResetExpiredTime::release_loc() {
  clear_has_loc();
  ::ItemLoc* temp = loc_;
  loc_ = NULL;
  return temp;
}
inline void ResponseEquipResetExpiredTime::set_allocated_loc(::ItemLoc* loc) {
  delete loc_;
  loc_ = loc;
  if (loc) {
    set_has_loc();
  } else {
    clear_has_loc();
  }
}

// optional int32 result = 2;
inline bool ResponseEquipResetExpiredTime::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseEquipResetExpiredTime::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseEquipResetExpiredTime::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseEquipResetExpiredTime::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseEquipResetExpiredTime::result() const {
  return result_;
}
inline void ResponseEquipResetExpiredTime::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestBuybackGetItem

// optional int32 reserve = 1;
inline bool RequestBuybackGetItem::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBuybackGetItem::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBuybackGetItem::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBuybackGetItem::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestBuybackGetItem::reserve() const {
  return reserve_;
}
inline void RequestBuybackGetItem::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// RequestBuybackBuyItem

// optional .ItemLocNum loc_num = 1;
inline bool RequestBuybackBuyItem::has_loc_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBuybackBuyItem::set_has_loc_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBuybackBuyItem::clear_has_loc_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBuybackBuyItem::clear_loc_num() {
  if (loc_num_ != NULL) loc_num_->::ItemLocNum::Clear();
  clear_has_loc_num();
}
inline const ::ItemLocNum& RequestBuybackBuyItem::loc_num() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loc_num_ != NULL ? *loc_num_ : *default_instance().loc_num_;
#else
  return loc_num_ != NULL ? *loc_num_ : *default_instance_->loc_num_;
#endif
}
inline ::ItemLocNum* RequestBuybackBuyItem::mutable_loc_num() {
  set_has_loc_num();
  if (loc_num_ == NULL) loc_num_ = new ::ItemLocNum;
  return loc_num_;
}
inline ::ItemLocNum* RequestBuybackBuyItem::release_loc_num() {
  clear_has_loc_num();
  ::ItemLocNum* temp = loc_num_;
  loc_num_ = NULL;
  return temp;
}
inline void RequestBuybackBuyItem::set_allocated_loc_num(::ItemLocNum* loc_num) {
  delete loc_num_;
  loc_num_ = loc_num;
  if (loc_num) {
    set_has_loc_num();
  } else {
    clear_has_loc_num();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoItem_2eproto__INCLUDED
