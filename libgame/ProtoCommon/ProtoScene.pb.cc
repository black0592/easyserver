// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoScene.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoScene.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace Protocol {

void protobuf_ShutdownFile_ProtoScene_2eproto() {
  delete NotifyCreateChar::default_instance_;
  delete NotifyRemoveChar::default_instance_;
  delete MsgCharMove::default_instance_;
  delete MsgCharStopMove::default_instance_;
  delete NotifyCreateMonster::default_instance_;
  delete NotifyRemoveMonster::default_instance_;
  delete NotifyMonsterMove::default_instance_;
  delete NotifyMonsterStopMove::default_instance_;
  delete NotifyCreateNpc::default_instance_;
  delete NotifyRemoveNpc::default_instance_;
  delete NotifyNpcMove::default_instance_;
  delete NotifyNpcStopMove::default_instance_;
  delete NotifyMonsterDead::default_instance_;
  delete NotifyMonsterDisappear::default_instance_;
  delete NotifyMonsterRevive::default_instance_;
  delete NotifyCharDead::default_instance_;
  delete NotifyCharDisappear::default_instance_;
  delete RequestCharRevive::default_instance_;
  delete NotifyCharRevive::default_instance_;
  delete NotifyCharLevel::default_instance_;
  delete JumpPoint::default_instance_;
  delete NotifyCreateJumpPoint::default_instance_;
  delete NotifyCharChangeMap::default_instance_;
  delete NotifySceneUpdateCharProperty::default_instance_;
  delete NotifySceneUpdateMonsterProperty::default_instance_;
  delete BigMapNpcInfo::default_instance_;
  delete BigMapMonsterInfo::default_instance_;
  delete BigMapJumpPointInfo::default_instance_;
  delete RequestGetBigMapInfo::default_instance_;
  delete ResponseGetBigMapInfo::default_instance_;
  delete RequestGetGoHomeMoney::default_instance_;
  delete ResponseGetGoHomeMoney::default_instance_;
  delete RequestGoHome::default_instance_;
  delete NotifyDuplicateVote::default_instance_;
  delete RequestDuplicateVoteResult::default_instance_;
  delete RequestDuplicateExit::default_instance_;
  delete RequestCrossMapPath::default_instance_;
  delete ResponseCrossMapPath::default_instance_;
  delete ResponseCrossMapPath_PathNode::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoScene_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoScene_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoGameData_2eproto();
  NotifyCreateChar::default_instance_ = new NotifyCreateChar();
  NotifyRemoveChar::default_instance_ = new NotifyRemoveChar();
  MsgCharMove::default_instance_ = new MsgCharMove();
  MsgCharStopMove::default_instance_ = new MsgCharStopMove();
  NotifyCreateMonster::default_instance_ = new NotifyCreateMonster();
  NotifyRemoveMonster::default_instance_ = new NotifyRemoveMonster();
  NotifyMonsterMove::default_instance_ = new NotifyMonsterMove();
  NotifyMonsterStopMove::default_instance_ = new NotifyMonsterStopMove();
  NotifyCreateNpc::default_instance_ = new NotifyCreateNpc();
  NotifyRemoveNpc::default_instance_ = new NotifyRemoveNpc();
  NotifyNpcMove::default_instance_ = new NotifyNpcMove();
  NotifyNpcStopMove::default_instance_ = new NotifyNpcStopMove();
  NotifyMonsterDead::default_instance_ = new NotifyMonsterDead();
  NotifyMonsterDisappear::default_instance_ = new NotifyMonsterDisappear();
  NotifyMonsterRevive::default_instance_ = new NotifyMonsterRevive();
  NotifyCharDead::default_instance_ = new NotifyCharDead();
  NotifyCharDisappear::default_instance_ = new NotifyCharDisappear();
  RequestCharRevive::default_instance_ = new RequestCharRevive();
  NotifyCharRevive::default_instance_ = new NotifyCharRevive();
  NotifyCharLevel::default_instance_ = new NotifyCharLevel();
  JumpPoint::default_instance_ = new JumpPoint();
  NotifyCreateJumpPoint::default_instance_ = new NotifyCreateJumpPoint();
  NotifyCharChangeMap::default_instance_ = new NotifyCharChangeMap();
  NotifySceneUpdateCharProperty::default_instance_ = new NotifySceneUpdateCharProperty();
  NotifySceneUpdateMonsterProperty::default_instance_ = new NotifySceneUpdateMonsterProperty();
  BigMapNpcInfo::default_instance_ = new BigMapNpcInfo();
  BigMapMonsterInfo::default_instance_ = new BigMapMonsterInfo();
  BigMapJumpPointInfo::default_instance_ = new BigMapJumpPointInfo();
  RequestGetBigMapInfo::default_instance_ = new RequestGetBigMapInfo();
  ResponseGetBigMapInfo::default_instance_ = new ResponseGetBigMapInfo();
  RequestGetGoHomeMoney::default_instance_ = new RequestGetGoHomeMoney();
  ResponseGetGoHomeMoney::default_instance_ = new ResponseGetGoHomeMoney();
  RequestGoHome::default_instance_ = new RequestGoHome();
  NotifyDuplicateVote::default_instance_ = new NotifyDuplicateVote();
  RequestDuplicateVoteResult::default_instance_ = new RequestDuplicateVoteResult();
  RequestDuplicateExit::default_instance_ = new RequestDuplicateExit();
  RequestCrossMapPath::default_instance_ = new RequestCrossMapPath();
  ResponseCrossMapPath::default_instance_ = new ResponseCrossMapPath();
  ResponseCrossMapPath_PathNode::default_instance_ = new ResponseCrossMapPath_PathNode();
  NotifyCreateChar::default_instance_->InitAsDefaultInstance();
  NotifyRemoveChar::default_instance_->InitAsDefaultInstance();
  MsgCharMove::default_instance_->InitAsDefaultInstance();
  MsgCharStopMove::default_instance_->InitAsDefaultInstance();
  NotifyCreateMonster::default_instance_->InitAsDefaultInstance();
  NotifyRemoveMonster::default_instance_->InitAsDefaultInstance();
  NotifyMonsterMove::default_instance_->InitAsDefaultInstance();
  NotifyMonsterStopMove::default_instance_->InitAsDefaultInstance();
  NotifyCreateNpc::default_instance_->InitAsDefaultInstance();
  NotifyRemoveNpc::default_instance_->InitAsDefaultInstance();
  NotifyNpcMove::default_instance_->InitAsDefaultInstance();
  NotifyNpcStopMove::default_instance_->InitAsDefaultInstance();
  NotifyMonsterDead::default_instance_->InitAsDefaultInstance();
  NotifyMonsterDisappear::default_instance_->InitAsDefaultInstance();
  NotifyMonsterRevive::default_instance_->InitAsDefaultInstance();
  NotifyCharDead::default_instance_->InitAsDefaultInstance();
  NotifyCharDisappear::default_instance_->InitAsDefaultInstance();
  RequestCharRevive::default_instance_->InitAsDefaultInstance();
  NotifyCharRevive::default_instance_->InitAsDefaultInstance();
  NotifyCharLevel::default_instance_->InitAsDefaultInstance();
  JumpPoint::default_instance_->InitAsDefaultInstance();
  NotifyCreateJumpPoint::default_instance_->InitAsDefaultInstance();
  NotifyCharChangeMap::default_instance_->InitAsDefaultInstance();
  NotifySceneUpdateCharProperty::default_instance_->InitAsDefaultInstance();
  NotifySceneUpdateMonsterProperty::default_instance_->InitAsDefaultInstance();
  BigMapNpcInfo::default_instance_->InitAsDefaultInstance();
  BigMapMonsterInfo::default_instance_->InitAsDefaultInstance();
  BigMapJumpPointInfo::default_instance_->InitAsDefaultInstance();
  RequestGetBigMapInfo::default_instance_->InitAsDefaultInstance();
  ResponseGetBigMapInfo::default_instance_->InitAsDefaultInstance();
  RequestGetGoHomeMoney::default_instance_->InitAsDefaultInstance();
  ResponseGetGoHomeMoney::default_instance_->InitAsDefaultInstance();
  RequestGoHome::default_instance_->InitAsDefaultInstance();
  NotifyDuplicateVote::default_instance_->InitAsDefaultInstance();
  RequestDuplicateVoteResult::default_instance_->InitAsDefaultInstance();
  RequestDuplicateExit::default_instance_->InitAsDefaultInstance();
  RequestCrossMapPath::default_instance_->InitAsDefaultInstance();
  ResponseCrossMapPath::default_instance_->InitAsDefaultInstance();
  ResponseCrossMapPath_PathNode::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoScene_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoScene_2eproto_once_);
void protobuf_AddDesc_ProtoScene_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoScene_2eproto_once_,
                 &protobuf_AddDesc_ProtoScene_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoScene_2eproto {
  StaticDescriptorInitializer_ProtoScene_2eproto() {
    protobuf_AddDesc_ProtoScene_2eproto();
  }
} static_descriptor_initializer_ProtoScene_2eproto_;
#endif
bool SceneOpCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 10:
    case 11:
    case 12:
    case 13:
    case 20:
    case 21:
    case 22:
    case 23:
    case 30:
    case 31:
    case 32:
    case 40:
    case 41:
    case 42:
    case 43:
    case 50:
    case 51:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
      return true;
    default:
      return false;
  }
}

bool ReviveType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCreateChar::kCharListFieldNumber;
#endif  // !_MSC_VER

NotifyCreateChar::NotifyCreateChar()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCreateChar::InitAsDefaultInstance() {
}

NotifyCreateChar::NotifyCreateChar(const NotifyCreateChar& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCreateChar::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCreateChar::~NotifyCreateChar() {
  SharedDtor();
}

void NotifyCreateChar::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCreateChar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCreateChar& NotifyCreateChar::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCreateChar* NotifyCreateChar::default_instance_ = NULL;

NotifyCreateChar* NotifyCreateChar::New() const {
  return new NotifyCreateChar;
}

void NotifyCreateChar::Clear() {
  char_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCreateChar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MapCharInfo char_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_char_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_char_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_char_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCreateChar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .MapCharInfo char_list = 1;
  for (int i = 0; i < this->char_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->char_list(i), output);
  }

}

int NotifyCreateChar::ByteSize() const {
  int total_size = 0;

  // repeated .MapCharInfo char_list = 1;
  total_size += 1 * this->char_list_size();
  for (int i = 0; i < this->char_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->char_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCreateChar::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCreateChar*>(&from));
}

void NotifyCreateChar::MergeFrom(const NotifyCreateChar& from) {
  GOOGLE_CHECK_NE(&from, this);
  char_list_.MergeFrom(from.char_list_);
}

void NotifyCreateChar::CopyFrom(const NotifyCreateChar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCreateChar::IsInitialized() const {

  return true;
}

void NotifyCreateChar::Swap(NotifyCreateChar* other) {
  if (other != this) {
    char_list_.Swap(&other->char_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCreateChar::GetTypeName() const {
  return "Protocol.NotifyCreateChar";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyRemoveChar::kIdListFieldNumber;
#endif  // !_MSC_VER

NotifyRemoveChar::NotifyRemoveChar()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyRemoveChar::InitAsDefaultInstance() {
}

NotifyRemoveChar::NotifyRemoveChar(const NotifyRemoveChar& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyRemoveChar::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRemoveChar::~NotifyRemoveChar() {
  SharedDtor();
}

void NotifyRemoveChar::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRemoveChar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRemoveChar& NotifyRemoveChar::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyRemoveChar* NotifyRemoveChar::default_instance_ = NULL;

NotifyRemoveChar* NotifyRemoveChar::New() const {
  return new NotifyRemoveChar;
}

void NotifyRemoveChar::Clear() {
  id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyRemoveChar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyRemoveChar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id_list = 1;
  for (int i = 0; i < this->id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id_list(i), output);
  }

}

int NotifyRemoveChar::ByteSize() const {
  int total_size = 0;

  // repeated int32 id_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id_list(i));
    }
    total_size += 1 * this->id_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRemoveChar::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRemoveChar*>(&from));
}

void NotifyRemoveChar::MergeFrom(const NotifyRemoveChar& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_list_.MergeFrom(from.id_list_);
}

void NotifyRemoveChar::CopyFrom(const NotifyRemoveChar& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRemoveChar::IsInitialized() const {

  return true;
}

void NotifyRemoveChar::Swap(NotifyRemoveChar* other) {
  if (other != this) {
    id_list_.Swap(&other->id_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRemoveChar::GetTypeName() const {
  return "Protocol.NotifyRemoveChar";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgCharMove::kIdFieldNumber;
const int MsgCharMove::kXFieldNumber;
const int MsgCharMove::kYFieldNumber;
const int MsgCharMove::kSpeedFieldNumber;
const int MsgCharMove::kFlagFieldNumber;
const int MsgCharMove::kDirectionFieldNumber;
#endif  // !_MSC_VER

MsgCharMove::MsgCharMove()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MsgCharMove::InitAsDefaultInstance() {
}

MsgCharMove::MsgCharMove(const MsgCharMove& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MsgCharMove::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0;
  y_ = 0;
  speed_ = 0;
  flag_ = 0;
  direction_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgCharMove::~MsgCharMove() {
  SharedDtor();
}

void MsgCharMove::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgCharMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgCharMove& MsgCharMove::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

MsgCharMove* MsgCharMove::default_instance_ = NULL;

MsgCharMove* MsgCharMove::New() const {
  return new MsgCharMove;
}

void MsgCharMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    x_ = 0;
    y_ = 0;
    speed_ = 0;
    flag_ = 0;
    direction_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MsgCharMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_speed;
        break;
      }

      // optional int32 speed = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_flag;
        break;
      }

      // optional int32 flag = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &flag_)));
          set_has_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_direction;
        break;
      }

      // optional int32 direction = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &direction_)));
          set_has_direction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MsgCharMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // optional int32 speed = 4;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->speed(), output);
  }

  // optional int32 flag = 5;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->flag(), output);
  }

  // optional int32 direction = 6;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->direction(), output);
  }

}

int MsgCharMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional int32 speed = 4;
    if (has_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->speed());
    }

    // optional int32 flag = 5;
    if (has_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->flag());
    }

    // optional int32 direction = 6;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->direction());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgCharMove::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgCharMove*>(&from));
}

void MsgCharMove::MergeFrom(const MsgCharMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_flag()) {
      set_flag(from.flag());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
}

void MsgCharMove::CopyFrom(const MsgCharMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgCharMove::IsInitialized() const {

  return true;
}

void MsgCharMove::Swap(MsgCharMove* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(speed_, other->speed_);
    std::swap(flag_, other->flag_);
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgCharMove::GetTypeName() const {
  return "Protocol.MsgCharMove";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgCharStopMove::kIdFieldNumber;
const int MsgCharStopMove::kXFieldNumber;
const int MsgCharStopMove::kYFieldNumber;
#endif  // !_MSC_VER

MsgCharStopMove::MsgCharStopMove()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MsgCharStopMove::InitAsDefaultInstance() {
}

MsgCharStopMove::MsgCharStopMove(const MsgCharStopMove& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MsgCharStopMove::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgCharStopMove::~MsgCharStopMove() {
  SharedDtor();
}

void MsgCharStopMove::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgCharStopMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgCharStopMove& MsgCharStopMove::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

MsgCharStopMove* MsgCharStopMove::default_instance_ = NULL;

MsgCharStopMove* MsgCharStopMove::New() const {
  return new MsgCharStopMove;
}

void MsgCharStopMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MsgCharStopMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MsgCharStopMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

}

int MsgCharStopMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgCharStopMove::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgCharStopMove*>(&from));
}

void MsgCharStopMove::MergeFrom(const MsgCharStopMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void MsgCharStopMove::CopyFrom(const MsgCharStopMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgCharStopMove::IsInitialized() const {

  return true;
}

void MsgCharStopMove::Swap(MsgCharStopMove* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgCharStopMove::GetTypeName() const {
  return "Protocol.MsgCharStopMove";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCreateMonster::kMonListFieldNumber;
#endif  // !_MSC_VER

NotifyCreateMonster::NotifyCreateMonster()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCreateMonster::InitAsDefaultInstance() {
}

NotifyCreateMonster::NotifyCreateMonster(const NotifyCreateMonster& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCreateMonster::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCreateMonster::~NotifyCreateMonster() {
  SharedDtor();
}

void NotifyCreateMonster::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCreateMonster::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCreateMonster& NotifyCreateMonster::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCreateMonster* NotifyCreateMonster::default_instance_ = NULL;

NotifyCreateMonster* NotifyCreateMonster::New() const {
  return new NotifyCreateMonster;
}

void NotifyCreateMonster::Clear() {
  mon_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCreateMonster::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MapMonsterInfo mon_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mon_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mon_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_mon_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCreateMonster::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .MapMonsterInfo mon_list = 1;
  for (int i = 0; i < this->mon_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mon_list(i), output);
  }

}

int NotifyCreateMonster::ByteSize() const {
  int total_size = 0;

  // repeated .MapMonsterInfo mon_list = 1;
  total_size += 1 * this->mon_list_size();
  for (int i = 0; i < this->mon_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mon_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCreateMonster::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCreateMonster*>(&from));
}

void NotifyCreateMonster::MergeFrom(const NotifyCreateMonster& from) {
  GOOGLE_CHECK_NE(&from, this);
  mon_list_.MergeFrom(from.mon_list_);
}

void NotifyCreateMonster::CopyFrom(const NotifyCreateMonster& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCreateMonster::IsInitialized() const {

  return true;
}

void NotifyCreateMonster::Swap(NotifyCreateMonster* other) {
  if (other != this) {
    mon_list_.Swap(&other->mon_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCreateMonster::GetTypeName() const {
  return "Protocol.NotifyCreateMonster";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyRemoveMonster::kIdListFieldNumber;
#endif  // !_MSC_VER

NotifyRemoveMonster::NotifyRemoveMonster()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyRemoveMonster::InitAsDefaultInstance() {
}

NotifyRemoveMonster::NotifyRemoveMonster(const NotifyRemoveMonster& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyRemoveMonster::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRemoveMonster::~NotifyRemoveMonster() {
  SharedDtor();
}

void NotifyRemoveMonster::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRemoveMonster::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRemoveMonster& NotifyRemoveMonster::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyRemoveMonster* NotifyRemoveMonster::default_instance_ = NULL;

NotifyRemoveMonster* NotifyRemoveMonster::New() const {
  return new NotifyRemoveMonster;
}

void NotifyRemoveMonster::Clear() {
  id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyRemoveMonster::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyRemoveMonster::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id_list = 1;
  for (int i = 0; i < this->id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id_list(i), output);
  }

}

int NotifyRemoveMonster::ByteSize() const {
  int total_size = 0;

  // repeated int32 id_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id_list(i));
    }
    total_size += 1 * this->id_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRemoveMonster::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRemoveMonster*>(&from));
}

void NotifyRemoveMonster::MergeFrom(const NotifyRemoveMonster& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_list_.MergeFrom(from.id_list_);
}

void NotifyRemoveMonster::CopyFrom(const NotifyRemoveMonster& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRemoveMonster::IsInitialized() const {

  return true;
}

void NotifyRemoveMonster::Swap(NotifyRemoveMonster* other) {
  if (other != this) {
    id_list_.Swap(&other->id_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRemoveMonster::GetTypeName() const {
  return "Protocol.NotifyRemoveMonster";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyMonsterMove::kIdFieldNumber;
const int NotifyMonsterMove::kXFieldNumber;
const int NotifyMonsterMove::kYFieldNumber;
#endif  // !_MSC_VER

NotifyMonsterMove::NotifyMonsterMove()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyMonsterMove::InitAsDefaultInstance() {
}

NotifyMonsterMove::NotifyMonsterMove(const NotifyMonsterMove& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyMonsterMove::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyMonsterMove::~NotifyMonsterMove() {
  SharedDtor();
}

void NotifyMonsterMove::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyMonsterMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyMonsterMove& NotifyMonsterMove::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyMonsterMove* NotifyMonsterMove::default_instance_ = NULL;

NotifyMonsterMove* NotifyMonsterMove::New() const {
  return new NotifyMonsterMove;
}

void NotifyMonsterMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyMonsterMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyMonsterMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

}

int NotifyMonsterMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyMonsterMove::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyMonsterMove*>(&from));
}

void NotifyMonsterMove::MergeFrom(const NotifyMonsterMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void NotifyMonsterMove::CopyFrom(const NotifyMonsterMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyMonsterMove::IsInitialized() const {

  return true;
}

void NotifyMonsterMove::Swap(NotifyMonsterMove* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyMonsterMove::GetTypeName() const {
  return "Protocol.NotifyMonsterMove";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyMonsterStopMove::kIdFieldNumber;
const int NotifyMonsterStopMove::kXFieldNumber;
const int NotifyMonsterStopMove::kYFieldNumber;
#endif  // !_MSC_VER

NotifyMonsterStopMove::NotifyMonsterStopMove()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyMonsterStopMove::InitAsDefaultInstance() {
}

NotifyMonsterStopMove::NotifyMonsterStopMove(const NotifyMonsterStopMove& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyMonsterStopMove::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyMonsterStopMove::~NotifyMonsterStopMove() {
  SharedDtor();
}

void NotifyMonsterStopMove::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyMonsterStopMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyMonsterStopMove& NotifyMonsterStopMove::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyMonsterStopMove* NotifyMonsterStopMove::default_instance_ = NULL;

NotifyMonsterStopMove* NotifyMonsterStopMove::New() const {
  return new NotifyMonsterStopMove;
}

void NotifyMonsterStopMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyMonsterStopMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyMonsterStopMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

}

int NotifyMonsterStopMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyMonsterStopMove::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyMonsterStopMove*>(&from));
}

void NotifyMonsterStopMove::MergeFrom(const NotifyMonsterStopMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void NotifyMonsterStopMove::CopyFrom(const NotifyMonsterStopMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyMonsterStopMove::IsInitialized() const {

  return true;
}

void NotifyMonsterStopMove::Swap(NotifyMonsterStopMove* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyMonsterStopMove::GetTypeName() const {
  return "Protocol.NotifyMonsterStopMove";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCreateNpc::kNpcListFieldNumber;
#endif  // !_MSC_VER

NotifyCreateNpc::NotifyCreateNpc()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCreateNpc::InitAsDefaultInstance() {
}

NotifyCreateNpc::NotifyCreateNpc(const NotifyCreateNpc& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCreateNpc::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCreateNpc::~NotifyCreateNpc() {
  SharedDtor();
}

void NotifyCreateNpc::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCreateNpc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCreateNpc& NotifyCreateNpc::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCreateNpc* NotifyCreateNpc::default_instance_ = NULL;

NotifyCreateNpc* NotifyCreateNpc::New() const {
  return new NotifyCreateNpc;
}

void NotifyCreateNpc::Clear() {
  npc_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCreateNpc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MapNpcInfo npc_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_npc_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_npc_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_npc_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCreateNpc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .MapNpcInfo npc_list = 1;
  for (int i = 0; i < this->npc_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->npc_list(i), output);
  }

}

int NotifyCreateNpc::ByteSize() const {
  int total_size = 0;

  // repeated .MapNpcInfo npc_list = 1;
  total_size += 1 * this->npc_list_size();
  for (int i = 0; i < this->npc_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->npc_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCreateNpc::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCreateNpc*>(&from));
}

void NotifyCreateNpc::MergeFrom(const NotifyCreateNpc& from) {
  GOOGLE_CHECK_NE(&from, this);
  npc_list_.MergeFrom(from.npc_list_);
}

void NotifyCreateNpc::CopyFrom(const NotifyCreateNpc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCreateNpc::IsInitialized() const {

  return true;
}

void NotifyCreateNpc::Swap(NotifyCreateNpc* other) {
  if (other != this) {
    npc_list_.Swap(&other->npc_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCreateNpc::GetTypeName() const {
  return "Protocol.NotifyCreateNpc";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyRemoveNpc::kIdListFieldNumber;
#endif  // !_MSC_VER

NotifyRemoveNpc::NotifyRemoveNpc()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyRemoveNpc::InitAsDefaultInstance() {
}

NotifyRemoveNpc::NotifyRemoveNpc(const NotifyRemoveNpc& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyRemoveNpc::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRemoveNpc::~NotifyRemoveNpc() {
  SharedDtor();
}

void NotifyRemoveNpc::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRemoveNpc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRemoveNpc& NotifyRemoveNpc::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyRemoveNpc* NotifyRemoveNpc::default_instance_ = NULL;

NotifyRemoveNpc* NotifyRemoveNpc::New() const {
  return new NotifyRemoveNpc;
}

void NotifyRemoveNpc::Clear() {
  id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyRemoveNpc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyRemoveNpc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id_list = 1;
  for (int i = 0; i < this->id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id_list(i), output);
  }

}

int NotifyRemoveNpc::ByteSize() const {
  int total_size = 0;

  // repeated int32 id_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id_list(i));
    }
    total_size += 1 * this->id_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRemoveNpc::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRemoveNpc*>(&from));
}

void NotifyRemoveNpc::MergeFrom(const NotifyRemoveNpc& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_list_.MergeFrom(from.id_list_);
}

void NotifyRemoveNpc::CopyFrom(const NotifyRemoveNpc& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRemoveNpc::IsInitialized() const {

  return true;
}

void NotifyRemoveNpc::Swap(NotifyRemoveNpc* other) {
  if (other != this) {
    id_list_.Swap(&other->id_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRemoveNpc::GetTypeName() const {
  return "Protocol.NotifyRemoveNpc";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyNpcMove::kIdFieldNumber;
const int NotifyNpcMove::kXFieldNumber;
const int NotifyNpcMove::kYFieldNumber;
#endif  // !_MSC_VER

NotifyNpcMove::NotifyNpcMove()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyNpcMove::InitAsDefaultInstance() {
}

NotifyNpcMove::NotifyNpcMove(const NotifyNpcMove& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyNpcMove::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyNpcMove::~NotifyNpcMove() {
  SharedDtor();
}

void NotifyNpcMove::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyNpcMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyNpcMove& NotifyNpcMove::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyNpcMove* NotifyNpcMove::default_instance_ = NULL;

NotifyNpcMove* NotifyNpcMove::New() const {
  return new NotifyNpcMove;
}

void NotifyNpcMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyNpcMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyNpcMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

}

int NotifyNpcMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyNpcMove::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyNpcMove*>(&from));
}

void NotifyNpcMove::MergeFrom(const NotifyNpcMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void NotifyNpcMove::CopyFrom(const NotifyNpcMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyNpcMove::IsInitialized() const {

  return true;
}

void NotifyNpcMove::Swap(NotifyNpcMove* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyNpcMove::GetTypeName() const {
  return "Protocol.NotifyNpcMove";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyNpcStopMove::kIdFieldNumber;
const int NotifyNpcStopMove::kXFieldNumber;
const int NotifyNpcStopMove::kYFieldNumber;
#endif  // !_MSC_VER

NotifyNpcStopMove::NotifyNpcStopMove()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyNpcStopMove::InitAsDefaultInstance() {
}

NotifyNpcStopMove::NotifyNpcStopMove(const NotifyNpcStopMove& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyNpcStopMove::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyNpcStopMove::~NotifyNpcStopMove() {
  SharedDtor();
}

void NotifyNpcStopMove::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyNpcStopMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyNpcStopMove& NotifyNpcStopMove::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyNpcStopMove* NotifyNpcStopMove::default_instance_ = NULL;

NotifyNpcStopMove* NotifyNpcStopMove::New() const {
  return new NotifyNpcStopMove;
}

void NotifyNpcStopMove::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyNpcStopMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyNpcStopMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

}

int NotifyNpcStopMove::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyNpcStopMove::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyNpcStopMove*>(&from));
}

void NotifyNpcStopMove::MergeFrom(const NotifyNpcStopMove& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void NotifyNpcStopMove::CopyFrom(const NotifyNpcStopMove& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyNpcStopMove::IsInitialized() const {

  return true;
}

void NotifyNpcStopMove::Swap(NotifyNpcStopMove* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyNpcStopMove::GetTypeName() const {
  return "Protocol.NotifyNpcStopMove";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyMonsterDead::kIdFieldNumber;
const int NotifyMonsterDead::kExpFieldNumber;
const int NotifyMonsterDead::kAttackerIdFieldNumber;
#endif  // !_MSC_VER

NotifyMonsterDead::NotifyMonsterDead()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyMonsterDead::InitAsDefaultInstance() {
}

NotifyMonsterDead::NotifyMonsterDead(const NotifyMonsterDead& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyMonsterDead::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  exp_ = 0;
  attacker_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyMonsterDead::~NotifyMonsterDead() {
  SharedDtor();
}

void NotifyMonsterDead::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyMonsterDead::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyMonsterDead& NotifyMonsterDead::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyMonsterDead* NotifyMonsterDead::default_instance_ = NULL;

NotifyMonsterDead* NotifyMonsterDead::New() const {
  return new NotifyMonsterDead;
}

void NotifyMonsterDead::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    exp_ = 0;
    attacker_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyMonsterDead::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_exp;
        break;
      }

      // optional int32 exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_attacker_id;
        break;
      }

      // optional int32 attacker_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attacker_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attacker_id_)));
          set_has_attacker_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyMonsterDead::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->exp(), output);
  }

  // optional int32 attacker_id = 3;
  if (has_attacker_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->attacker_id(), output);
  }

}

int NotifyMonsterDead::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 attacker_id = 3;
    if (has_attacker_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->attacker_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyMonsterDead::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyMonsterDead*>(&from));
}

void NotifyMonsterDead::MergeFrom(const NotifyMonsterDead& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_attacker_id()) {
      set_attacker_id(from.attacker_id());
    }
  }
}

void NotifyMonsterDead::CopyFrom(const NotifyMonsterDead& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyMonsterDead::IsInitialized() const {

  return true;
}

void NotifyMonsterDead::Swap(NotifyMonsterDead* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(exp_, other->exp_);
    std::swap(attacker_id_, other->attacker_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyMonsterDead::GetTypeName() const {
  return "Protocol.NotifyMonsterDead";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyMonsterDisappear::kIdFieldNumber;
#endif  // !_MSC_VER

NotifyMonsterDisappear::NotifyMonsterDisappear()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyMonsterDisappear::InitAsDefaultInstance() {
}

NotifyMonsterDisappear::NotifyMonsterDisappear(const NotifyMonsterDisappear& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyMonsterDisappear::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyMonsterDisappear::~NotifyMonsterDisappear() {
  SharedDtor();
}

void NotifyMonsterDisappear::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyMonsterDisappear::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyMonsterDisappear& NotifyMonsterDisappear::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyMonsterDisappear* NotifyMonsterDisappear::default_instance_ = NULL;

NotifyMonsterDisappear* NotifyMonsterDisappear::New() const {
  return new NotifyMonsterDisappear;
}

void NotifyMonsterDisappear::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyMonsterDisappear::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyMonsterDisappear::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

}

int NotifyMonsterDisappear::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyMonsterDisappear::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyMonsterDisappear*>(&from));
}

void NotifyMonsterDisappear::MergeFrom(const NotifyMonsterDisappear& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void NotifyMonsterDisappear::CopyFrom(const NotifyMonsterDisappear& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyMonsterDisappear::IsInitialized() const {

  return true;
}

void NotifyMonsterDisappear::Swap(NotifyMonsterDisappear* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyMonsterDisappear::GetTypeName() const {
  return "Protocol.NotifyMonsterDisappear";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyMonsterRevive::kMoninfoFieldNumber;
#endif  // !_MSC_VER

NotifyMonsterRevive::NotifyMonsterRevive()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyMonsterRevive::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  moninfo_ = const_cast< ::MapMonsterInfo*>(
      ::MapMonsterInfo::internal_default_instance());
#else
  moninfo_ = const_cast< ::MapMonsterInfo*>(&::MapMonsterInfo::default_instance());
#endif
}

NotifyMonsterRevive::NotifyMonsterRevive(const NotifyMonsterRevive& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyMonsterRevive::SharedCtor() {
  _cached_size_ = 0;
  moninfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyMonsterRevive::~NotifyMonsterRevive() {
  SharedDtor();
}

void NotifyMonsterRevive::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete moninfo_;
  }
}

void NotifyMonsterRevive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyMonsterRevive& NotifyMonsterRevive::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyMonsterRevive* NotifyMonsterRevive::default_instance_ = NULL;

NotifyMonsterRevive* NotifyMonsterRevive::New() const {
  return new NotifyMonsterRevive;
}

void NotifyMonsterRevive::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_moninfo()) {
      if (moninfo_ != NULL) moninfo_->::MapMonsterInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyMonsterRevive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MapMonsterInfo moninfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_moninfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyMonsterRevive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .MapMonsterInfo moninfo = 1;
  if (has_moninfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->moninfo(), output);
  }

}

int NotifyMonsterRevive::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MapMonsterInfo moninfo = 1;
    if (has_moninfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->moninfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyMonsterRevive::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyMonsterRevive*>(&from));
}

void NotifyMonsterRevive::MergeFrom(const NotifyMonsterRevive& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_moninfo()) {
      mutable_moninfo()->::MapMonsterInfo::MergeFrom(from.moninfo());
    }
  }
}

void NotifyMonsterRevive::CopyFrom(const NotifyMonsterRevive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyMonsterRevive::IsInitialized() const {

  return true;
}

void NotifyMonsterRevive::Swap(NotifyMonsterRevive* other) {
  if (other != this) {
    std::swap(moninfo_, other->moninfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyMonsterRevive::GetTypeName() const {
  return "Protocol.NotifyMonsterRevive";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCharDead::kIdFieldNumber;
const int NotifyCharDead::kExpFieldNumber;
const int NotifyCharDead::kAttackerIdFieldNumber;
#endif  // !_MSC_VER

NotifyCharDead::NotifyCharDead()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCharDead::InitAsDefaultInstance() {
}

NotifyCharDead::NotifyCharDead(const NotifyCharDead& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCharDead::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  exp_ = 0;
  attacker_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCharDead::~NotifyCharDead() {
  SharedDtor();
}

void NotifyCharDead::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCharDead::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCharDead& NotifyCharDead::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCharDead* NotifyCharDead::default_instance_ = NULL;

NotifyCharDead* NotifyCharDead::New() const {
  return new NotifyCharDead;
}

void NotifyCharDead::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    exp_ = 0;
    attacker_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCharDead::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_exp;
        break;
      }

      // optional int32 exp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_attacker_id;
        break;
      }

      // optional int32 attacker_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_attacker_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attacker_id_)));
          set_has_attacker_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCharDead::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 exp = 2;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->exp(), output);
  }

  // optional int32 attacker_id = 3;
  if (has_attacker_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->attacker_id(), output);
  }

}

int NotifyCharDead::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 exp = 2;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->exp());
    }

    // optional int32 attacker_id = 3;
    if (has_attacker_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->attacker_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCharDead::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCharDead*>(&from));
}

void NotifyCharDead::MergeFrom(const NotifyCharDead& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_attacker_id()) {
      set_attacker_id(from.attacker_id());
    }
  }
}

void NotifyCharDead::CopyFrom(const NotifyCharDead& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCharDead::IsInitialized() const {

  return true;
}

void NotifyCharDead::Swap(NotifyCharDead* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(exp_, other->exp_);
    std::swap(attacker_id_, other->attacker_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCharDead::GetTypeName() const {
  return "Protocol.NotifyCharDead";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCharDisappear::kIdFieldNumber;
#endif  // !_MSC_VER

NotifyCharDisappear::NotifyCharDisappear()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCharDisappear::InitAsDefaultInstance() {
}

NotifyCharDisappear::NotifyCharDisappear(const NotifyCharDisappear& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCharDisappear::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCharDisappear::~NotifyCharDisappear() {
  SharedDtor();
}

void NotifyCharDisappear::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCharDisappear::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCharDisappear& NotifyCharDisappear::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCharDisappear* NotifyCharDisappear::default_instance_ = NULL;

NotifyCharDisappear* NotifyCharDisappear::New() const {
  return new NotifyCharDisappear;
}

void NotifyCharDisappear::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCharDisappear::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCharDisappear::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

}

int NotifyCharDisappear::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCharDisappear::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCharDisappear*>(&from));
}

void NotifyCharDisappear::MergeFrom(const NotifyCharDisappear& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void NotifyCharDisappear::CopyFrom(const NotifyCharDisappear& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCharDisappear::IsInitialized() const {

  return true;
}

void NotifyCharDisappear::Swap(NotifyCharDisappear* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCharDisappear::GetTypeName() const {
  return "Protocol.NotifyCharDisappear";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCharRevive::kReviveTypeFieldNumber;
#endif  // !_MSC_VER

RequestCharRevive::RequestCharRevive()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestCharRevive::InitAsDefaultInstance() {
}

RequestCharRevive::RequestCharRevive(const RequestCharRevive& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestCharRevive::SharedCtor() {
  _cached_size_ = 0;
  revive_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCharRevive::~RequestCharRevive() {
  SharedDtor();
}

void RequestCharRevive::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCharRevive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCharRevive& RequestCharRevive::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

RequestCharRevive* RequestCharRevive::default_instance_ = NULL;

RequestCharRevive* RequestCharRevive::New() const {
  return new RequestCharRevive;
}

void RequestCharRevive::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    revive_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestCharRevive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.ReviveType revive_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::ReviveType_IsValid(value)) {
            set_revive_type(static_cast< ::Protocol::ReviveType >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestCharRevive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.ReviveType revive_type = 1;
  if (has_revive_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->revive_type(), output);
  }

}

int RequestCharRevive::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.ReviveType revive_type = 1;
    if (has_revive_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->revive_type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCharRevive::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCharRevive*>(&from));
}

void RequestCharRevive::MergeFrom(const RequestCharRevive& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_revive_type()) {
      set_revive_type(from.revive_type());
    }
  }
}

void RequestCharRevive::CopyFrom(const RequestCharRevive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCharRevive::IsInitialized() const {

  return true;
}

void RequestCharRevive::Swap(RequestCharRevive* other) {
  if (other != this) {
    std::swap(revive_type_, other->revive_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCharRevive::GetTypeName() const {
  return "Protocol.RequestCharRevive";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCharRevive::kCharinfoFieldNumber;
#endif  // !_MSC_VER

NotifyCharRevive::NotifyCharRevive()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCharRevive::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  charinfo_ = const_cast< ::MapCharInfo*>(
      ::MapCharInfo::internal_default_instance());
#else
  charinfo_ = const_cast< ::MapCharInfo*>(&::MapCharInfo::default_instance());
#endif
}

NotifyCharRevive::NotifyCharRevive(const NotifyCharRevive& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCharRevive::SharedCtor() {
  _cached_size_ = 0;
  charinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCharRevive::~NotifyCharRevive() {
  SharedDtor();
}

void NotifyCharRevive::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete charinfo_;
  }
}

void NotifyCharRevive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCharRevive& NotifyCharRevive::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCharRevive* NotifyCharRevive::default_instance_ = NULL;

NotifyCharRevive* NotifyCharRevive::New() const {
  return new NotifyCharRevive;
}

void NotifyCharRevive::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_charinfo()) {
      if (charinfo_ != NULL) charinfo_->::MapCharInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCharRevive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MapCharInfo charinfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_charinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCharRevive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .MapCharInfo charinfo = 1;
  if (has_charinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->charinfo(), output);
  }

}

int NotifyCharRevive::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MapCharInfo charinfo = 1;
    if (has_charinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->charinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCharRevive::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCharRevive*>(&from));
}

void NotifyCharRevive::MergeFrom(const NotifyCharRevive& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charinfo()) {
      mutable_charinfo()->::MapCharInfo::MergeFrom(from.charinfo());
    }
  }
}

void NotifyCharRevive::CopyFrom(const NotifyCharRevive& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCharRevive::IsInitialized() const {

  return true;
}

void NotifyCharRevive::Swap(NotifyCharRevive* other) {
  if (other != this) {
    std::swap(charinfo_, other->charinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCharRevive::GetTypeName() const {
  return "Protocol.NotifyCharRevive";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCharLevel::kCharidFieldNumber;
const int NotifyCharLevel::kCharlevelFieldNumber;
#endif  // !_MSC_VER

NotifyCharLevel::NotifyCharLevel()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCharLevel::InitAsDefaultInstance() {
}

NotifyCharLevel::NotifyCharLevel(const NotifyCharLevel& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCharLevel::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0;
  charlevel_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCharLevel::~NotifyCharLevel() {
  SharedDtor();
}

void NotifyCharLevel::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCharLevel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCharLevel& NotifyCharLevel::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCharLevel* NotifyCharLevel::default_instance_ = NULL;

NotifyCharLevel* NotifyCharLevel::New() const {
  return new NotifyCharLevel;
}

void NotifyCharLevel::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = 0;
    charlevel_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCharLevel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_charlevel;
        break;
      }

      // optional int32 charlevel = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charlevel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charlevel_)));
          set_has_charlevel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCharLevel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->charid(), output);
  }

  // optional int32 charlevel = 2;
  if (has_charlevel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->charlevel(), output);
  }

}

int NotifyCharLevel::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional int32 charlevel = 2;
    if (has_charlevel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charlevel());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCharLevel::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCharLevel*>(&from));
}

void NotifyCharLevel::MergeFrom(const NotifyCharLevel& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_charlevel()) {
      set_charlevel(from.charlevel());
    }
  }
}

void NotifyCharLevel::CopyFrom(const NotifyCharLevel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCharLevel::IsInitialized() const {

  return true;
}

void NotifyCharLevel::Swap(NotifyCharLevel* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(charlevel_, other->charlevel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCharLevel::GetTypeName() const {
  return "Protocol.NotifyCharLevel";
}


// ===================================================================

#ifndef _MSC_VER
const int JumpPoint::kMapXFieldNumber;
const int JumpPoint::kMapYFieldNumber;
const int JumpPoint::kTargetMapidFieldNumber;
#endif  // !_MSC_VER

JumpPoint::JumpPoint()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JumpPoint::InitAsDefaultInstance() {
}

JumpPoint::JumpPoint(const JumpPoint& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JumpPoint::SharedCtor() {
  _cached_size_ = 0;
  map_x_ = 0;
  map_y_ = 0;
  target_mapid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JumpPoint::~JumpPoint() {
  SharedDtor();
}

void JumpPoint::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JumpPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JumpPoint& JumpPoint::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

JumpPoint* JumpPoint::default_instance_ = NULL;

JumpPoint* JumpPoint::New() const {
  return new JumpPoint;
}

void JumpPoint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_x_ = 0;
    map_y_ = 0;
    target_mapid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JumpPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 map_x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_x_)));
          set_has_map_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_map_y;
        break;
      }

      // optional int32 map_y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_y_)));
          set_has_map_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_target_mapid;
        break;
      }

      // optional int32 target_mapid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_target_mapid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &target_mapid_)));
          set_has_target_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JumpPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 map_x = 1;
  if (has_map_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->map_x(), output);
  }

  // optional int32 map_y = 2;
  if (has_map_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->map_y(), output);
  }

  // optional int32 target_mapid = 3;
  if (has_target_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->target_mapid(), output);
  }

}

int JumpPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 map_x = 1;
    if (has_map_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_x());
    }

    // optional int32 map_y = 2;
    if (has_map_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_y());
    }

    // optional int32 target_mapid = 3;
    if (has_target_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->target_mapid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JumpPoint::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JumpPoint*>(&from));
}

void JumpPoint::MergeFrom(const JumpPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_x()) {
      set_map_x(from.map_x());
    }
    if (from.has_map_y()) {
      set_map_y(from.map_y());
    }
    if (from.has_target_mapid()) {
      set_target_mapid(from.target_mapid());
    }
  }
}

void JumpPoint::CopyFrom(const JumpPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JumpPoint::IsInitialized() const {

  return true;
}

void JumpPoint::Swap(JumpPoint* other) {
  if (other != this) {
    std::swap(map_x_, other->map_x_);
    std::swap(map_y_, other->map_y_);
    std::swap(target_mapid_, other->target_mapid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JumpPoint::GetTypeName() const {
  return "Protocol.JumpPoint";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCreateJumpPoint::kPointListFieldNumber;
#endif  // !_MSC_VER

NotifyCreateJumpPoint::NotifyCreateJumpPoint()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCreateJumpPoint::InitAsDefaultInstance() {
}

NotifyCreateJumpPoint::NotifyCreateJumpPoint(const NotifyCreateJumpPoint& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCreateJumpPoint::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCreateJumpPoint::~NotifyCreateJumpPoint() {
  SharedDtor();
}

void NotifyCreateJumpPoint::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCreateJumpPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCreateJumpPoint& NotifyCreateJumpPoint::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCreateJumpPoint* NotifyCreateJumpPoint::default_instance_ = NULL;

NotifyCreateJumpPoint* NotifyCreateJumpPoint::New() const {
  return new NotifyCreateJumpPoint;
}

void NotifyCreateJumpPoint::Clear() {
  point_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCreateJumpPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.JumpPoint point_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_point_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_point_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_point_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCreateJumpPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.JumpPoint point_list = 1;
  for (int i = 0; i < this->point_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->point_list(i), output);
  }

}

int NotifyCreateJumpPoint::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.JumpPoint point_list = 1;
  total_size += 1 * this->point_list_size();
  for (int i = 0; i < this->point_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->point_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCreateJumpPoint::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCreateJumpPoint*>(&from));
}

void NotifyCreateJumpPoint::MergeFrom(const NotifyCreateJumpPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  point_list_.MergeFrom(from.point_list_);
}

void NotifyCreateJumpPoint::CopyFrom(const NotifyCreateJumpPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCreateJumpPoint::IsInitialized() const {

  return true;
}

void NotifyCreateJumpPoint::Swap(NotifyCreateJumpPoint* other) {
  if (other != this) {
    point_list_.Swap(&other->point_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCreateJumpPoint::GetTypeName() const {
  return "Protocol.NotifyCreateJumpPoint";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyCharChangeMap::kMapIdFieldNumber;
const int NotifyCharChangeMap::kMapXFieldNumber;
const int NotifyCharChangeMap::kMapYFieldNumber;
#endif  // !_MSC_VER

NotifyCharChangeMap::NotifyCharChangeMap()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyCharChangeMap::InitAsDefaultInstance() {
}

NotifyCharChangeMap::NotifyCharChangeMap(const NotifyCharChangeMap& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyCharChangeMap::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0;
  map_x_ = 0;
  map_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyCharChangeMap::~NotifyCharChangeMap() {
  SharedDtor();
}

void NotifyCharChangeMap::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyCharChangeMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyCharChangeMap& NotifyCharChangeMap::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyCharChangeMap* NotifyCharChangeMap::default_instance_ = NULL;

NotifyCharChangeMap* NotifyCharChangeMap::New() const {
  return new NotifyCharChangeMap;
}

void NotifyCharChangeMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0;
    map_x_ = 0;
    map_y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyCharChangeMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_map_x;
        break;
      }

      // optional int32 map_x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_x_)));
          set_has_map_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_map_y;
        break;
      }

      // optional int32 map_y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_y_)));
          set_has_map_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyCharChangeMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->map_id(), output);
  }

  // optional int32 map_x = 2;
  if (has_map_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->map_x(), output);
  }

  // optional int32 map_y = 3;
  if (has_map_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->map_y(), output);
  }

}

int NotifyCharChangeMap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_id());
    }

    // optional int32 map_x = 2;
    if (has_map_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_x());
    }

    // optional int32 map_y = 3;
    if (has_map_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyCharChangeMap::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyCharChangeMap*>(&from));
}

void NotifyCharChangeMap::MergeFrom(const NotifyCharChangeMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_map_x()) {
      set_map_x(from.map_x());
    }
    if (from.has_map_y()) {
      set_map_y(from.map_y());
    }
  }
}

void NotifyCharChangeMap::CopyFrom(const NotifyCharChangeMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyCharChangeMap::IsInitialized() const {

  return true;
}

void NotifyCharChangeMap::Swap(NotifyCharChangeMap* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(map_x_, other->map_x_);
    std::swap(map_y_, other->map_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyCharChangeMap::GetTypeName() const {
  return "Protocol.NotifyCharChangeMap";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifySceneUpdateCharProperty::kIdFieldNumber;
const int NotifySceneUpdateCharProperty::kLevelFieldNumber;
const int NotifySceneUpdateCharProperty::kCurhpFieldNumber;
const int NotifySceneUpdateCharProperty::kMaxhpFieldNumber;
const int NotifySceneUpdateCharProperty::kMoveSpeedFieldNumber;
const int NotifySceneUpdateCharProperty::kHasLooksFieldNumber;
const int NotifySceneUpdateCharProperty::kLooksFieldNumber;
#endif  // !_MSC_VER

NotifySceneUpdateCharProperty::NotifySceneUpdateCharProperty()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifySceneUpdateCharProperty::InitAsDefaultInstance() {
}

NotifySceneUpdateCharProperty::NotifySceneUpdateCharProperty(const NotifySceneUpdateCharProperty& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifySceneUpdateCharProperty::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  level_ = 0;
  curhp_ = 0;
  maxhp_ = 0;
  move_speed_ = 0;
  has_looks_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifySceneUpdateCharProperty::~NotifySceneUpdateCharProperty() {
  SharedDtor();
}

void NotifySceneUpdateCharProperty::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifySceneUpdateCharProperty::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifySceneUpdateCharProperty& NotifySceneUpdateCharProperty::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifySceneUpdateCharProperty* NotifySceneUpdateCharProperty::default_instance_ = NULL;

NotifySceneUpdateCharProperty* NotifySceneUpdateCharProperty::New() const {
  return new NotifySceneUpdateCharProperty;
}

void NotifySceneUpdateCharProperty::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    level_ = 0;
    curhp_ = 0;
    maxhp_ = 0;
    move_speed_ = 0;
    has_looks_ = false;
  }
  looks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifySceneUpdateCharProperty::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_level;
        break;
      }

      // optional int32 level = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_curhp;
        break;
      }

      // optional int32 curhp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curhp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curhp_)));
          set_has_curhp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_maxhp;
        break;
      }

      // optional int32 maxhp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxhp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxhp_)));
          set_has_maxhp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_move_speed;
        break;
      }

      // optional int32 move_speed = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_move_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &move_speed_)));
          set_has_move_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_has_looks;
        break;
      }

      // optional bool has_looks = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_looks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_looks_)));
          set_has_has_looks();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_looks;
        break;
      }

      // repeated int32 looks = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_looks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 56, input, this->mutable_looks())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_looks())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_looks;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifySceneUpdateCharProperty::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 level = 2;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->level(), output);
  }

  // optional int32 curhp = 3;
  if (has_curhp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->curhp(), output);
  }

  // optional int32 maxhp = 4;
  if (has_maxhp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->maxhp(), output);
  }

  // optional int32 move_speed = 5;
  if (has_move_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->move_speed(), output);
  }

  // optional bool has_looks = 6;
  if (has_has_looks()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->has_looks(), output);
  }

  // repeated int32 looks = 7;
  for (int i = 0; i < this->looks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      7, this->looks(i), output);
  }

}

int NotifySceneUpdateCharProperty::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 level = 2;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->level());
    }

    // optional int32 curhp = 3;
    if (has_curhp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curhp());
    }

    // optional int32 maxhp = 4;
    if (has_maxhp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxhp());
    }

    // optional int32 move_speed = 5;
    if (has_move_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->move_speed());
    }

    // optional bool has_looks = 6;
    if (has_has_looks()) {
      total_size += 1 + 1;
    }

  }
  // repeated int32 looks = 7;
  {
    int data_size = 0;
    for (int i = 0; i < this->looks_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->looks(i));
    }
    total_size += 1 * this->looks_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifySceneUpdateCharProperty::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifySceneUpdateCharProperty*>(&from));
}

void NotifySceneUpdateCharProperty::MergeFrom(const NotifySceneUpdateCharProperty& from) {
  GOOGLE_CHECK_NE(&from, this);
  looks_.MergeFrom(from.looks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_curhp()) {
      set_curhp(from.curhp());
    }
    if (from.has_maxhp()) {
      set_maxhp(from.maxhp());
    }
    if (from.has_move_speed()) {
      set_move_speed(from.move_speed());
    }
    if (from.has_has_looks()) {
      set_has_looks(from.has_looks());
    }
  }
}

void NotifySceneUpdateCharProperty::CopyFrom(const NotifySceneUpdateCharProperty& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifySceneUpdateCharProperty::IsInitialized() const {

  return true;
}

void NotifySceneUpdateCharProperty::Swap(NotifySceneUpdateCharProperty* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(level_, other->level_);
    std::swap(curhp_, other->curhp_);
    std::swap(maxhp_, other->maxhp_);
    std::swap(move_speed_, other->move_speed_);
    std::swap(has_looks_, other->has_looks_);
    looks_.Swap(&other->looks_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifySceneUpdateCharProperty::GetTypeName() const {
  return "Protocol.NotifySceneUpdateCharProperty";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifySceneUpdateMonsterProperty::kIdFieldNumber;
const int NotifySceneUpdateMonsterProperty::kCurhpFieldNumber;
const int NotifySceneUpdateMonsterProperty::kMaxhpFieldNumber;
const int NotifySceneUpdateMonsterProperty::kMoveSpeedFieldNumber;
#endif  // !_MSC_VER

NotifySceneUpdateMonsterProperty::NotifySceneUpdateMonsterProperty()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifySceneUpdateMonsterProperty::InitAsDefaultInstance() {
}

NotifySceneUpdateMonsterProperty::NotifySceneUpdateMonsterProperty(const NotifySceneUpdateMonsterProperty& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifySceneUpdateMonsterProperty::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  curhp_ = 0;
  maxhp_ = 0;
  move_speed_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifySceneUpdateMonsterProperty::~NotifySceneUpdateMonsterProperty() {
  SharedDtor();
}

void NotifySceneUpdateMonsterProperty::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifySceneUpdateMonsterProperty::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifySceneUpdateMonsterProperty& NotifySceneUpdateMonsterProperty::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifySceneUpdateMonsterProperty* NotifySceneUpdateMonsterProperty::default_instance_ = NULL;

NotifySceneUpdateMonsterProperty* NotifySceneUpdateMonsterProperty::New() const {
  return new NotifySceneUpdateMonsterProperty;
}

void NotifySceneUpdateMonsterProperty::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    curhp_ = 0;
    maxhp_ = 0;
    move_speed_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifySceneUpdateMonsterProperty::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_curhp;
        break;
      }

      // optional int32 curhp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_curhp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &curhp_)));
          set_has_curhp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_maxhp;
        break;
      }

      // optional int32 maxhp = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxhp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxhp_)));
          set_has_maxhp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_move_speed;
        break;
      }

      // optional int32 move_speed = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_move_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &move_speed_)));
          set_has_move_speed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifySceneUpdateMonsterProperty::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 curhp = 2;
  if (has_curhp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->curhp(), output);
  }

  // optional int32 maxhp = 3;
  if (has_maxhp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->maxhp(), output);
  }

  // optional int32 move_speed = 4;
  if (has_move_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->move_speed(), output);
  }

}

int NotifySceneUpdateMonsterProperty::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 curhp = 2;
    if (has_curhp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->curhp());
    }

    // optional int32 maxhp = 3;
    if (has_maxhp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxhp());
    }

    // optional int32 move_speed = 4;
    if (has_move_speed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->move_speed());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifySceneUpdateMonsterProperty::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifySceneUpdateMonsterProperty*>(&from));
}

void NotifySceneUpdateMonsterProperty::MergeFrom(const NotifySceneUpdateMonsterProperty& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_curhp()) {
      set_curhp(from.curhp());
    }
    if (from.has_maxhp()) {
      set_maxhp(from.maxhp());
    }
    if (from.has_move_speed()) {
      set_move_speed(from.move_speed());
    }
  }
}

void NotifySceneUpdateMonsterProperty::CopyFrom(const NotifySceneUpdateMonsterProperty& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifySceneUpdateMonsterProperty::IsInitialized() const {

  return true;
}

void NotifySceneUpdateMonsterProperty::Swap(NotifySceneUpdateMonsterProperty* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(curhp_, other->curhp_);
    std::swap(maxhp_, other->maxhp_);
    std::swap(move_speed_, other->move_speed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifySceneUpdateMonsterProperty::GetTypeName() const {
  return "Protocol.NotifySceneUpdateMonsterProperty";
}


// ===================================================================

#ifndef _MSC_VER
const int BigMapNpcInfo::kIdFieldNumber;
const int BigMapNpcInfo::kXFieldNumber;
const int BigMapNpcInfo::kYFieldNumber;
const int BigMapNpcInfo::kNpcidFieldNumber;
const int BigMapNpcInfo::kFuncFieldNumber;
#endif  // !_MSC_VER

BigMapNpcInfo::BigMapNpcInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BigMapNpcInfo::InitAsDefaultInstance() {
}

BigMapNpcInfo::BigMapNpcInfo(const BigMapNpcInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BigMapNpcInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  x_ = 0;
  y_ = 0;
  npcid_ = 0;
  func_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BigMapNpcInfo::~BigMapNpcInfo() {
  SharedDtor();
}

void BigMapNpcInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BigMapNpcInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BigMapNpcInfo& BigMapNpcInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

BigMapNpcInfo* BigMapNpcInfo::default_instance_ = NULL;

BigMapNpcInfo* BigMapNpcInfo::New() const {
  return new BigMapNpcInfo;
}

void BigMapNpcInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    x_ = 0;
    y_ = 0;
    npcid_ = 0;
    func_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BigMapNpcInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_x;
        break;
      }

      // optional int32 x = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_y;
        break;
      }

      // optional int32 y = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_npcid;
        break;
      }

      // optional int32 npcid = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_npcid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &npcid_)));
          set_has_npcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_func;
        break;
      }

      // optional int32 func = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_func:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &func_)));
          set_has_func();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BigMapNpcInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 x = 2;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->x(), output);
  }

  // optional int32 y = 3;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->y(), output);
  }

  // optional int32 npcid = 4;
  if (has_npcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->npcid(), output);
  }

  // optional int32 func = 5;
  if (has_func()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->func(), output);
  }

}

int BigMapNpcInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 x = 2;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 3;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional int32 npcid = 4;
    if (has_npcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->npcid());
    }

    // optional int32 func = 5;
    if (has_func()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->func());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BigMapNpcInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BigMapNpcInfo*>(&from));
}

void BigMapNpcInfo::MergeFrom(const BigMapNpcInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_npcid()) {
      set_npcid(from.npcid());
    }
    if (from.has_func()) {
      set_func(from.func());
    }
  }
}

void BigMapNpcInfo::CopyFrom(const BigMapNpcInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BigMapNpcInfo::IsInitialized() const {

  return true;
}

void BigMapNpcInfo::Swap(BigMapNpcInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(npcid_, other->npcid_);
    std::swap(func_, other->func_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BigMapNpcInfo::GetTypeName() const {
  return "Protocol.BigMapNpcInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int BigMapMonsterInfo::kXFieldNumber;
const int BigMapMonsterInfo::kYFieldNumber;
const int BigMapMonsterInfo::kMonidFieldNumber;
#endif  // !_MSC_VER

BigMapMonsterInfo::BigMapMonsterInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BigMapMonsterInfo::InitAsDefaultInstance() {
}

BigMapMonsterInfo::BigMapMonsterInfo(const BigMapMonsterInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BigMapMonsterInfo::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  monid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BigMapMonsterInfo::~BigMapMonsterInfo() {
  SharedDtor();
}

void BigMapMonsterInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BigMapMonsterInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BigMapMonsterInfo& BigMapMonsterInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

BigMapMonsterInfo* BigMapMonsterInfo::default_instance_ = NULL;

BigMapMonsterInfo* BigMapMonsterInfo::New() const {
  return new BigMapMonsterInfo;
}

void BigMapMonsterInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    monid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BigMapMonsterInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional int32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_monid;
        break;
      }

      // optional int32 monid = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_monid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &monid_)));
          set_has_monid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BigMapMonsterInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // optional int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 monid = 3;
  if (has_monid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->monid(), output);
  }

}

int BigMapMonsterInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional int32 monid = 3;
    if (has_monid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->monid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BigMapMonsterInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BigMapMonsterInfo*>(&from));
}

void BigMapMonsterInfo::MergeFrom(const BigMapMonsterInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_monid()) {
      set_monid(from.monid());
    }
  }
}

void BigMapMonsterInfo::CopyFrom(const BigMapMonsterInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BigMapMonsterInfo::IsInitialized() const {

  return true;
}

void BigMapMonsterInfo::Swap(BigMapMonsterInfo* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(monid_, other->monid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BigMapMonsterInfo::GetTypeName() const {
  return "Protocol.BigMapMonsterInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int BigMapJumpPointInfo::kXFieldNumber;
const int BigMapJumpPointInfo::kYFieldNumber;
const int BigMapJumpPointInfo::kMapIdFieldNumber;
#endif  // !_MSC_VER

BigMapJumpPointInfo::BigMapJumpPointInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void BigMapJumpPointInfo::InitAsDefaultInstance() {
}

BigMapJumpPointInfo::BigMapJumpPointInfo(const BigMapJumpPointInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void BigMapJumpPointInfo::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  map_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BigMapJumpPointInfo::~BigMapJumpPointInfo() {
  SharedDtor();
}

void BigMapJumpPointInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BigMapJumpPointInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BigMapJumpPointInfo& BigMapJumpPointInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

BigMapJumpPointInfo* BigMapJumpPointInfo::default_instance_ = NULL;

BigMapJumpPointInfo* BigMapJumpPointInfo::New() const {
  return new BigMapJumpPointInfo;
}

void BigMapJumpPointInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
    map_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool BigMapJumpPointInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional int32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_map_id;
        break;
      }

      // optional int32 map_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_map_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void BigMapJumpPointInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // optional int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

  // optional int32 map_id = 3;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->map_id(), output);
  }

}

int BigMapJumpPointInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

    // optional int32 map_id = 3;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BigMapJumpPointInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BigMapJumpPointInfo*>(&from));
}

void BigMapJumpPointInfo::MergeFrom(const BigMapJumpPointInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
  }
}

void BigMapJumpPointInfo::CopyFrom(const BigMapJumpPointInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BigMapJumpPointInfo::IsInitialized() const {

  return true;
}

void BigMapJumpPointInfo::Swap(BigMapJumpPointInfo* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(map_id_, other->map_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string BigMapJumpPointInfo::GetTypeName() const {
  return "Protocol.BigMapJumpPointInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetBigMapInfo::kMapIdFieldNumber;
#endif  // !_MSC_VER

RequestGetBigMapInfo::RequestGetBigMapInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetBigMapInfo::InitAsDefaultInstance() {
}

RequestGetBigMapInfo::RequestGetBigMapInfo(const RequestGetBigMapInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetBigMapInfo::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetBigMapInfo::~RequestGetBigMapInfo() {
  SharedDtor();
}

void RequestGetBigMapInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetBigMapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetBigMapInfo& RequestGetBigMapInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

RequestGetBigMapInfo* RequestGetBigMapInfo::default_instance_ = NULL;

RequestGetBigMapInfo* RequestGetBigMapInfo::New() const {
  return new RequestGetBigMapInfo;
}

void RequestGetBigMapInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetBigMapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetBigMapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->map_id(), output);
  }

}

int RequestGetBigMapInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetBigMapInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetBigMapInfo*>(&from));
}

void RequestGetBigMapInfo::MergeFrom(const RequestGetBigMapInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
  }
}

void RequestGetBigMapInfo::CopyFrom(const RequestGetBigMapInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetBigMapInfo::IsInitialized() const {

  return true;
}

void RequestGetBigMapInfo::Swap(RequestGetBigMapInfo* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetBigMapInfo::GetTypeName() const {
  return "Protocol.RequestGetBigMapInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetBigMapInfo::kNpcListFieldNumber;
const int ResponseGetBigMapInfo::kMonsterListFieldNumber;
const int ResponseGetBigMapInfo::kJumppointListFieldNumber;
#endif  // !_MSC_VER

ResponseGetBigMapInfo::ResponseGetBigMapInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetBigMapInfo::InitAsDefaultInstance() {
}

ResponseGetBigMapInfo::ResponseGetBigMapInfo(const ResponseGetBigMapInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetBigMapInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetBigMapInfo::~ResponseGetBigMapInfo() {
  SharedDtor();
}

void ResponseGetBigMapInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetBigMapInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetBigMapInfo& ResponseGetBigMapInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

ResponseGetBigMapInfo* ResponseGetBigMapInfo::default_instance_ = NULL;

ResponseGetBigMapInfo* ResponseGetBigMapInfo::New() const {
  return new ResponseGetBigMapInfo;
}

void ResponseGetBigMapInfo::Clear() {
  npc_list_.Clear();
  monster_list_.Clear();
  jumppoint_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetBigMapInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.BigMapNpcInfo npc_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_npc_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_npc_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_npc_list;
        if (input->ExpectTag(18)) goto parse_monster_list;
        break;
      }

      // repeated .Protocol.BigMapMonsterInfo monster_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_monster_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_monster_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_monster_list;
        if (input->ExpectTag(26)) goto parse_jumppoint_list;
        break;
      }

      // repeated .Protocol.BigMapJumpPointInfo jumppoint_list = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_jumppoint_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_jumppoint_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_jumppoint_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetBigMapInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.BigMapNpcInfo npc_list = 1;
  for (int i = 0; i < this->npc_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->npc_list(i), output);
  }

  // repeated .Protocol.BigMapMonsterInfo monster_list = 2;
  for (int i = 0; i < this->monster_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->monster_list(i), output);
  }

  // repeated .Protocol.BigMapJumpPointInfo jumppoint_list = 3;
  for (int i = 0; i < this->jumppoint_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->jumppoint_list(i), output);
  }

}

int ResponseGetBigMapInfo::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.BigMapNpcInfo npc_list = 1;
  total_size += 1 * this->npc_list_size();
  for (int i = 0; i < this->npc_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->npc_list(i));
  }

  // repeated .Protocol.BigMapMonsterInfo monster_list = 2;
  total_size += 1 * this->monster_list_size();
  for (int i = 0; i < this->monster_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->monster_list(i));
  }

  // repeated .Protocol.BigMapJumpPointInfo jumppoint_list = 3;
  total_size += 1 * this->jumppoint_list_size();
  for (int i = 0; i < this->jumppoint_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->jumppoint_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetBigMapInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetBigMapInfo*>(&from));
}

void ResponseGetBigMapInfo::MergeFrom(const ResponseGetBigMapInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  npc_list_.MergeFrom(from.npc_list_);
  monster_list_.MergeFrom(from.monster_list_);
  jumppoint_list_.MergeFrom(from.jumppoint_list_);
}

void ResponseGetBigMapInfo::CopyFrom(const ResponseGetBigMapInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetBigMapInfo::IsInitialized() const {

  return true;
}

void ResponseGetBigMapInfo::Swap(ResponseGetBigMapInfo* other) {
  if (other != this) {
    npc_list_.Swap(&other->npc_list_);
    monster_list_.Swap(&other->monster_list_);
    jumppoint_list_.Swap(&other->jumppoint_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetBigMapInfo::GetTypeName() const {
  return "Protocol.ResponseGetBigMapInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetGoHomeMoney::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestGetGoHomeMoney::RequestGetGoHomeMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetGoHomeMoney::InitAsDefaultInstance() {
}

RequestGetGoHomeMoney::RequestGetGoHomeMoney(const RequestGetGoHomeMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetGoHomeMoney::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetGoHomeMoney::~RequestGetGoHomeMoney() {
  SharedDtor();
}

void RequestGetGoHomeMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetGoHomeMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetGoHomeMoney& RequestGetGoHomeMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

RequestGetGoHomeMoney* RequestGetGoHomeMoney::default_instance_ = NULL;

RequestGetGoHomeMoney* RequestGetGoHomeMoney::New() const {
  return new RequestGetGoHomeMoney;
}

void RequestGetGoHomeMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetGoHomeMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetGoHomeMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestGetGoHomeMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetGoHomeMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetGoHomeMoney*>(&from));
}

void RequestGetGoHomeMoney::MergeFrom(const RequestGetGoHomeMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestGetGoHomeMoney::CopyFrom(const RequestGetGoHomeMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetGoHomeMoney::IsInitialized() const {

  return true;
}

void RequestGetGoHomeMoney::Swap(RequestGetGoHomeMoney* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetGoHomeMoney::GetTypeName() const {
  return "Protocol.RequestGetGoHomeMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetGoHomeMoney::kMoneyFieldNumber;
#endif  // !_MSC_VER

ResponseGetGoHomeMoney::ResponseGetGoHomeMoney()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetGoHomeMoney::InitAsDefaultInstance() {
}

ResponseGetGoHomeMoney::ResponseGetGoHomeMoney(const ResponseGetGoHomeMoney& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetGoHomeMoney::SharedCtor() {
  _cached_size_ = 0;
  money_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetGoHomeMoney::~ResponseGetGoHomeMoney() {
  SharedDtor();
}

void ResponseGetGoHomeMoney::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetGoHomeMoney::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetGoHomeMoney& ResponseGetGoHomeMoney::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

ResponseGetGoHomeMoney* ResponseGetGoHomeMoney::default_instance_ = NULL;

ResponseGetGoHomeMoney* ResponseGetGoHomeMoney::New() const {
  return new ResponseGetGoHomeMoney;
}

void ResponseGetGoHomeMoney::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    money_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetGoHomeMoney::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 money = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetGoHomeMoney::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 money = 1;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->money(), output);
  }

}

int ResponseGetGoHomeMoney::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 money = 1;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetGoHomeMoney::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetGoHomeMoney*>(&from));
}

void ResponseGetGoHomeMoney::MergeFrom(const ResponseGetGoHomeMoney& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_money()) {
      set_money(from.money());
    }
  }
}

void ResponseGetGoHomeMoney::CopyFrom(const ResponseGetGoHomeMoney& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetGoHomeMoney::IsInitialized() const {

  return true;
}

void ResponseGetGoHomeMoney::Swap(ResponseGetGoHomeMoney* other) {
  if (other != this) {
    std::swap(money_, other->money_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetGoHomeMoney::GetTypeName() const {
  return "Protocol.ResponseGetGoHomeMoney";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGoHome::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestGoHome::RequestGoHome()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGoHome::InitAsDefaultInstance() {
}

RequestGoHome::RequestGoHome(const RequestGoHome& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGoHome::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGoHome::~RequestGoHome() {
  SharedDtor();
}

void RequestGoHome::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGoHome::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGoHome& RequestGoHome::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

RequestGoHome* RequestGoHome::default_instance_ = NULL;

RequestGoHome* RequestGoHome::New() const {
  return new RequestGoHome;
}

void RequestGoHome::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGoHome::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGoHome::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestGoHome::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGoHome::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGoHome*>(&from));
}

void RequestGoHome::MergeFrom(const RequestGoHome& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestGoHome::CopyFrom(const RequestGoHome& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGoHome::IsInitialized() const {

  return true;
}

void RequestGoHome::Swap(RequestGoHome* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGoHome::GetTypeName() const {
  return "Protocol.RequestGoHome";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyDuplicateVote::kMapIdFieldNumber;
const int NotifyDuplicateVote::kCharnameFieldNumber;
#endif  // !_MSC_VER

NotifyDuplicateVote::NotifyDuplicateVote()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyDuplicateVote::InitAsDefaultInstance() {
}

NotifyDuplicateVote::NotifyDuplicateVote(const NotifyDuplicateVote& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyDuplicateVote::SharedCtor() {
  _cached_size_ = 0;
  map_id_ = 0;
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyDuplicateVote::~NotifyDuplicateVote() {
  SharedDtor();
}

void NotifyDuplicateVote::SharedDtor() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyDuplicateVote::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyDuplicateVote& NotifyDuplicateVote::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

NotifyDuplicateVote* NotifyDuplicateVote::default_instance_ = NULL;

NotifyDuplicateVote* NotifyDuplicateVote::New() const {
  return new NotifyDuplicateVote;
}

void NotifyDuplicateVote::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    map_id_ = 0;
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyDuplicateVote::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 map_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &map_id_)));
          set_has_map_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_charname;
        break;
      }

      // optional string charname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyDuplicateVote::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 map_id = 1;
  if (has_map_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->map_id(), output);
  }

  // optional string charname = 2;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->charname(), output);
  }

}

int NotifyDuplicateVote::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 map_id = 1;
    if (has_map_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->map_id());
    }

    // optional string charname = 2;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyDuplicateVote::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyDuplicateVote*>(&from));
}

void NotifyDuplicateVote::MergeFrom(const NotifyDuplicateVote& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_id()) {
      set_map_id(from.map_id());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
  }
}

void NotifyDuplicateVote::CopyFrom(const NotifyDuplicateVote& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyDuplicateVote::IsInitialized() const {

  return true;
}

void NotifyDuplicateVote::Swap(NotifyDuplicateVote* other) {
  if (other != this) {
    std::swap(map_id_, other->map_id_);
    std::swap(charname_, other->charname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyDuplicateVote::GetTypeName() const {
  return "Protocol.NotifyDuplicateVote";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestDuplicateVoteResult::kAgreeFieldNumber;
#endif  // !_MSC_VER

RequestDuplicateVoteResult::RequestDuplicateVoteResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestDuplicateVoteResult::InitAsDefaultInstance() {
}

RequestDuplicateVoteResult::RequestDuplicateVoteResult(const RequestDuplicateVoteResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestDuplicateVoteResult::SharedCtor() {
  _cached_size_ = 0;
  agree_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestDuplicateVoteResult::~RequestDuplicateVoteResult() {
  SharedDtor();
}

void RequestDuplicateVoteResult::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestDuplicateVoteResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestDuplicateVoteResult& RequestDuplicateVoteResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

RequestDuplicateVoteResult* RequestDuplicateVoteResult::default_instance_ = NULL;

RequestDuplicateVoteResult* RequestDuplicateVoteResult::New() const {
  return new RequestDuplicateVoteResult;
}

void RequestDuplicateVoteResult::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    agree_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestDuplicateVoteResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool agree = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &agree_)));
          set_has_agree();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestDuplicateVoteResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool agree = 1;
  if (has_agree()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->agree(), output);
  }

}

int RequestDuplicateVoteResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool agree = 1;
    if (has_agree()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestDuplicateVoteResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestDuplicateVoteResult*>(&from));
}

void RequestDuplicateVoteResult::MergeFrom(const RequestDuplicateVoteResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_agree()) {
      set_agree(from.agree());
    }
  }
}

void RequestDuplicateVoteResult::CopyFrom(const RequestDuplicateVoteResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDuplicateVoteResult::IsInitialized() const {

  return true;
}

void RequestDuplicateVoteResult::Swap(RequestDuplicateVoteResult* other) {
  if (other != this) {
    std::swap(agree_, other->agree_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestDuplicateVoteResult::GetTypeName() const {
  return "Protocol.RequestDuplicateVoteResult";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestDuplicateExit::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestDuplicateExit::RequestDuplicateExit()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestDuplicateExit::InitAsDefaultInstance() {
}

RequestDuplicateExit::RequestDuplicateExit(const RequestDuplicateExit& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestDuplicateExit::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestDuplicateExit::~RequestDuplicateExit() {
  SharedDtor();
}

void RequestDuplicateExit::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestDuplicateExit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestDuplicateExit& RequestDuplicateExit::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

RequestDuplicateExit* RequestDuplicateExit::default_instance_ = NULL;

RequestDuplicateExit* RequestDuplicateExit::New() const {
  return new RequestDuplicateExit;
}

void RequestDuplicateExit::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestDuplicateExit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestDuplicateExit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestDuplicateExit::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestDuplicateExit::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestDuplicateExit*>(&from));
}

void RequestDuplicateExit::MergeFrom(const RequestDuplicateExit& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestDuplicateExit::CopyFrom(const RequestDuplicateExit& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDuplicateExit::IsInitialized() const {

  return true;
}

void RequestDuplicateExit::Swap(RequestDuplicateExit* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestDuplicateExit::GetTypeName() const {
  return "Protocol.RequestDuplicateExit";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestCrossMapPath::kObjectTypeFieldNumber;
const int RequestCrossMapPath::kIdFieldNumber;
#endif  // !_MSC_VER

RequestCrossMapPath::RequestCrossMapPath()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestCrossMapPath::InitAsDefaultInstance() {
}

RequestCrossMapPath::RequestCrossMapPath(const RequestCrossMapPath& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestCrossMapPath::SharedCtor() {
  _cached_size_ = 0;
  object_type_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestCrossMapPath::~RequestCrossMapPath() {
  SharedDtor();
}

void RequestCrossMapPath::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestCrossMapPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestCrossMapPath& RequestCrossMapPath::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

RequestCrossMapPath* RequestCrossMapPath::default_instance_ = NULL;

RequestCrossMapPath* RequestCrossMapPath::New() const {
  return new RequestCrossMapPath;
}

void RequestCrossMapPath::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    object_type_ = 0;
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestCrossMapPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 object_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_type_)));
          set_has_object_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional int32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestCrossMapPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 object_type = 1;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_type(), output);
  }

  // optional int32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

}

int RequestCrossMapPath::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 object_type = 1;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->object_type());
    }

    // optional int32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestCrossMapPath::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestCrossMapPath*>(&from));
}

void RequestCrossMapPath::MergeFrom(const RequestCrossMapPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void RequestCrossMapPath::CopyFrom(const RequestCrossMapPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestCrossMapPath::IsInitialized() const {

  return true;
}

void RequestCrossMapPath::Swap(RequestCrossMapPath* other) {
  if (other != this) {
    std::swap(object_type_, other->object_type_);
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestCrossMapPath::GetTypeName() const {
  return "Protocol.RequestCrossMapPath";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseCrossMapPath_PathNode::kXFieldNumber;
const int ResponseCrossMapPath_PathNode::kYFieldNumber;
#endif  // !_MSC_VER

ResponseCrossMapPath_PathNode::ResponseCrossMapPath_PathNode()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseCrossMapPath_PathNode::InitAsDefaultInstance() {
}

ResponseCrossMapPath_PathNode::ResponseCrossMapPath_PathNode(const ResponseCrossMapPath_PathNode& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseCrossMapPath_PathNode::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseCrossMapPath_PathNode::~ResponseCrossMapPath_PathNode() {
  SharedDtor();
}

void ResponseCrossMapPath_PathNode::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseCrossMapPath_PathNode::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseCrossMapPath_PathNode& ResponseCrossMapPath_PathNode::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

ResponseCrossMapPath_PathNode* ResponseCrossMapPath_PathNode::default_instance_ = NULL;

ResponseCrossMapPath_PathNode* ResponseCrossMapPath_PathNode::New() const {
  return new ResponseCrossMapPath_PathNode;
}

void ResponseCrossMapPath_PathNode::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    y_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseCrossMapPath_PathNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 x = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_y;
        break;
      }

      // optional int32 y = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseCrossMapPath_PathNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->x(), output);
  }

  // optional int32 y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->y(), output);
  }

}

int ResponseCrossMapPath_PathNode::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 x = 1;
    if (has_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->x());
    }

    // optional int32 y = 2;
    if (has_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->y());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseCrossMapPath_PathNode::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseCrossMapPath_PathNode*>(&from));
}

void ResponseCrossMapPath_PathNode::MergeFrom(const ResponseCrossMapPath_PathNode& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
  }
}

void ResponseCrossMapPath_PathNode::CopyFrom(const ResponseCrossMapPath_PathNode& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseCrossMapPath_PathNode::IsInitialized() const {

  return true;
}

void ResponseCrossMapPath_PathNode::Swap(ResponseCrossMapPath_PathNode* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseCrossMapPath_PathNode::GetTypeName() const {
  return "Protocol.ResponseCrossMapPath.PathNode";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int ResponseCrossMapPath::kObjectTypeFieldNumber;
const int ResponseCrossMapPath::kIdFieldNumber;
const int ResponseCrossMapPath::kPathNodeFieldNumber;
#endif  // !_MSC_VER

ResponseCrossMapPath::ResponseCrossMapPath()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseCrossMapPath::InitAsDefaultInstance() {
}

ResponseCrossMapPath::ResponseCrossMapPath(const ResponseCrossMapPath& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseCrossMapPath::SharedCtor() {
  _cached_size_ = 0;
  object_type_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseCrossMapPath::~ResponseCrossMapPath() {
  SharedDtor();
}

void ResponseCrossMapPath::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseCrossMapPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseCrossMapPath& ResponseCrossMapPath::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoScene_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoScene_2eproto();
#endif
  return *default_instance_;
}

ResponseCrossMapPath* ResponseCrossMapPath::default_instance_ = NULL;

ResponseCrossMapPath* ResponseCrossMapPath::New() const {
  return new ResponseCrossMapPath;
}

void ResponseCrossMapPath::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    object_type_ = 0;
    id_ = 0;
  }
  path_node_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseCrossMapPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 object_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_type_)));
          set_has_object_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional int32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_path_node;
        break;
      }

      // repeated .Protocol.ResponseCrossMapPath.PathNode path_node = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_path_node()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_path_node;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseCrossMapPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 object_type = 1;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->object_type(), output);
  }

  // optional int32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

  // repeated .Protocol.ResponseCrossMapPath.PathNode path_node = 3;
  for (int i = 0; i < this->path_node_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->path_node(i), output);
  }

}

int ResponseCrossMapPath::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 object_type = 1;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->object_type());
    }

    // optional int32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  // repeated .Protocol.ResponseCrossMapPath.PathNode path_node = 3;
  total_size += 1 * this->path_node_size();
  for (int i = 0; i < this->path_node_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->path_node(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseCrossMapPath::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseCrossMapPath*>(&from));
}

void ResponseCrossMapPath::MergeFrom(const ResponseCrossMapPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  path_node_.MergeFrom(from.path_node_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void ResponseCrossMapPath::CopyFrom(const ResponseCrossMapPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseCrossMapPath::IsInitialized() const {

  return true;
}

void ResponseCrossMapPath::Swap(ResponseCrossMapPath* other) {
  if (other != this) {
    std::swap(object_type_, other->object_type_);
    std::swap(id_, other->id_);
    path_node_.Swap(&other->path_node_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseCrossMapPath::GetTypeName() const {
  return "Protocol.ResponseCrossMapPath";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)
