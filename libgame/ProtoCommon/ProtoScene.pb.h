// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoScene.proto

#ifndef PROTOBUF_ProtoScene_2eproto__INCLUDED
#define PROTOBUF_ProtoScene_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoScene_2eproto();
void protobuf_AssignDesc_ProtoScene_2eproto();
void protobuf_ShutdownFile_ProtoScene_2eproto();

class NotifyCreateChar;
class NotifyRemoveChar;
class MsgCharMove;
class MsgCharStopMove;
class NotifyCreateMonster;
class NotifyRemoveMonster;
class NotifyMonsterMove;
class NotifyMonsterStopMove;
class NotifyCreateNpc;
class NotifyRemoveNpc;
class NotifyNpcMove;
class NotifyNpcStopMove;
class NotifyMonsterDead;
class NotifyMonsterDisappear;
class NotifyMonsterRevive;
class NotifyCharDead;
class NotifyCharDisappear;
class RequestCharRevive;
class NotifyCharRevive;
class NotifyCharLevel;
class JumpPoint;
class NotifyCreateJumpPoint;
class NotifyCharChangeMap;
class NotifySceneUpdateCharProperty;
class NotifySceneUpdateMonsterProperty;
class BigMapNpcInfo;
class BigMapMonsterInfo;
class BigMapJumpPointInfo;
class RequestGetBigMapInfo;
class ResponseGetBigMapInfo;
class RequestGetGoHomeMoney;
class ResponseGetGoHomeMoney;
class RequestGoHome;
class NotifyDuplicateVote;
class RequestDuplicateVoteResult;
class RequestDuplicateExit;
class RequestCrossMapPath;
class ResponseCrossMapPath;
class ResponseCrossMapPath_PathNode;

enum SceneOpCode {
  OP_SCENE_CREATE_CHAR = 1,
  OP_SCENE_REMOVE_CHAR = 2,
  OP_SCENE_CHAR_MOVE = 3,
  OP_SCENE_CHAR_STOP_MOVE = 4,
  OP_SCENE_CREATE_MONSTER = 10,
  OP_SCENE_REMOVE_MONSTER = 11,
  OP_SCENE_MONSTER_MOVE = 12,
  OP_SCENE_MONSTER_STOP_MOVE = 13,
  OP_SCENE_CREATE_NPC = 20,
  OP_SCENE_REMOVE_NPC = 21,
  OP_SCENE_NPC_MOVE = 22,
  OP_SCENE_NPC_STOP_MOVE = 23,
  OP_MONSTER_DEAD = 30,
  OP_MONSTER_DISAPPEAR = 31,
  OP_MONSTER_REVIVE = 32,
  OP_CHAR_DEAD = 40,
  OP_CHAR_DISAPPEAR = 41,
  OP_CHAR_REVIVE = 42,
  OP_CHAR_LEVELUP = 43,
  OP_CREATE_JUMP_POINT = 50,
  OP_CHAR_CHANGE_MAP = 51,
  OP_SCENE_UPDATE_CHAR_PROPERTY = 60,
  OP_SCENE_UPDATE_MONSTER_PROPERTY = 61,
  OP_GET_BIGMAP_INFO = 62,
  OP_SCENE_GET_GOHOME_MONEY = 63,
  OP_SCENE_GO_HOME = 64,
  OP_DUPLICATE_VOTE = 65,
  OP_DUPLICATE_VOTE_RESULT = 66,
  OP_DUPLICATE_EXIT = 67,
  OP_CROSSMAP_PATH = 68
};
bool SceneOpCode_IsValid(int value);
const SceneOpCode SceneOpCode_MIN = OP_SCENE_CREATE_CHAR;
const SceneOpCode SceneOpCode_MAX = OP_CROSSMAP_PATH;
const int SceneOpCode_ARRAYSIZE = SceneOpCode_MAX + 1;

enum ReviveType {
  REVIVE_HOME = 0,
  REVIVE_LOCAL = 1
};
bool ReviveType_IsValid(int value);
const ReviveType ReviveType_MIN = REVIVE_HOME;
const ReviveType ReviveType_MAX = REVIVE_LOCAL;
const int ReviveType_ARRAYSIZE = ReviveType_MAX + 1;

// ===================================================================

class NotifyCreateChar : public ::google::protobuf::MessageLite {
 public:
  NotifyCreateChar();
  virtual ~NotifyCreateChar();

  NotifyCreateChar(const NotifyCreateChar& from);

  inline NotifyCreateChar& operator=(const NotifyCreateChar& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCreateChar& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCreateChar* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCreateChar* other);

  // implements Message ----------------------------------------------

  NotifyCreateChar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCreateChar& from);
  void MergeFrom(const NotifyCreateChar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapCharInfo char_list = 1;
  inline int char_list_size() const;
  inline void clear_char_list();
  static const int kCharListFieldNumber = 1;
  inline const ::MapCharInfo& char_list(int index) const;
  inline ::MapCharInfo* mutable_char_list(int index);
  inline ::MapCharInfo* add_char_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MapCharInfo >&
      char_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapCharInfo >*
      mutable_char_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCreateChar)
 private:

  ::google::protobuf::RepeatedPtrField< ::MapCharInfo > char_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCreateChar* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRemoveChar : public ::google::protobuf::MessageLite {
 public:
  NotifyRemoveChar();
  virtual ~NotifyRemoveChar();

  NotifyRemoveChar(const NotifyRemoveChar& from);

  inline NotifyRemoveChar& operator=(const NotifyRemoveChar& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyRemoveChar& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRemoveChar* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRemoveChar* other);

  // implements Message ----------------------------------------------

  NotifyRemoveChar* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRemoveChar& from);
  void MergeFrom(const NotifyRemoveChar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyRemoveChar)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyRemoveChar* default_instance_;
};
// -------------------------------------------------------------------

class MsgCharMove : public ::google::protobuf::MessageLite {
 public:
  MsgCharMove();
  virtual ~MsgCharMove();

  MsgCharMove(const MsgCharMove& from);

  inline MsgCharMove& operator=(const MsgCharMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const MsgCharMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgCharMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgCharMove* other);

  // implements Message ----------------------------------------------

  MsgCharMove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgCharMove& from);
  void MergeFrom(const MsgCharMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 flag = 5;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 5;
  inline ::google::protobuf::int32 flag() const;
  inline void set_flag(::google::protobuf::int32 value);

  // optional int32 direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.MsgCharMove)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 flag_;
  ::google::protobuf::int32 direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static MsgCharMove* default_instance_;
};
// -------------------------------------------------------------------

class MsgCharStopMove : public ::google::protobuf::MessageLite {
 public:
  MsgCharStopMove();
  virtual ~MsgCharStopMove();

  MsgCharStopMove(const MsgCharStopMove& from);

  inline MsgCharStopMove& operator=(const MsgCharStopMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const MsgCharStopMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgCharStopMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgCharStopMove* other);

  // implements Message ----------------------------------------------

  MsgCharStopMove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgCharStopMove& from);
  void MergeFrom(const MsgCharStopMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.MsgCharStopMove)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static MsgCharStopMove* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCreateMonster : public ::google::protobuf::MessageLite {
 public:
  NotifyCreateMonster();
  virtual ~NotifyCreateMonster();

  NotifyCreateMonster(const NotifyCreateMonster& from);

  inline NotifyCreateMonster& operator=(const NotifyCreateMonster& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCreateMonster& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCreateMonster* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCreateMonster* other);

  // implements Message ----------------------------------------------

  NotifyCreateMonster* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCreateMonster& from);
  void MergeFrom(const NotifyCreateMonster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapMonsterInfo mon_list = 1;
  inline int mon_list_size() const;
  inline void clear_mon_list();
  static const int kMonListFieldNumber = 1;
  inline const ::MapMonsterInfo& mon_list(int index) const;
  inline ::MapMonsterInfo* mutable_mon_list(int index);
  inline ::MapMonsterInfo* add_mon_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MapMonsterInfo >&
      mon_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapMonsterInfo >*
      mutable_mon_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCreateMonster)
 private:

  ::google::protobuf::RepeatedPtrField< ::MapMonsterInfo > mon_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCreateMonster* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRemoveMonster : public ::google::protobuf::MessageLite {
 public:
  NotifyRemoveMonster();
  virtual ~NotifyRemoveMonster();

  NotifyRemoveMonster(const NotifyRemoveMonster& from);

  inline NotifyRemoveMonster& operator=(const NotifyRemoveMonster& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyRemoveMonster& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRemoveMonster* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRemoveMonster* other);

  // implements Message ----------------------------------------------

  NotifyRemoveMonster* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRemoveMonster& from);
  void MergeFrom(const NotifyRemoveMonster& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyRemoveMonster)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyRemoveMonster* default_instance_;
};
// -------------------------------------------------------------------

class NotifyMonsterMove : public ::google::protobuf::MessageLite {
 public:
  NotifyMonsterMove();
  virtual ~NotifyMonsterMove();

  NotifyMonsterMove(const NotifyMonsterMove& from);

  inline NotifyMonsterMove& operator=(const NotifyMonsterMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyMonsterMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyMonsterMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyMonsterMove* other);

  // implements Message ----------------------------------------------

  NotifyMonsterMove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyMonsterMove& from);
  void MergeFrom(const NotifyMonsterMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyMonsterMove)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyMonsterMove* default_instance_;
};
// -------------------------------------------------------------------

class NotifyMonsterStopMove : public ::google::protobuf::MessageLite {
 public:
  NotifyMonsterStopMove();
  virtual ~NotifyMonsterStopMove();

  NotifyMonsterStopMove(const NotifyMonsterStopMove& from);

  inline NotifyMonsterStopMove& operator=(const NotifyMonsterStopMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyMonsterStopMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyMonsterStopMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyMonsterStopMove* other);

  // implements Message ----------------------------------------------

  NotifyMonsterStopMove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyMonsterStopMove& from);
  void MergeFrom(const NotifyMonsterStopMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyMonsterStopMove)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyMonsterStopMove* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCreateNpc : public ::google::protobuf::MessageLite {
 public:
  NotifyCreateNpc();
  virtual ~NotifyCreateNpc();

  NotifyCreateNpc(const NotifyCreateNpc& from);

  inline NotifyCreateNpc& operator=(const NotifyCreateNpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCreateNpc& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCreateNpc* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCreateNpc* other);

  // implements Message ----------------------------------------------

  NotifyCreateNpc* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCreateNpc& from);
  void MergeFrom(const NotifyCreateNpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapNpcInfo npc_list = 1;
  inline int npc_list_size() const;
  inline void clear_npc_list();
  static const int kNpcListFieldNumber = 1;
  inline const ::MapNpcInfo& npc_list(int index) const;
  inline ::MapNpcInfo* mutable_npc_list(int index);
  inline ::MapNpcInfo* add_npc_list();
  inline const ::google::protobuf::RepeatedPtrField< ::MapNpcInfo >&
      npc_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapNpcInfo >*
      mutable_npc_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCreateNpc)
 private:

  ::google::protobuf::RepeatedPtrField< ::MapNpcInfo > npc_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCreateNpc* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRemoveNpc : public ::google::protobuf::MessageLite {
 public:
  NotifyRemoveNpc();
  virtual ~NotifyRemoveNpc();

  NotifyRemoveNpc(const NotifyRemoveNpc& from);

  inline NotifyRemoveNpc& operator=(const NotifyRemoveNpc& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyRemoveNpc& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRemoveNpc* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRemoveNpc* other);

  // implements Message ----------------------------------------------

  NotifyRemoveNpc* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRemoveNpc& from);
  void MergeFrom(const NotifyRemoveNpc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyRemoveNpc)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyRemoveNpc* default_instance_;
};
// -------------------------------------------------------------------

class NotifyNpcMove : public ::google::protobuf::MessageLite {
 public:
  NotifyNpcMove();
  virtual ~NotifyNpcMove();

  NotifyNpcMove(const NotifyNpcMove& from);

  inline NotifyNpcMove& operator=(const NotifyNpcMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyNpcMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyNpcMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyNpcMove* other);

  // implements Message ----------------------------------------------

  NotifyNpcMove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyNpcMove& from);
  void MergeFrom(const NotifyNpcMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyNpcMove)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyNpcMove* default_instance_;
};
// -------------------------------------------------------------------

class NotifyNpcStopMove : public ::google::protobuf::MessageLite {
 public:
  NotifyNpcStopMove();
  virtual ~NotifyNpcStopMove();

  NotifyNpcStopMove(const NotifyNpcStopMove& from);

  inline NotifyNpcStopMove& operator=(const NotifyNpcStopMove& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyNpcStopMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyNpcStopMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyNpcStopMove* other);

  // implements Message ----------------------------------------------

  NotifyNpcStopMove* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyNpcStopMove& from);
  void MergeFrom(const NotifyNpcStopMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyNpcStopMove)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyNpcStopMove* default_instance_;
};
// -------------------------------------------------------------------

class NotifyMonsterDead : public ::google::protobuf::MessageLite {
 public:
  NotifyMonsterDead();
  virtual ~NotifyMonsterDead();

  NotifyMonsterDead(const NotifyMonsterDead& from);

  inline NotifyMonsterDead& operator=(const NotifyMonsterDead& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyMonsterDead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyMonsterDead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyMonsterDead* other);

  // implements Message ----------------------------------------------

  NotifyMonsterDead* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyMonsterDead& from);
  void MergeFrom(const NotifyMonsterDead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 attacker_id = 3;
  inline bool has_attacker_id() const;
  inline void clear_attacker_id();
  static const int kAttackerIdFieldNumber = 3;
  inline ::google::protobuf::int32 attacker_id() const;
  inline void set_attacker_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyMonsterDead)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_attacker_id();
  inline void clear_has_attacker_id();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 attacker_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyMonsterDead* default_instance_;
};
// -------------------------------------------------------------------

class NotifyMonsterDisappear : public ::google::protobuf::MessageLite {
 public:
  NotifyMonsterDisappear();
  virtual ~NotifyMonsterDisappear();

  NotifyMonsterDisappear(const NotifyMonsterDisappear& from);

  inline NotifyMonsterDisappear& operator=(const NotifyMonsterDisappear& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyMonsterDisappear& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyMonsterDisappear* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyMonsterDisappear* other);

  // implements Message ----------------------------------------------

  NotifyMonsterDisappear* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyMonsterDisappear& from);
  void MergeFrom(const NotifyMonsterDisappear& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyMonsterDisappear)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyMonsterDisappear* default_instance_;
};
// -------------------------------------------------------------------

class NotifyMonsterRevive : public ::google::protobuf::MessageLite {
 public:
  NotifyMonsterRevive();
  virtual ~NotifyMonsterRevive();

  NotifyMonsterRevive(const NotifyMonsterRevive& from);

  inline NotifyMonsterRevive& operator=(const NotifyMonsterRevive& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyMonsterRevive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyMonsterRevive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyMonsterRevive* other);

  // implements Message ----------------------------------------------

  NotifyMonsterRevive* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyMonsterRevive& from);
  void MergeFrom(const NotifyMonsterRevive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MapMonsterInfo moninfo = 1;
  inline bool has_moninfo() const;
  inline void clear_moninfo();
  static const int kMoninfoFieldNumber = 1;
  inline const ::MapMonsterInfo& moninfo() const;
  inline ::MapMonsterInfo* mutable_moninfo();
  inline ::MapMonsterInfo* release_moninfo();
  inline void set_allocated_moninfo(::MapMonsterInfo* moninfo);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyMonsterRevive)
 private:
  inline void set_has_moninfo();
  inline void clear_has_moninfo();

  ::MapMonsterInfo* moninfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyMonsterRevive* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCharDead : public ::google::protobuf::MessageLite {
 public:
  NotifyCharDead();
  virtual ~NotifyCharDead();

  NotifyCharDead(const NotifyCharDead& from);

  inline NotifyCharDead& operator=(const NotifyCharDead& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCharDead& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCharDead* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCharDead* other);

  // implements Message ----------------------------------------------

  NotifyCharDead* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCharDead& from);
  void MergeFrom(const NotifyCharDead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 exp = 2;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 2;
  inline ::google::protobuf::int32 exp() const;
  inline void set_exp(::google::protobuf::int32 value);

  // optional int32 attacker_id = 3;
  inline bool has_attacker_id() const;
  inline void clear_attacker_id();
  static const int kAttackerIdFieldNumber = 3;
  inline ::google::protobuf::int32 attacker_id() const;
  inline void set_attacker_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCharDead)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_attacker_id();
  inline void clear_has_attacker_id();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 exp_;
  ::google::protobuf::int32 attacker_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCharDead* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCharDisappear : public ::google::protobuf::MessageLite {
 public:
  NotifyCharDisappear();
  virtual ~NotifyCharDisappear();

  NotifyCharDisappear(const NotifyCharDisappear& from);

  inline NotifyCharDisappear& operator=(const NotifyCharDisappear& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCharDisappear& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCharDisappear* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCharDisappear* other);

  // implements Message ----------------------------------------------

  NotifyCharDisappear* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCharDisappear& from);
  void MergeFrom(const NotifyCharDisappear& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCharDisappear)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCharDisappear* default_instance_;
};
// -------------------------------------------------------------------

class RequestCharRevive : public ::google::protobuf::MessageLite {
 public:
  RequestCharRevive();
  virtual ~RequestCharRevive();

  RequestCharRevive(const RequestCharRevive& from);

  inline RequestCharRevive& operator=(const RequestCharRevive& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestCharRevive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCharRevive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCharRevive* other);

  // implements Message ----------------------------------------------

  RequestCharRevive* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCharRevive& from);
  void MergeFrom(const RequestCharRevive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.ReviveType revive_type = 1;
  inline bool has_revive_type() const;
  inline void clear_revive_type();
  static const int kReviveTypeFieldNumber = 1;
  inline ::Protocol::ReviveType revive_type() const;
  inline void set_revive_type(::Protocol::ReviveType value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestCharRevive)
 private:
  inline void set_has_revive_type();
  inline void clear_has_revive_type();

  int revive_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static RequestCharRevive* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCharRevive : public ::google::protobuf::MessageLite {
 public:
  NotifyCharRevive();
  virtual ~NotifyCharRevive();

  NotifyCharRevive(const NotifyCharRevive& from);

  inline NotifyCharRevive& operator=(const NotifyCharRevive& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCharRevive& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCharRevive* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCharRevive* other);

  // implements Message ----------------------------------------------

  NotifyCharRevive* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCharRevive& from);
  void MergeFrom(const NotifyCharRevive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .MapCharInfo charinfo = 1;
  inline bool has_charinfo() const;
  inline void clear_charinfo();
  static const int kCharinfoFieldNumber = 1;
  inline const ::MapCharInfo& charinfo() const;
  inline ::MapCharInfo* mutable_charinfo();
  inline ::MapCharInfo* release_charinfo();
  inline void set_allocated_charinfo(::MapCharInfo* charinfo);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCharRevive)
 private:
  inline void set_has_charinfo();
  inline void clear_has_charinfo();

  ::MapCharInfo* charinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCharRevive* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCharLevel : public ::google::protobuf::MessageLite {
 public:
  NotifyCharLevel();
  virtual ~NotifyCharLevel();

  NotifyCharLevel(const NotifyCharLevel& from);

  inline NotifyCharLevel& operator=(const NotifyCharLevel& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCharLevel& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCharLevel* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCharLevel* other);

  // implements Message ----------------------------------------------

  NotifyCharLevel* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCharLevel& from);
  void MergeFrom(const NotifyCharLevel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional int32 charlevel = 2;
  inline bool has_charlevel() const;
  inline void clear_charlevel();
  static const int kCharlevelFieldNumber = 2;
  inline ::google::protobuf::int32 charlevel() const;
  inline void set_charlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCharLevel)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_charlevel();
  inline void clear_has_charlevel();

  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 charlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCharLevel* default_instance_;
};
// -------------------------------------------------------------------

class JumpPoint : public ::google::protobuf::MessageLite {
 public:
  JumpPoint();
  virtual ~JumpPoint();

  JumpPoint(const JumpPoint& from);

  inline JumpPoint& operator=(const JumpPoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const JumpPoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JumpPoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JumpPoint* other);

  // implements Message ----------------------------------------------

  JumpPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JumpPoint& from);
  void MergeFrom(const JumpPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 map_x = 1;
  inline bool has_map_x() const;
  inline void clear_map_x();
  static const int kMapXFieldNumber = 1;
  inline ::google::protobuf::int32 map_x() const;
  inline void set_map_x(::google::protobuf::int32 value);

  // optional int32 map_y = 2;
  inline bool has_map_y() const;
  inline void clear_map_y();
  static const int kMapYFieldNumber = 2;
  inline ::google::protobuf::int32 map_y() const;
  inline void set_map_y(::google::protobuf::int32 value);

  // optional int32 target_mapid = 3;
  inline bool has_target_mapid() const;
  inline void clear_target_mapid();
  static const int kTargetMapidFieldNumber = 3;
  inline ::google::protobuf::int32 target_mapid() const;
  inline void set_target_mapid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.JumpPoint)
 private:
  inline void set_has_map_x();
  inline void clear_has_map_x();
  inline void set_has_map_y();
  inline void clear_has_map_y();
  inline void set_has_target_mapid();
  inline void clear_has_target_mapid();

  ::google::protobuf::int32 map_x_;
  ::google::protobuf::int32 map_y_;
  ::google::protobuf::int32 target_mapid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static JumpPoint* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCreateJumpPoint : public ::google::protobuf::MessageLite {
 public:
  NotifyCreateJumpPoint();
  virtual ~NotifyCreateJumpPoint();

  NotifyCreateJumpPoint(const NotifyCreateJumpPoint& from);

  inline NotifyCreateJumpPoint& operator=(const NotifyCreateJumpPoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCreateJumpPoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCreateJumpPoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCreateJumpPoint* other);

  // implements Message ----------------------------------------------

  NotifyCreateJumpPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCreateJumpPoint& from);
  void MergeFrom(const NotifyCreateJumpPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.JumpPoint point_list = 1;
  inline int point_list_size() const;
  inline void clear_point_list();
  static const int kPointListFieldNumber = 1;
  inline const ::Protocol::JumpPoint& point_list(int index) const;
  inline ::Protocol::JumpPoint* mutable_point_list(int index);
  inline ::Protocol::JumpPoint* add_point_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::JumpPoint >&
      point_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::JumpPoint >*
      mutable_point_list();

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCreateJumpPoint)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::JumpPoint > point_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCreateJumpPoint* default_instance_;
};
// -------------------------------------------------------------------

class NotifyCharChangeMap : public ::google::protobuf::MessageLite {
 public:
  NotifyCharChangeMap();
  virtual ~NotifyCharChangeMap();

  NotifyCharChangeMap(const NotifyCharChangeMap& from);

  inline NotifyCharChangeMap& operator=(const NotifyCharChangeMap& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyCharChangeMap& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyCharChangeMap* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyCharChangeMap* other);

  // implements Message ----------------------------------------------

  NotifyCharChangeMap* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyCharChangeMap& from);
  void MergeFrom(const NotifyCharChangeMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 map_id() const;
  inline void set_map_id(::google::protobuf::int32 value);

  // optional int32 map_x = 2;
  inline bool has_map_x() const;
  inline void clear_map_x();
  static const int kMapXFieldNumber = 2;
  inline ::google::protobuf::int32 map_x() const;
  inline void set_map_x(::google::protobuf::int32 value);

  // optional int32 map_y = 3;
  inline bool has_map_y() const;
  inline void clear_map_y();
  static const int kMapYFieldNumber = 3;
  inline ::google::protobuf::int32 map_y() const;
  inline void set_map_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyCharChangeMap)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_map_x();
  inline void clear_has_map_x();
  inline void set_has_map_y();
  inline void clear_has_map_y();

  ::google::protobuf::int32 map_id_;
  ::google::protobuf::int32 map_x_;
  ::google::protobuf::int32 map_y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyCharChangeMap* default_instance_;
};
// -------------------------------------------------------------------

class NotifySceneUpdateCharProperty : public ::google::protobuf::MessageLite {
 public:
  NotifySceneUpdateCharProperty();
  virtual ~NotifySceneUpdateCharProperty();

  NotifySceneUpdateCharProperty(const NotifySceneUpdateCharProperty& from);

  inline NotifySceneUpdateCharProperty& operator=(const NotifySceneUpdateCharProperty& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifySceneUpdateCharProperty& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifySceneUpdateCharProperty* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifySceneUpdateCharProperty* other);

  // implements Message ----------------------------------------------

  NotifySceneUpdateCharProperty* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifySceneUpdateCharProperty& from);
  void MergeFrom(const NotifySceneUpdateCharProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 curhp = 3;
  inline bool has_curhp() const;
  inline void clear_curhp();
  static const int kCurhpFieldNumber = 3;
  inline ::google::protobuf::int32 curhp() const;
  inline void set_curhp(::google::protobuf::int32 value);

  // optional int32 maxhp = 4;
  inline bool has_maxhp() const;
  inline void clear_maxhp();
  static const int kMaxhpFieldNumber = 4;
  inline ::google::protobuf::int32 maxhp() const;
  inline void set_maxhp(::google::protobuf::int32 value);

  // optional int32 move_speed = 5;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 5;
  inline ::google::protobuf::int32 move_speed() const;
  inline void set_move_speed(::google::protobuf::int32 value);

  // optional bool has_looks = 6;
  inline bool has_has_looks() const;
  inline void clear_has_looks();
  static const int kHasLooksFieldNumber = 6;
  inline bool has_looks() const;
  inline void set_has_looks(bool value);

  // repeated int32 looks = 7;
  inline int looks_size() const;
  inline void clear_looks();
  static const int kLooksFieldNumber = 7;
  inline ::google::protobuf::int32 looks(int index) const;
  inline void set_looks(int index, ::google::protobuf::int32 value);
  inline void add_looks(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      looks() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_looks();

  // @@protoc_insertion_point(class_scope:Protocol.NotifySceneUpdateCharProperty)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_curhp();
  inline void clear_has_curhp();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();
  inline void set_has_has_looks();
  inline void clear_has_has_looks();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 curhp_;
  ::google::protobuf::int32 maxhp_;
  ::google::protobuf::int32 move_speed_;
  bool has_looks_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > looks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifySceneUpdateCharProperty* default_instance_;
};
// -------------------------------------------------------------------

class NotifySceneUpdateMonsterProperty : public ::google::protobuf::MessageLite {
 public:
  NotifySceneUpdateMonsterProperty();
  virtual ~NotifySceneUpdateMonsterProperty();

  NotifySceneUpdateMonsterProperty(const NotifySceneUpdateMonsterProperty& from);

  inline NotifySceneUpdateMonsterProperty& operator=(const NotifySceneUpdateMonsterProperty& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifySceneUpdateMonsterProperty& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifySceneUpdateMonsterProperty* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifySceneUpdateMonsterProperty* other);

  // implements Message ----------------------------------------------

  NotifySceneUpdateMonsterProperty* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifySceneUpdateMonsterProperty& from);
  void MergeFrom(const NotifySceneUpdateMonsterProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 curhp = 2;
  inline bool has_curhp() const;
  inline void clear_curhp();
  static const int kCurhpFieldNumber = 2;
  inline ::google::protobuf::int32 curhp() const;
  inline void set_curhp(::google::protobuf::int32 value);

  // optional int32 maxhp = 3;
  inline bool has_maxhp() const;
  inline void clear_maxhp();
  static const int kMaxhpFieldNumber = 3;
  inline ::google::protobuf::int32 maxhp() const;
  inline void set_maxhp(::google::protobuf::int32 value);

  // optional int32 move_speed = 4;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 4;
  inline ::google::protobuf::int32 move_speed() const;
  inline void set_move_speed(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifySceneUpdateMonsterProperty)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_curhp();
  inline void clear_has_curhp();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 curhp_;
  ::google::protobuf::int32 maxhp_;
  ::google::protobuf::int32 move_speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifySceneUpdateMonsterProperty* default_instance_;
};
// -------------------------------------------------------------------

class BigMapNpcInfo : public ::google::protobuf::MessageLite {
 public:
  BigMapNpcInfo();
  virtual ~BigMapNpcInfo();

  BigMapNpcInfo(const BigMapNpcInfo& from);

  inline BigMapNpcInfo& operator=(const BigMapNpcInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BigMapNpcInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BigMapNpcInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BigMapNpcInfo* other);

  // implements Message ----------------------------------------------

  BigMapNpcInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BigMapNpcInfo& from);
  void MergeFrom(const BigMapNpcInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 x = 2;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 3;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 3;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 npcid = 4;
  inline bool has_npcid() const;
  inline void clear_npcid();
  static const int kNpcidFieldNumber = 4;
  inline ::google::protobuf::int32 npcid() const;
  inline void set_npcid(::google::protobuf::int32 value);

  // optional int32 func = 5;
  inline bool has_func() const;
  inline void clear_func();
  static const int kFuncFieldNumber = 5;
  inline ::google::protobuf::int32 func() const;
  inline void set_func(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.BigMapNpcInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_npcid();
  inline void clear_has_npcid();
  inline void set_has_func();
  inline void clear_has_func();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 npcid_;
  ::google::protobuf::int32 func_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static BigMapNpcInfo* default_instance_;
};
// -------------------------------------------------------------------

class BigMapMonsterInfo : public ::google::protobuf::MessageLite {
 public:
  BigMapMonsterInfo();
  virtual ~BigMapMonsterInfo();

  BigMapMonsterInfo(const BigMapMonsterInfo& from);

  inline BigMapMonsterInfo& operator=(const BigMapMonsterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BigMapMonsterInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BigMapMonsterInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BigMapMonsterInfo* other);

  // implements Message ----------------------------------------------

  BigMapMonsterInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BigMapMonsterInfo& from);
  void MergeFrom(const BigMapMonsterInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 monid = 3;
  inline bool has_monid() const;
  inline void clear_monid();
  static const int kMonidFieldNumber = 3;
  inline ::google::protobuf::int32 monid() const;
  inline void set_monid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.BigMapMonsterInfo)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_monid();
  inline void clear_has_monid();

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 monid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static BigMapMonsterInfo* default_instance_;
};
// -------------------------------------------------------------------

class BigMapJumpPointInfo : public ::google::protobuf::MessageLite {
 public:
  BigMapJumpPointInfo();
  virtual ~BigMapJumpPointInfo();

  BigMapJumpPointInfo(const BigMapJumpPointInfo& from);

  inline BigMapJumpPointInfo& operator=(const BigMapJumpPointInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BigMapJumpPointInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BigMapJumpPointInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BigMapJumpPointInfo* other);

  // implements Message ----------------------------------------------

  BigMapJumpPointInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BigMapJumpPointInfo& from);
  void MergeFrom(const BigMapJumpPointInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // optional int32 map_id = 3;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 3;
  inline ::google::protobuf::int32 map_id() const;
  inline void set_map_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.BigMapJumpPointInfo)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_map_id();
  inline void clear_has_map_id();

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 map_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static BigMapJumpPointInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetBigMapInfo : public ::google::protobuf::MessageLite {
 public:
  RequestGetBigMapInfo();
  virtual ~RequestGetBigMapInfo();

  RequestGetBigMapInfo(const RequestGetBigMapInfo& from);

  inline RequestGetBigMapInfo& operator=(const RequestGetBigMapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetBigMapInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetBigMapInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetBigMapInfo* other);

  // implements Message ----------------------------------------------

  RequestGetBigMapInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetBigMapInfo& from);
  void MergeFrom(const RequestGetBigMapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 map_id() const;
  inline void set_map_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetBigMapInfo)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();

  ::google::protobuf::int32 map_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static RequestGetBigMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetBigMapInfo : public ::google::protobuf::MessageLite {
 public:
  ResponseGetBigMapInfo();
  virtual ~ResponseGetBigMapInfo();

  ResponseGetBigMapInfo(const ResponseGetBigMapInfo& from);

  inline ResponseGetBigMapInfo& operator=(const ResponseGetBigMapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetBigMapInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetBigMapInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetBigMapInfo* other);

  // implements Message ----------------------------------------------

  ResponseGetBigMapInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetBigMapInfo& from);
  void MergeFrom(const ResponseGetBigMapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.BigMapNpcInfo npc_list = 1;
  inline int npc_list_size() const;
  inline void clear_npc_list();
  static const int kNpcListFieldNumber = 1;
  inline const ::Protocol::BigMapNpcInfo& npc_list(int index) const;
  inline ::Protocol::BigMapNpcInfo* mutable_npc_list(int index);
  inline ::Protocol::BigMapNpcInfo* add_npc_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapNpcInfo >&
      npc_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapNpcInfo >*
      mutable_npc_list();

  // repeated .Protocol.BigMapMonsterInfo monster_list = 2;
  inline int monster_list_size() const;
  inline void clear_monster_list();
  static const int kMonsterListFieldNumber = 2;
  inline const ::Protocol::BigMapMonsterInfo& monster_list(int index) const;
  inline ::Protocol::BigMapMonsterInfo* mutable_monster_list(int index);
  inline ::Protocol::BigMapMonsterInfo* add_monster_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapMonsterInfo >&
      monster_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapMonsterInfo >*
      mutable_monster_list();

  // repeated .Protocol.BigMapJumpPointInfo jumppoint_list = 3;
  inline int jumppoint_list_size() const;
  inline void clear_jumppoint_list();
  static const int kJumppointListFieldNumber = 3;
  inline const ::Protocol::BigMapJumpPointInfo& jumppoint_list(int index) const;
  inline ::Protocol::BigMapJumpPointInfo* mutable_jumppoint_list(int index);
  inline ::Protocol::BigMapJumpPointInfo* add_jumppoint_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapJumpPointInfo >&
      jumppoint_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapJumpPointInfo >*
      mutable_jumppoint_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetBigMapInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapNpcInfo > npc_list_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapMonsterInfo > monster_list_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapJumpPointInfo > jumppoint_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetBigMapInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetGoHomeMoney : public ::google::protobuf::MessageLite {
 public:
  RequestGetGoHomeMoney();
  virtual ~RequestGetGoHomeMoney();

  RequestGetGoHomeMoney(const RequestGetGoHomeMoney& from);

  inline RequestGetGoHomeMoney& operator=(const RequestGetGoHomeMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetGoHomeMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetGoHomeMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetGoHomeMoney* other);

  // implements Message ----------------------------------------------

  RequestGetGoHomeMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetGoHomeMoney& from);
  void MergeFrom(const RequestGetGoHomeMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetGoHomeMoney)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static RequestGetGoHomeMoney* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetGoHomeMoney : public ::google::protobuf::MessageLite {
 public:
  ResponseGetGoHomeMoney();
  virtual ~ResponseGetGoHomeMoney();

  ResponseGetGoHomeMoney(const ResponseGetGoHomeMoney& from);

  inline ResponseGetGoHomeMoney& operator=(const ResponseGetGoHomeMoney& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetGoHomeMoney& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetGoHomeMoney* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetGoHomeMoney* other);

  // implements Message ----------------------------------------------

  ResponseGetGoHomeMoney* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetGoHomeMoney& from);
  void MergeFrom(const ResponseGetGoHomeMoney& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 money = 1;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 1;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetGoHomeMoney)
 private:
  inline void set_has_money();
  inline void clear_has_money();

  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetGoHomeMoney* default_instance_;
};
// -------------------------------------------------------------------

class RequestGoHome : public ::google::protobuf::MessageLite {
 public:
  RequestGoHome();
  virtual ~RequestGoHome();

  RequestGoHome(const RequestGoHome& from);

  inline RequestGoHome& operator=(const RequestGoHome& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGoHome& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGoHome* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGoHome* other);

  // implements Message ----------------------------------------------

  RequestGoHome* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGoHome& from);
  void MergeFrom(const RequestGoHome& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGoHome)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static RequestGoHome* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDuplicateVote : public ::google::protobuf::MessageLite {
 public:
  NotifyDuplicateVote();
  virtual ~NotifyDuplicateVote();

  NotifyDuplicateVote(const NotifyDuplicateVote& from);

  inline NotifyDuplicateVote& operator=(const NotifyDuplicateVote& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyDuplicateVote& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDuplicateVote* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDuplicateVote* other);

  // implements Message ----------------------------------------------

  NotifyDuplicateVote* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDuplicateVote& from);
  void MergeFrom(const NotifyDuplicateVote& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 map_id = 1;
  inline bool has_map_id() const;
  inline void clear_map_id();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 map_id() const;
  inline void set_map_id(::google::protobuf::int32 value);

  // optional string charname = 2;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 2;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyDuplicateVote)
 private:
  inline void set_has_map_id();
  inline void clear_has_map_id();
  inline void set_has_charname();
  inline void clear_has_charname();

  ::std::string* charname_;
  ::google::protobuf::int32 map_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static NotifyDuplicateVote* default_instance_;
};
// -------------------------------------------------------------------

class RequestDuplicateVoteResult : public ::google::protobuf::MessageLite {
 public:
  RequestDuplicateVoteResult();
  virtual ~RequestDuplicateVoteResult();

  RequestDuplicateVoteResult(const RequestDuplicateVoteResult& from);

  inline RequestDuplicateVoteResult& operator=(const RequestDuplicateVoteResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestDuplicateVoteResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestDuplicateVoteResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestDuplicateVoteResult* other);

  // implements Message ----------------------------------------------

  RequestDuplicateVoteResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestDuplicateVoteResult& from);
  void MergeFrom(const RequestDuplicateVoteResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool agree = 1;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 1;
  inline bool agree() const;
  inline void set_agree(bool value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestDuplicateVoteResult)
 private:
  inline void set_has_agree();
  inline void clear_has_agree();

  bool agree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static RequestDuplicateVoteResult* default_instance_;
};
// -------------------------------------------------------------------

class RequestDuplicateExit : public ::google::protobuf::MessageLite {
 public:
  RequestDuplicateExit();
  virtual ~RequestDuplicateExit();

  RequestDuplicateExit(const RequestDuplicateExit& from);

  inline RequestDuplicateExit& operator=(const RequestDuplicateExit& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestDuplicateExit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestDuplicateExit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestDuplicateExit* other);

  // implements Message ----------------------------------------------

  RequestDuplicateExit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestDuplicateExit& from);
  void MergeFrom(const RequestDuplicateExit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestDuplicateExit)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static RequestDuplicateExit* default_instance_;
};
// -------------------------------------------------------------------

class RequestCrossMapPath : public ::google::protobuf::MessageLite {
 public:
  RequestCrossMapPath();
  virtual ~RequestCrossMapPath();

  RequestCrossMapPath(const RequestCrossMapPath& from);

  inline RequestCrossMapPath& operator=(const RequestCrossMapPath& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestCrossMapPath& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCrossMapPath* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCrossMapPath* other);

  // implements Message ----------------------------------------------

  RequestCrossMapPath* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCrossMapPath& from);
  void MergeFrom(const RequestCrossMapPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 object_type = 1;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 1;
  inline ::google::protobuf::int32 object_type() const;
  inline void set_object_type(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestCrossMapPath)
 private:
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 object_type_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static RequestCrossMapPath* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCrossMapPath_PathNode : public ::google::protobuf::MessageLite {
 public:
  ResponseCrossMapPath_PathNode();
  virtual ~ResponseCrossMapPath_PathNode();

  ResponseCrossMapPath_PathNode(const ResponseCrossMapPath_PathNode& from);

  inline ResponseCrossMapPath_PathNode& operator=(const ResponseCrossMapPath_PathNode& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseCrossMapPath_PathNode& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseCrossMapPath_PathNode* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseCrossMapPath_PathNode* other);

  // implements Message ----------------------------------------------

  ResponseCrossMapPath_PathNode* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseCrossMapPath_PathNode& from);
  void MergeFrom(const ResponseCrossMapPath_PathNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseCrossMapPath.PathNode)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static ResponseCrossMapPath_PathNode* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCrossMapPath : public ::google::protobuf::MessageLite {
 public:
  ResponseCrossMapPath();
  virtual ~ResponseCrossMapPath();

  ResponseCrossMapPath(const ResponseCrossMapPath& from);

  inline ResponseCrossMapPath& operator=(const ResponseCrossMapPath& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseCrossMapPath& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseCrossMapPath* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseCrossMapPath* other);

  // implements Message ----------------------------------------------

  ResponseCrossMapPath* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseCrossMapPath& from);
  void MergeFrom(const ResponseCrossMapPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ResponseCrossMapPath_PathNode PathNode;

  // accessors -------------------------------------------------------

  // optional int32 object_type = 1;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 1;
  inline ::google::protobuf::int32 object_type() const;
  inline void set_object_type(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .Protocol.ResponseCrossMapPath.PathNode path_node = 3;
  inline int path_node_size() const;
  inline void clear_path_node();
  static const int kPathNodeFieldNumber = 3;
  inline const ::Protocol::ResponseCrossMapPath_PathNode& path_node(int index) const;
  inline ::Protocol::ResponseCrossMapPath_PathNode* mutable_path_node(int index);
  inline ::Protocol::ResponseCrossMapPath_PathNode* add_path_node();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::ResponseCrossMapPath_PathNode >&
      path_node() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::ResponseCrossMapPath_PathNode >*
      mutable_path_node();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseCrossMapPath)
 private:
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 object_type_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::RepeatedPtrField< ::Protocol::ResponseCrossMapPath_PathNode > path_node_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoScene_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoScene_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoScene_2eproto();
  friend void protobuf_ShutdownFile_ProtoScene_2eproto();

  void InitAsDefaultInstance();
  static ResponseCrossMapPath* default_instance_;
};
// ===================================================================


// ===================================================================

// NotifyCreateChar

// repeated .MapCharInfo char_list = 1;
inline int NotifyCreateChar::char_list_size() const {
  return char_list_.size();
}
inline void NotifyCreateChar::clear_char_list() {
  char_list_.Clear();
}
inline const ::MapCharInfo& NotifyCreateChar::char_list(int index) const {
  return char_list_.Get(index);
}
inline ::MapCharInfo* NotifyCreateChar::mutable_char_list(int index) {
  return char_list_.Mutable(index);
}
inline ::MapCharInfo* NotifyCreateChar::add_char_list() {
  return char_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapCharInfo >&
NotifyCreateChar::char_list() const {
  return char_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapCharInfo >*
NotifyCreateChar::mutable_char_list() {
  return &char_list_;
}

// -------------------------------------------------------------------

// NotifyRemoveChar

// repeated int32 id_list = 1;
inline int NotifyRemoveChar::id_list_size() const {
  return id_list_.size();
}
inline void NotifyRemoveChar::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 NotifyRemoveChar::id_list(int index) const {
  return id_list_.Get(index);
}
inline void NotifyRemoveChar::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void NotifyRemoveChar::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NotifyRemoveChar::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NotifyRemoveChar::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// MsgCharMove

// optional int32 id = 1;
inline bool MsgCharMove::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgCharMove::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgCharMove::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgCharMove::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MsgCharMove::id() const {
  return id_;
}
inline void MsgCharMove::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool MsgCharMove::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgCharMove::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgCharMove::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgCharMove::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MsgCharMove::x() const {
  return x_;
}
inline void MsgCharMove::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool MsgCharMove::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgCharMove::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgCharMove::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgCharMove::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MsgCharMove::y() const {
  return y_;
}
inline void MsgCharMove::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 speed = 4;
inline bool MsgCharMove::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgCharMove::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgCharMove::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgCharMove::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 MsgCharMove::speed() const {
  return speed_;
}
inline void MsgCharMove::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 flag = 5;
inline bool MsgCharMove::has_flag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgCharMove::set_has_flag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgCharMove::clear_has_flag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgCharMove::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::google::protobuf::int32 MsgCharMove::flag() const {
  return flag_;
}
inline void MsgCharMove::set_flag(::google::protobuf::int32 value) {
  set_has_flag();
  flag_ = value;
}

// optional int32 direction = 6;
inline bool MsgCharMove::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgCharMove::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgCharMove::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgCharMove::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 MsgCharMove::direction() const {
  return direction_;
}
inline void MsgCharMove::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// -------------------------------------------------------------------

// MsgCharStopMove

// optional int32 id = 1;
inline bool MsgCharStopMove::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgCharStopMove::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgCharStopMove::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgCharStopMove::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MsgCharStopMove::id() const {
  return id_;
}
inline void MsgCharStopMove::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool MsgCharStopMove::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgCharStopMove::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgCharStopMove::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgCharStopMove::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 MsgCharStopMove::x() const {
  return x_;
}
inline void MsgCharStopMove::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool MsgCharStopMove::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgCharStopMove::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgCharStopMove::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgCharStopMove::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 MsgCharStopMove::y() const {
  return y_;
}
inline void MsgCharStopMove::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// NotifyCreateMonster

// repeated .MapMonsterInfo mon_list = 1;
inline int NotifyCreateMonster::mon_list_size() const {
  return mon_list_.size();
}
inline void NotifyCreateMonster::clear_mon_list() {
  mon_list_.Clear();
}
inline const ::MapMonsterInfo& NotifyCreateMonster::mon_list(int index) const {
  return mon_list_.Get(index);
}
inline ::MapMonsterInfo* NotifyCreateMonster::mutable_mon_list(int index) {
  return mon_list_.Mutable(index);
}
inline ::MapMonsterInfo* NotifyCreateMonster::add_mon_list() {
  return mon_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapMonsterInfo >&
NotifyCreateMonster::mon_list() const {
  return mon_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapMonsterInfo >*
NotifyCreateMonster::mutable_mon_list() {
  return &mon_list_;
}

// -------------------------------------------------------------------

// NotifyRemoveMonster

// repeated int32 id_list = 1;
inline int NotifyRemoveMonster::id_list_size() const {
  return id_list_.size();
}
inline void NotifyRemoveMonster::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 NotifyRemoveMonster::id_list(int index) const {
  return id_list_.Get(index);
}
inline void NotifyRemoveMonster::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void NotifyRemoveMonster::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NotifyRemoveMonster::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NotifyRemoveMonster::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// NotifyMonsterMove

// optional int32 id = 1;
inline bool NotifyMonsterMove::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyMonsterMove::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyMonsterMove::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyMonsterMove::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyMonsterMove::id() const {
  return id_;
}
inline void NotifyMonsterMove::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool NotifyMonsterMove::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyMonsterMove::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyMonsterMove::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyMonsterMove::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 NotifyMonsterMove::x() const {
  return x_;
}
inline void NotifyMonsterMove::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool NotifyMonsterMove::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyMonsterMove::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyMonsterMove::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyMonsterMove::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 NotifyMonsterMove::y() const {
  return y_;
}
inline void NotifyMonsterMove::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// NotifyMonsterStopMove

// optional int32 id = 1;
inline bool NotifyMonsterStopMove::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyMonsterStopMove::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyMonsterStopMove::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyMonsterStopMove::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyMonsterStopMove::id() const {
  return id_;
}
inline void NotifyMonsterStopMove::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool NotifyMonsterStopMove::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyMonsterStopMove::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyMonsterStopMove::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyMonsterStopMove::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 NotifyMonsterStopMove::x() const {
  return x_;
}
inline void NotifyMonsterStopMove::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool NotifyMonsterStopMove::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyMonsterStopMove::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyMonsterStopMove::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyMonsterStopMove::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 NotifyMonsterStopMove::y() const {
  return y_;
}
inline void NotifyMonsterStopMove::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// NotifyCreateNpc

// repeated .MapNpcInfo npc_list = 1;
inline int NotifyCreateNpc::npc_list_size() const {
  return npc_list_.size();
}
inline void NotifyCreateNpc::clear_npc_list() {
  npc_list_.Clear();
}
inline const ::MapNpcInfo& NotifyCreateNpc::npc_list(int index) const {
  return npc_list_.Get(index);
}
inline ::MapNpcInfo* NotifyCreateNpc::mutable_npc_list(int index) {
  return npc_list_.Mutable(index);
}
inline ::MapNpcInfo* NotifyCreateNpc::add_npc_list() {
  return npc_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapNpcInfo >&
NotifyCreateNpc::npc_list() const {
  return npc_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapNpcInfo >*
NotifyCreateNpc::mutable_npc_list() {
  return &npc_list_;
}

// -------------------------------------------------------------------

// NotifyRemoveNpc

// repeated int32 id_list = 1;
inline int NotifyRemoveNpc::id_list_size() const {
  return id_list_.size();
}
inline void NotifyRemoveNpc::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 NotifyRemoveNpc::id_list(int index) const {
  return id_list_.Get(index);
}
inline void NotifyRemoveNpc::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void NotifyRemoveNpc::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NotifyRemoveNpc::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NotifyRemoveNpc::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// NotifyNpcMove

// optional int32 id = 1;
inline bool NotifyNpcMove::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyNpcMove::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyNpcMove::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyNpcMove::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyNpcMove::id() const {
  return id_;
}
inline void NotifyNpcMove::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool NotifyNpcMove::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyNpcMove::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyNpcMove::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyNpcMove::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 NotifyNpcMove::x() const {
  return x_;
}
inline void NotifyNpcMove::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool NotifyNpcMove::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyNpcMove::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyNpcMove::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyNpcMove::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 NotifyNpcMove::y() const {
  return y_;
}
inline void NotifyNpcMove::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// NotifyNpcStopMove

// optional int32 id = 1;
inline bool NotifyNpcStopMove::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyNpcStopMove::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyNpcStopMove::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyNpcStopMove::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyNpcStopMove::id() const {
  return id_;
}
inline void NotifyNpcStopMove::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool NotifyNpcStopMove::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyNpcStopMove::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyNpcStopMove::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyNpcStopMove::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 NotifyNpcStopMove::x() const {
  return x_;
}
inline void NotifyNpcStopMove::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool NotifyNpcStopMove::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyNpcStopMove::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyNpcStopMove::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyNpcStopMove::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 NotifyNpcStopMove::y() const {
  return y_;
}
inline void NotifyNpcStopMove::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// NotifyMonsterDead

// optional int32 id = 1;
inline bool NotifyMonsterDead::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyMonsterDead::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyMonsterDead::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyMonsterDead::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyMonsterDead::id() const {
  return id_;
}
inline void NotifyMonsterDead::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 exp = 2;
inline bool NotifyMonsterDead::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyMonsterDead::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyMonsterDead::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyMonsterDead::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 NotifyMonsterDead::exp() const {
  return exp_;
}
inline void NotifyMonsterDead::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 attacker_id = 3;
inline bool NotifyMonsterDead::has_attacker_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyMonsterDead::set_has_attacker_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyMonsterDead::clear_has_attacker_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyMonsterDead::clear_attacker_id() {
  attacker_id_ = 0;
  clear_has_attacker_id();
}
inline ::google::protobuf::int32 NotifyMonsterDead::attacker_id() const {
  return attacker_id_;
}
inline void NotifyMonsterDead::set_attacker_id(::google::protobuf::int32 value) {
  set_has_attacker_id();
  attacker_id_ = value;
}

// -------------------------------------------------------------------

// NotifyMonsterDisappear

// optional int32 id = 1;
inline bool NotifyMonsterDisappear::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyMonsterDisappear::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyMonsterDisappear::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyMonsterDisappear::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyMonsterDisappear::id() const {
  return id_;
}
inline void NotifyMonsterDisappear::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// NotifyMonsterRevive

// optional .MapMonsterInfo moninfo = 1;
inline bool NotifyMonsterRevive::has_moninfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyMonsterRevive::set_has_moninfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyMonsterRevive::clear_has_moninfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyMonsterRevive::clear_moninfo() {
  if (moninfo_ != NULL) moninfo_->::MapMonsterInfo::Clear();
  clear_has_moninfo();
}
inline const ::MapMonsterInfo& NotifyMonsterRevive::moninfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return moninfo_ != NULL ? *moninfo_ : *default_instance().moninfo_;
#else
  return moninfo_ != NULL ? *moninfo_ : *default_instance_->moninfo_;
#endif
}
inline ::MapMonsterInfo* NotifyMonsterRevive::mutable_moninfo() {
  set_has_moninfo();
  if (moninfo_ == NULL) moninfo_ = new ::MapMonsterInfo;
  return moninfo_;
}
inline ::MapMonsterInfo* NotifyMonsterRevive::release_moninfo() {
  clear_has_moninfo();
  ::MapMonsterInfo* temp = moninfo_;
  moninfo_ = NULL;
  return temp;
}
inline void NotifyMonsterRevive::set_allocated_moninfo(::MapMonsterInfo* moninfo) {
  delete moninfo_;
  moninfo_ = moninfo;
  if (moninfo) {
    set_has_moninfo();
  } else {
    clear_has_moninfo();
  }
}

// -------------------------------------------------------------------

// NotifyCharDead

// optional int32 id = 1;
inline bool NotifyCharDead::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyCharDead::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyCharDead::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyCharDead::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyCharDead::id() const {
  return id_;
}
inline void NotifyCharDead::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 exp = 2;
inline bool NotifyCharDead::has_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyCharDead::set_has_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyCharDead::clear_has_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyCharDead::clear_exp() {
  exp_ = 0;
  clear_has_exp();
}
inline ::google::protobuf::int32 NotifyCharDead::exp() const {
  return exp_;
}
inline void NotifyCharDead::set_exp(::google::protobuf::int32 value) {
  set_has_exp();
  exp_ = value;
}

// optional int32 attacker_id = 3;
inline bool NotifyCharDead::has_attacker_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyCharDead::set_has_attacker_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyCharDead::clear_has_attacker_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyCharDead::clear_attacker_id() {
  attacker_id_ = 0;
  clear_has_attacker_id();
}
inline ::google::protobuf::int32 NotifyCharDead::attacker_id() const {
  return attacker_id_;
}
inline void NotifyCharDead::set_attacker_id(::google::protobuf::int32 value) {
  set_has_attacker_id();
  attacker_id_ = value;
}

// -------------------------------------------------------------------

// NotifyCharDisappear

// optional int32 id = 1;
inline bool NotifyCharDisappear::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyCharDisappear::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyCharDisappear::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyCharDisappear::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifyCharDisappear::id() const {
  return id_;
}
inline void NotifyCharDisappear::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// RequestCharRevive

// optional .Protocol.ReviveType revive_type = 1;
inline bool RequestCharRevive::has_revive_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCharRevive::set_has_revive_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCharRevive::clear_has_revive_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCharRevive::clear_revive_type() {
  revive_type_ = 0;
  clear_has_revive_type();
}
inline ::Protocol::ReviveType RequestCharRevive::revive_type() const {
  return static_cast< ::Protocol::ReviveType >(revive_type_);
}
inline void RequestCharRevive::set_revive_type(::Protocol::ReviveType value) {
  assert(::Protocol::ReviveType_IsValid(value));
  set_has_revive_type();
  revive_type_ = value;
}

// -------------------------------------------------------------------

// NotifyCharRevive

// optional .MapCharInfo charinfo = 1;
inline bool NotifyCharRevive::has_charinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyCharRevive::set_has_charinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyCharRevive::clear_has_charinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyCharRevive::clear_charinfo() {
  if (charinfo_ != NULL) charinfo_->::MapCharInfo::Clear();
  clear_has_charinfo();
}
inline const ::MapCharInfo& NotifyCharRevive::charinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return charinfo_ != NULL ? *charinfo_ : *default_instance().charinfo_;
#else
  return charinfo_ != NULL ? *charinfo_ : *default_instance_->charinfo_;
#endif
}
inline ::MapCharInfo* NotifyCharRevive::mutable_charinfo() {
  set_has_charinfo();
  if (charinfo_ == NULL) charinfo_ = new ::MapCharInfo;
  return charinfo_;
}
inline ::MapCharInfo* NotifyCharRevive::release_charinfo() {
  clear_has_charinfo();
  ::MapCharInfo* temp = charinfo_;
  charinfo_ = NULL;
  return temp;
}
inline void NotifyCharRevive::set_allocated_charinfo(::MapCharInfo* charinfo) {
  delete charinfo_;
  charinfo_ = charinfo;
  if (charinfo) {
    set_has_charinfo();
  } else {
    clear_has_charinfo();
  }
}

// -------------------------------------------------------------------

// NotifyCharLevel

// optional int32 charid = 1;
inline bool NotifyCharLevel::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyCharLevel::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyCharLevel::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyCharLevel::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 NotifyCharLevel::charid() const {
  return charid_;
}
inline void NotifyCharLevel::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional int32 charlevel = 2;
inline bool NotifyCharLevel::has_charlevel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyCharLevel::set_has_charlevel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyCharLevel::clear_has_charlevel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyCharLevel::clear_charlevel() {
  charlevel_ = 0;
  clear_has_charlevel();
}
inline ::google::protobuf::int32 NotifyCharLevel::charlevel() const {
  return charlevel_;
}
inline void NotifyCharLevel::set_charlevel(::google::protobuf::int32 value) {
  set_has_charlevel();
  charlevel_ = value;
}

// -------------------------------------------------------------------

// JumpPoint

// optional int32 map_x = 1;
inline bool JumpPoint::has_map_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JumpPoint::set_has_map_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JumpPoint::clear_has_map_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JumpPoint::clear_map_x() {
  map_x_ = 0;
  clear_has_map_x();
}
inline ::google::protobuf::int32 JumpPoint::map_x() const {
  return map_x_;
}
inline void JumpPoint::set_map_x(::google::protobuf::int32 value) {
  set_has_map_x();
  map_x_ = value;
}

// optional int32 map_y = 2;
inline bool JumpPoint::has_map_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JumpPoint::set_has_map_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JumpPoint::clear_has_map_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JumpPoint::clear_map_y() {
  map_y_ = 0;
  clear_has_map_y();
}
inline ::google::protobuf::int32 JumpPoint::map_y() const {
  return map_y_;
}
inline void JumpPoint::set_map_y(::google::protobuf::int32 value) {
  set_has_map_y();
  map_y_ = value;
}

// optional int32 target_mapid = 3;
inline bool JumpPoint::has_target_mapid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JumpPoint::set_has_target_mapid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JumpPoint::clear_has_target_mapid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JumpPoint::clear_target_mapid() {
  target_mapid_ = 0;
  clear_has_target_mapid();
}
inline ::google::protobuf::int32 JumpPoint::target_mapid() const {
  return target_mapid_;
}
inline void JumpPoint::set_target_mapid(::google::protobuf::int32 value) {
  set_has_target_mapid();
  target_mapid_ = value;
}

// -------------------------------------------------------------------

// NotifyCreateJumpPoint

// repeated .Protocol.JumpPoint point_list = 1;
inline int NotifyCreateJumpPoint::point_list_size() const {
  return point_list_.size();
}
inline void NotifyCreateJumpPoint::clear_point_list() {
  point_list_.Clear();
}
inline const ::Protocol::JumpPoint& NotifyCreateJumpPoint::point_list(int index) const {
  return point_list_.Get(index);
}
inline ::Protocol::JumpPoint* NotifyCreateJumpPoint::mutable_point_list(int index) {
  return point_list_.Mutable(index);
}
inline ::Protocol::JumpPoint* NotifyCreateJumpPoint::add_point_list() {
  return point_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::JumpPoint >&
NotifyCreateJumpPoint::point_list() const {
  return point_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::JumpPoint >*
NotifyCreateJumpPoint::mutable_point_list() {
  return &point_list_;
}

// -------------------------------------------------------------------

// NotifyCharChangeMap

// optional int32 map_id = 1;
inline bool NotifyCharChangeMap::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyCharChangeMap::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyCharChangeMap::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyCharChangeMap::clear_map_id() {
  map_id_ = 0;
  clear_has_map_id();
}
inline ::google::protobuf::int32 NotifyCharChangeMap::map_id() const {
  return map_id_;
}
inline void NotifyCharChangeMap::set_map_id(::google::protobuf::int32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional int32 map_x = 2;
inline bool NotifyCharChangeMap::has_map_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyCharChangeMap::set_has_map_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyCharChangeMap::clear_has_map_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyCharChangeMap::clear_map_x() {
  map_x_ = 0;
  clear_has_map_x();
}
inline ::google::protobuf::int32 NotifyCharChangeMap::map_x() const {
  return map_x_;
}
inline void NotifyCharChangeMap::set_map_x(::google::protobuf::int32 value) {
  set_has_map_x();
  map_x_ = value;
}

// optional int32 map_y = 3;
inline bool NotifyCharChangeMap::has_map_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyCharChangeMap::set_has_map_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyCharChangeMap::clear_has_map_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyCharChangeMap::clear_map_y() {
  map_y_ = 0;
  clear_has_map_y();
}
inline ::google::protobuf::int32 NotifyCharChangeMap::map_y() const {
  return map_y_;
}
inline void NotifyCharChangeMap::set_map_y(::google::protobuf::int32 value) {
  set_has_map_y();
  map_y_ = value;
}

// -------------------------------------------------------------------

// NotifySceneUpdateCharProperty

// optional int32 id = 1;
inline bool NotifySceneUpdateCharProperty::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifySceneUpdateCharProperty::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifySceneUpdateCharProperty::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifySceneUpdateCharProperty::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifySceneUpdateCharProperty::id() const {
  return id_;
}
inline void NotifySceneUpdateCharProperty::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 level = 2;
inline bool NotifySceneUpdateCharProperty::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifySceneUpdateCharProperty::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifySceneUpdateCharProperty::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifySceneUpdateCharProperty::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 NotifySceneUpdateCharProperty::level() const {
  return level_;
}
inline void NotifySceneUpdateCharProperty::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 curhp = 3;
inline bool NotifySceneUpdateCharProperty::has_curhp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifySceneUpdateCharProperty::set_has_curhp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifySceneUpdateCharProperty::clear_has_curhp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifySceneUpdateCharProperty::clear_curhp() {
  curhp_ = 0;
  clear_has_curhp();
}
inline ::google::protobuf::int32 NotifySceneUpdateCharProperty::curhp() const {
  return curhp_;
}
inline void NotifySceneUpdateCharProperty::set_curhp(::google::protobuf::int32 value) {
  set_has_curhp();
  curhp_ = value;
}

// optional int32 maxhp = 4;
inline bool NotifySceneUpdateCharProperty::has_maxhp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifySceneUpdateCharProperty::set_has_maxhp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifySceneUpdateCharProperty::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifySceneUpdateCharProperty::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 NotifySceneUpdateCharProperty::maxhp() const {
  return maxhp_;
}
inline void NotifySceneUpdateCharProperty::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
}

// optional int32 move_speed = 5;
inline bool NotifySceneUpdateCharProperty::has_move_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NotifySceneUpdateCharProperty::set_has_move_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NotifySceneUpdateCharProperty::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NotifySceneUpdateCharProperty::clear_move_speed() {
  move_speed_ = 0;
  clear_has_move_speed();
}
inline ::google::protobuf::int32 NotifySceneUpdateCharProperty::move_speed() const {
  return move_speed_;
}
inline void NotifySceneUpdateCharProperty::set_move_speed(::google::protobuf::int32 value) {
  set_has_move_speed();
  move_speed_ = value;
}

// optional bool has_looks = 6;
inline bool NotifySceneUpdateCharProperty::has_has_looks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NotifySceneUpdateCharProperty::set_has_has_looks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NotifySceneUpdateCharProperty::clear_has_has_looks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NotifySceneUpdateCharProperty::clear_has_looks() {
  has_looks_ = false;
  clear_has_has_looks();
}
inline bool NotifySceneUpdateCharProperty::has_looks() const {
  return has_looks_;
}
inline void NotifySceneUpdateCharProperty::set_has_looks(bool value) {
  set_has_has_looks();
  has_looks_ = value;
}

// repeated int32 looks = 7;
inline int NotifySceneUpdateCharProperty::looks_size() const {
  return looks_.size();
}
inline void NotifySceneUpdateCharProperty::clear_looks() {
  looks_.Clear();
}
inline ::google::protobuf::int32 NotifySceneUpdateCharProperty::looks(int index) const {
  return looks_.Get(index);
}
inline void NotifySceneUpdateCharProperty::set_looks(int index, ::google::protobuf::int32 value) {
  looks_.Set(index, value);
}
inline void NotifySceneUpdateCharProperty::add_looks(::google::protobuf::int32 value) {
  looks_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
NotifySceneUpdateCharProperty::looks() const {
  return looks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
NotifySceneUpdateCharProperty::mutable_looks() {
  return &looks_;
}

// -------------------------------------------------------------------

// NotifySceneUpdateMonsterProperty

// optional int32 id = 1;
inline bool NotifySceneUpdateMonsterProperty::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifySceneUpdateMonsterProperty::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifySceneUpdateMonsterProperty::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifySceneUpdateMonsterProperty::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 NotifySceneUpdateMonsterProperty::id() const {
  return id_;
}
inline void NotifySceneUpdateMonsterProperty::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 curhp = 2;
inline bool NotifySceneUpdateMonsterProperty::has_curhp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifySceneUpdateMonsterProperty::set_has_curhp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifySceneUpdateMonsterProperty::clear_has_curhp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifySceneUpdateMonsterProperty::clear_curhp() {
  curhp_ = 0;
  clear_has_curhp();
}
inline ::google::protobuf::int32 NotifySceneUpdateMonsterProperty::curhp() const {
  return curhp_;
}
inline void NotifySceneUpdateMonsterProperty::set_curhp(::google::protobuf::int32 value) {
  set_has_curhp();
  curhp_ = value;
}

// optional int32 maxhp = 3;
inline bool NotifySceneUpdateMonsterProperty::has_maxhp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifySceneUpdateMonsterProperty::set_has_maxhp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifySceneUpdateMonsterProperty::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifySceneUpdateMonsterProperty::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 NotifySceneUpdateMonsterProperty::maxhp() const {
  return maxhp_;
}
inline void NotifySceneUpdateMonsterProperty::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
}

// optional int32 move_speed = 4;
inline bool NotifySceneUpdateMonsterProperty::has_move_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifySceneUpdateMonsterProperty::set_has_move_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifySceneUpdateMonsterProperty::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifySceneUpdateMonsterProperty::clear_move_speed() {
  move_speed_ = 0;
  clear_has_move_speed();
}
inline ::google::protobuf::int32 NotifySceneUpdateMonsterProperty::move_speed() const {
  return move_speed_;
}
inline void NotifySceneUpdateMonsterProperty::set_move_speed(::google::protobuf::int32 value) {
  set_has_move_speed();
  move_speed_ = value;
}

// -------------------------------------------------------------------

// BigMapNpcInfo

// optional int32 id = 1;
inline bool BigMapNpcInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigMapNpcInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigMapNpcInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigMapNpcInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BigMapNpcInfo::id() const {
  return id_;
}
inline void BigMapNpcInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 x = 2;
inline bool BigMapNpcInfo::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigMapNpcInfo::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigMapNpcInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigMapNpcInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 BigMapNpcInfo::x() const {
  return x_;
}
inline void BigMapNpcInfo::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 3;
inline bool BigMapNpcInfo::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigMapNpcInfo::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigMapNpcInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigMapNpcInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 BigMapNpcInfo::y() const {
  return y_;
}
inline void BigMapNpcInfo::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 npcid = 4;
inline bool BigMapNpcInfo::has_npcid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BigMapNpcInfo::set_has_npcid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BigMapNpcInfo::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BigMapNpcInfo::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 BigMapNpcInfo::npcid() const {
  return npcid_;
}
inline void BigMapNpcInfo::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
}

// optional int32 func = 5;
inline bool BigMapNpcInfo::has_func() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BigMapNpcInfo::set_has_func() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BigMapNpcInfo::clear_has_func() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BigMapNpcInfo::clear_func() {
  func_ = 0;
  clear_has_func();
}
inline ::google::protobuf::int32 BigMapNpcInfo::func() const {
  return func_;
}
inline void BigMapNpcInfo::set_func(::google::protobuf::int32 value) {
  set_has_func();
  func_ = value;
}

// -------------------------------------------------------------------

// BigMapMonsterInfo

// optional int32 x = 1;
inline bool BigMapMonsterInfo::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigMapMonsterInfo::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigMapMonsterInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigMapMonsterInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 BigMapMonsterInfo::x() const {
  return x_;
}
inline void BigMapMonsterInfo::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 2;
inline bool BigMapMonsterInfo::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigMapMonsterInfo::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigMapMonsterInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigMapMonsterInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 BigMapMonsterInfo::y() const {
  return y_;
}
inline void BigMapMonsterInfo::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 monid = 3;
inline bool BigMapMonsterInfo::has_monid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigMapMonsterInfo::set_has_monid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigMapMonsterInfo::clear_has_monid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigMapMonsterInfo::clear_monid() {
  monid_ = 0;
  clear_has_monid();
}
inline ::google::protobuf::int32 BigMapMonsterInfo::monid() const {
  return monid_;
}
inline void BigMapMonsterInfo::set_monid(::google::protobuf::int32 value) {
  set_has_monid();
  monid_ = value;
}

// -------------------------------------------------------------------

// BigMapJumpPointInfo

// optional int32 x = 1;
inline bool BigMapJumpPointInfo::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigMapJumpPointInfo::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BigMapJumpPointInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BigMapJumpPointInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 BigMapJumpPointInfo::x() const {
  return x_;
}
inline void BigMapJumpPointInfo::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 2;
inline bool BigMapJumpPointInfo::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BigMapJumpPointInfo::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BigMapJumpPointInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BigMapJumpPointInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 BigMapJumpPointInfo::y() const {
  return y_;
}
inline void BigMapJumpPointInfo::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// optional int32 map_id = 3;
inline bool BigMapJumpPointInfo::has_map_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BigMapJumpPointInfo::set_has_map_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BigMapJumpPointInfo::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BigMapJumpPointInfo::clear_map_id() {
  map_id_ = 0;
  clear_has_map_id();
}
inline ::google::protobuf::int32 BigMapJumpPointInfo::map_id() const {
  return map_id_;
}
inline void BigMapJumpPointInfo::set_map_id(::google::protobuf::int32 value) {
  set_has_map_id();
  map_id_ = value;
}

// -------------------------------------------------------------------

// RequestGetBigMapInfo

// optional int32 map_id = 1;
inline bool RequestGetBigMapInfo::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetBigMapInfo::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetBigMapInfo::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetBigMapInfo::clear_map_id() {
  map_id_ = 0;
  clear_has_map_id();
}
inline ::google::protobuf::int32 RequestGetBigMapInfo::map_id() const {
  return map_id_;
}
inline void RequestGetBigMapInfo::set_map_id(::google::protobuf::int32 value) {
  set_has_map_id();
  map_id_ = value;
}

// -------------------------------------------------------------------

// ResponseGetBigMapInfo

// repeated .Protocol.BigMapNpcInfo npc_list = 1;
inline int ResponseGetBigMapInfo::npc_list_size() const {
  return npc_list_.size();
}
inline void ResponseGetBigMapInfo::clear_npc_list() {
  npc_list_.Clear();
}
inline const ::Protocol::BigMapNpcInfo& ResponseGetBigMapInfo::npc_list(int index) const {
  return npc_list_.Get(index);
}
inline ::Protocol::BigMapNpcInfo* ResponseGetBigMapInfo::mutable_npc_list(int index) {
  return npc_list_.Mutable(index);
}
inline ::Protocol::BigMapNpcInfo* ResponseGetBigMapInfo::add_npc_list() {
  return npc_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapNpcInfo >&
ResponseGetBigMapInfo::npc_list() const {
  return npc_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapNpcInfo >*
ResponseGetBigMapInfo::mutable_npc_list() {
  return &npc_list_;
}

// repeated .Protocol.BigMapMonsterInfo monster_list = 2;
inline int ResponseGetBigMapInfo::monster_list_size() const {
  return monster_list_.size();
}
inline void ResponseGetBigMapInfo::clear_monster_list() {
  monster_list_.Clear();
}
inline const ::Protocol::BigMapMonsterInfo& ResponseGetBigMapInfo::monster_list(int index) const {
  return monster_list_.Get(index);
}
inline ::Protocol::BigMapMonsterInfo* ResponseGetBigMapInfo::mutable_monster_list(int index) {
  return monster_list_.Mutable(index);
}
inline ::Protocol::BigMapMonsterInfo* ResponseGetBigMapInfo::add_monster_list() {
  return monster_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapMonsterInfo >&
ResponseGetBigMapInfo::monster_list() const {
  return monster_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapMonsterInfo >*
ResponseGetBigMapInfo::mutable_monster_list() {
  return &monster_list_;
}

// repeated .Protocol.BigMapJumpPointInfo jumppoint_list = 3;
inline int ResponseGetBigMapInfo::jumppoint_list_size() const {
  return jumppoint_list_.size();
}
inline void ResponseGetBigMapInfo::clear_jumppoint_list() {
  jumppoint_list_.Clear();
}
inline const ::Protocol::BigMapJumpPointInfo& ResponseGetBigMapInfo::jumppoint_list(int index) const {
  return jumppoint_list_.Get(index);
}
inline ::Protocol::BigMapJumpPointInfo* ResponseGetBigMapInfo::mutable_jumppoint_list(int index) {
  return jumppoint_list_.Mutable(index);
}
inline ::Protocol::BigMapJumpPointInfo* ResponseGetBigMapInfo::add_jumppoint_list() {
  return jumppoint_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapJumpPointInfo >&
ResponseGetBigMapInfo::jumppoint_list() const {
  return jumppoint_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::BigMapJumpPointInfo >*
ResponseGetBigMapInfo::mutable_jumppoint_list() {
  return &jumppoint_list_;
}

// -------------------------------------------------------------------

// RequestGetGoHomeMoney

// optional int32 reserve = 1;
inline bool RequestGetGoHomeMoney::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetGoHomeMoney::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetGoHomeMoney::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetGoHomeMoney::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestGetGoHomeMoney::reserve() const {
  return reserve_;
}
inline void RequestGetGoHomeMoney::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// ResponseGetGoHomeMoney

// optional int32 money = 1;
inline bool ResponseGetGoHomeMoney::has_money() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetGoHomeMoney::set_has_money() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetGoHomeMoney::clear_has_money() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetGoHomeMoney::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 ResponseGetGoHomeMoney::money() const {
  return money_;
}
inline void ResponseGetGoHomeMoney::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// -------------------------------------------------------------------

// RequestGoHome

// optional int32 reserve = 1;
inline bool RequestGoHome::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGoHome::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGoHome::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGoHome::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestGoHome::reserve() const {
  return reserve_;
}
inline void RequestGoHome::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// NotifyDuplicateVote

// optional int32 map_id = 1;
inline bool NotifyDuplicateVote::has_map_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyDuplicateVote::set_has_map_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyDuplicateVote::clear_has_map_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyDuplicateVote::clear_map_id() {
  map_id_ = 0;
  clear_has_map_id();
}
inline ::google::protobuf::int32 NotifyDuplicateVote::map_id() const {
  return map_id_;
}
inline void NotifyDuplicateVote::set_map_id(::google::protobuf::int32 value) {
  set_has_map_id();
  map_id_ = value;
}

// optional string charname = 2;
inline bool NotifyDuplicateVote::has_charname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyDuplicateVote::set_has_charname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyDuplicateVote::clear_has_charname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyDuplicateVote::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& NotifyDuplicateVote::charname() const {
  return *charname_;
}
inline void NotifyDuplicateVote::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void NotifyDuplicateVote::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void NotifyDuplicateVote::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyDuplicateVote::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* NotifyDuplicateVote::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyDuplicateVote::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RequestDuplicateVoteResult

// optional bool agree = 1;
inline bool RequestDuplicateVoteResult::has_agree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestDuplicateVoteResult::set_has_agree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestDuplicateVoteResult::clear_has_agree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestDuplicateVoteResult::clear_agree() {
  agree_ = false;
  clear_has_agree();
}
inline bool RequestDuplicateVoteResult::agree() const {
  return agree_;
}
inline void RequestDuplicateVoteResult::set_agree(bool value) {
  set_has_agree();
  agree_ = value;
}

// -------------------------------------------------------------------

// RequestDuplicateExit

// optional int32 reserve = 1;
inline bool RequestDuplicateExit::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestDuplicateExit::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestDuplicateExit::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestDuplicateExit::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestDuplicateExit::reserve() const {
  return reserve_;
}
inline void RequestDuplicateExit::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// RequestCrossMapPath

// optional int32 object_type = 1;
inline bool RequestCrossMapPath::has_object_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCrossMapPath::set_has_object_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCrossMapPath::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCrossMapPath::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::google::protobuf::int32 RequestCrossMapPath::object_type() const {
  return object_type_;
}
inline void RequestCrossMapPath::set_object_type(::google::protobuf::int32 value) {
  set_has_object_type();
  object_type_ = value;
}

// optional int32 id = 2;
inline bool RequestCrossMapPath::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCrossMapPath::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCrossMapPath::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCrossMapPath::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestCrossMapPath::id() const {
  return id_;
}
inline void RequestCrossMapPath::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ResponseCrossMapPath_PathNode

// optional int32 x = 1;
inline bool ResponseCrossMapPath_PathNode::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCrossMapPath_PathNode::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCrossMapPath_PathNode::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCrossMapPath_PathNode::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 ResponseCrossMapPath_PathNode::x() const {
  return x_;
}
inline void ResponseCrossMapPath_PathNode::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// optional int32 y = 2;
inline bool ResponseCrossMapPath_PathNode::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCrossMapPath_PathNode::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCrossMapPath_PathNode::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCrossMapPath_PathNode::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 ResponseCrossMapPath_PathNode::y() const {
  return y_;
}
inline void ResponseCrossMapPath_PathNode::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// ResponseCrossMapPath

// optional int32 object_type = 1;
inline bool ResponseCrossMapPath::has_object_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCrossMapPath::set_has_object_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCrossMapPath::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCrossMapPath::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::google::protobuf::int32 ResponseCrossMapPath::object_type() const {
  return object_type_;
}
inline void ResponseCrossMapPath::set_object_type(::google::protobuf::int32 value) {
  set_has_object_type();
  object_type_ = value;
}

// optional int32 id = 2;
inline bool ResponseCrossMapPath::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCrossMapPath::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCrossMapPath::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCrossMapPath::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ResponseCrossMapPath::id() const {
  return id_;
}
inline void ResponseCrossMapPath::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .Protocol.ResponseCrossMapPath.PathNode path_node = 3;
inline int ResponseCrossMapPath::path_node_size() const {
  return path_node_.size();
}
inline void ResponseCrossMapPath::clear_path_node() {
  path_node_.Clear();
}
inline const ::Protocol::ResponseCrossMapPath_PathNode& ResponseCrossMapPath::path_node(int index) const {
  return path_node_.Get(index);
}
inline ::Protocol::ResponseCrossMapPath_PathNode* ResponseCrossMapPath::mutable_path_node(int index) {
  return path_node_.Mutable(index);
}
inline ::Protocol::ResponseCrossMapPath_PathNode* ResponseCrossMapPath::add_path_node() {
  return path_node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::ResponseCrossMapPath_PathNode >&
ResponseCrossMapPath::path_node() const {
  return path_node_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::ResponseCrossMapPath_PathNode >*
ResponseCrossMapPath::mutable_path_node() {
  return &path_node_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoScene_2eproto__INCLUDED
