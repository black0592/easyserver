// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoMail.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoMail.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace Protocol {

void protobuf_ShutdownFile_ProtoMail_2eproto() {
  delete MailItem::default_instance_;
  delete MailInfo::default_instance_;
  delete RequestGetMail::default_instance_;
  delete ResponseGetMail::default_instance_;
  delete RequestReadMail::default_instance_;
  delete ResponseReadMail::default_instance_;
  delete RequestTakeOutAttachment::default_instance_;
  delete ResponseTakeOutAttachment::default_instance_;
  delete RequestWriteMail::default_instance_;
  delete ResponseWriteMail::default_instance_;
  delete RequestDeleteMail::default_instance_;
  delete ResponseDeleteMail::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoMail_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoMail_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoGameData_2eproto();
  MailItem::default_instance_ = new MailItem();
  MailInfo::default_instance_ = new MailInfo();
  RequestGetMail::default_instance_ = new RequestGetMail();
  ResponseGetMail::default_instance_ = new ResponseGetMail();
  RequestReadMail::default_instance_ = new RequestReadMail();
  ResponseReadMail::default_instance_ = new ResponseReadMail();
  RequestTakeOutAttachment::default_instance_ = new RequestTakeOutAttachment();
  ResponseTakeOutAttachment::default_instance_ = new ResponseTakeOutAttachment();
  RequestWriteMail::default_instance_ = new RequestWriteMail();
  ResponseWriteMail::default_instance_ = new ResponseWriteMail();
  RequestDeleteMail::default_instance_ = new RequestDeleteMail();
  ResponseDeleteMail::default_instance_ = new ResponseDeleteMail();
  MailItem::default_instance_->InitAsDefaultInstance();
  MailInfo::default_instance_->InitAsDefaultInstance();
  RequestGetMail::default_instance_->InitAsDefaultInstance();
  ResponseGetMail::default_instance_->InitAsDefaultInstance();
  RequestReadMail::default_instance_->InitAsDefaultInstance();
  ResponseReadMail::default_instance_->InitAsDefaultInstance();
  RequestTakeOutAttachment::default_instance_->InitAsDefaultInstance();
  ResponseTakeOutAttachment::default_instance_->InitAsDefaultInstance();
  RequestWriteMail::default_instance_->InitAsDefaultInstance();
  ResponseWriteMail::default_instance_->InitAsDefaultInstance();
  RequestDeleteMail::default_instance_->InitAsDefaultInstance();
  ResponseDeleteMail::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoMail_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoMail_2eproto_once_);
void protobuf_AddDesc_ProtoMail_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoMail_2eproto_once_,
                 &protobuf_AddDesc_ProtoMail_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoMail_2eproto {
  StaticDescriptorInitializer_ProtoMail_2eproto() {
    protobuf_AddDesc_ProtoMail_2eproto();
  }
} static_descriptor_initializer_ProtoMail_2eproto_;
#endif
bool MailOpCode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

bool MailFlag_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MailItem::kItemListFieldNumber;
#endif  // !_MSC_VER

MailItem::MailItem()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MailItem::InitAsDefaultInstance() {
}

MailItem::MailItem(const MailItem& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MailItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MailItem::~MailItem() {
  SharedDtor();
}

void MailItem::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MailItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MailItem& MailItem::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

MailItem* MailItem::default_instance_ = NULL;

MailItem* MailItem::New() const {
  return new MailItem;
}

void MailItem::Clear() {
  item_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MailItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ItemData item_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_item_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_item_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_item_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MailItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ItemData item_list = 1;
  for (int i = 0; i < this->item_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->item_list(i), output);
  }

}

int MailItem::ByteSize() const {
  int total_size = 0;

  // repeated .ItemData item_list = 1;
  total_size += 1 * this->item_list_size();
  for (int i = 0; i < this->item_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->item_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MailItem::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MailItem*>(&from));
}

void MailItem::MergeFrom(const MailItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  item_list_.MergeFrom(from.item_list_);
}

void MailItem::CopyFrom(const MailItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MailItem::IsInitialized() const {

  return true;
}

void MailItem::Swap(MailItem* other) {
  if (other != this) {
    item_list_.Swap(&other->item_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MailItem::GetTypeName() const {
  return "Protocol.MailItem";
}


// ===================================================================

#ifndef _MSC_VER
const int MailInfo::kIdFieldNumber;
const int MailInfo::kFlagFieldNumber;
const int MailInfo::kSystemFieldNumber;
const int MailInfo::kSenderFieldNumber;
const int MailInfo::kReceiverFieldNumber;
const int MailInfo::kTitleFieldNumber;
const int MailInfo::kContentFieldNumber;
const int MailInfo::kMoneyFieldNumber;
const int MailInfo::kGoldFieldNumber;
const int MailInfo::kBindgoldFieldNumber;
const int MailInfo::kExpFieldNumber;
const int MailInfo::kSendtimeFieldNumber;
const int MailInfo::kExpiredtimeFieldNumber;
const int MailInfo::kHaveAttachmentFieldNumber;
const int MailInfo::kMailItemFieldNumber;
#endif  // !_MSC_VER

MailInfo::MailInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MailInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  mail_item_ = const_cast< ::Protocol::MailItem*>(
      ::Protocol::MailItem::internal_default_instance());
#else
  mail_item_ = const_cast< ::Protocol::MailItem*>(&::Protocol::MailItem::default_instance());
#endif
}

MailInfo::MailInfo(const MailInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MailInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  flag_ = 0;
  system_ = 0;
  sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  money_ = GOOGLE_ULONGLONG(0);
  gold_ = GOOGLE_ULONGLONG(0);
  bindgold_ = GOOGLE_ULONGLONG(0);
  exp_ = GOOGLE_ULONGLONG(0);
  sendtime_ = 0u;
  expiredtime_ = 0u;
  have_attachment_ = false;
  mail_item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MailInfo::~MailInfo() {
  SharedDtor();
}

void MailInfo::SharedDtor() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete mail_item_;
  }
}

void MailInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MailInfo& MailInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

MailInfo* MailInfo::default_instance_ = NULL;

MailInfo* MailInfo::New() const {
  return new MailInfo;
}

void MailInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    flag_ = 0;
    system_ = 0;
    if (has_sender()) {
      if (sender_ != &::google::protobuf::internal::kEmptyString) {
        sender_->clear();
      }
    }
    if (has_receiver()) {
      if (receiver_ != &::google::protobuf::internal::kEmptyString) {
        receiver_->clear();
      }
    }
    if (has_title()) {
      if (title_ != &::google::protobuf::internal::kEmptyString) {
        title_->clear();
      }
    }
    if (has_content()) {
      if (content_ != &::google::protobuf::internal::kEmptyString) {
        content_->clear();
      }
    }
    money_ = GOOGLE_ULONGLONG(0);
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    gold_ = GOOGLE_ULONGLONG(0);
    bindgold_ = GOOGLE_ULONGLONG(0);
    exp_ = GOOGLE_ULONGLONG(0);
    sendtime_ = 0u;
    expiredtime_ = 0u;
    have_attachment_ = false;
    if (has_mail_item()) {
      if (mail_item_ != NULL) mail_item_->::Protocol::MailItem::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MailInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_flag;
        break;
      }

      // optional .Protocol.MailFlag flag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_flag:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Protocol::MailFlag_IsValid(value)) {
            set_flag(static_cast< ::Protocol::MailFlag >(value));
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_system;
        break;
      }

      // optional int32 system = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_system:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &system_)));
          set_has_system();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_sender;
        break;
      }

      // optional string sender = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sender:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sender()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_receiver;
        break;
      }

      // optional string receiver = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_receiver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_receiver()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_title;
        break;
      }

      // optional string title = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_title:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_title()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_content;
        break;
      }

      // optional string content = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_content:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_content()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_money;
        break;
      }

      // optional uint64 money = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_gold;
        break;
      }

      // optional uint64 gold = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gold_)));
          set_has_gold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_bindgold;
        break;
      }

      // optional uint64 bindgold = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bindgold:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bindgold_)));
          set_has_bindgold();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_exp;
        break;
      }

      // optional uint64 exp = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_exp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &exp_)));
          set_has_exp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(96)) goto parse_sendtime;
        break;
      }

      // optional uint32 sendtime = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sendtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sendtime_)));
          set_has_sendtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_expiredtime;
        break;
      }

      // optional uint32 expiredtime = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_expiredtime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &expiredtime_)));
          set_has_expiredtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_have_attachment;
        break;
      }

      // optional bool have_attachment = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_have_attachment:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &have_attachment_)));
          set_has_have_attachment();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_mail_item;
        break;
      }

      // optional .Protocol.MailItem mail_item = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mail_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mail_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MailInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional .Protocol.MailFlag flag = 2;
  if (has_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->flag(), output);
  }

  // optional int32 system = 3;
  if (has_system()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->system(), output);
  }

  // optional string sender = 4;
  if (has_sender()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->sender(), output);
  }

  // optional string receiver = 5;
  if (has_receiver()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->receiver(), output);
  }

  // optional string title = 6;
  if (has_title()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->title(), output);
  }

  // optional string content = 7;
  if (has_content()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->content(), output);
  }

  // optional uint64 money = 8;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->money(), output);
  }

  // optional uint64 gold = 9;
  if (has_gold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->gold(), output);
  }

  // optional uint64 bindgold = 10;
  if (has_bindgold()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->bindgold(), output);
  }

  // optional uint64 exp = 11;
  if (has_exp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->exp(), output);
  }

  // optional uint32 sendtime = 12;
  if (has_sendtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->sendtime(), output);
  }

  // optional uint32 expiredtime = 13;
  if (has_expiredtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->expiredtime(), output);
  }

  // optional bool have_attachment = 14;
  if (has_have_attachment()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->have_attachment(), output);
  }

  // optional .Protocol.MailItem mail_item = 15;
  if (has_mail_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      15, this->mail_item(), output);
  }

}

int MailInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional .Protocol.MailFlag flag = 2;
    if (has_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->flag());
    }

    // optional int32 system = 3;
    if (has_system()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->system());
    }

    // optional string sender = 4;
    if (has_sender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sender());
    }

    // optional string receiver = 5;
    if (has_receiver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->receiver());
    }

    // optional string title = 6;
    if (has_title()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->title());
    }

    // optional string content = 7;
    if (has_content()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->content());
    }

    // optional uint64 money = 8;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->money());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint64 gold = 9;
    if (has_gold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->gold());
    }

    // optional uint64 bindgold = 10;
    if (has_bindgold()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bindgold());
    }

    // optional uint64 exp = 11;
    if (has_exp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->exp());
    }

    // optional uint32 sendtime = 12;
    if (has_sendtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sendtime());
    }

    // optional uint32 expiredtime = 13;
    if (has_expiredtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->expiredtime());
    }

    // optional bool have_attachment = 14;
    if (has_have_attachment()) {
      total_size += 1 + 1;
    }

    // optional .Protocol.MailItem mail_item = 15;
    if (has_mail_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mail_item());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MailInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MailInfo*>(&from));
}

void MailInfo::MergeFrom(const MailInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_flag()) {
      set_flag(from.flag());
    }
    if (from.has_system()) {
      set_system(from.system());
    }
    if (from.has_sender()) {
      set_sender(from.sender());
    }
    if (from.has_receiver()) {
      set_receiver(from.receiver());
    }
    if (from.has_title()) {
      set_title(from.title());
    }
    if (from.has_content()) {
      set_content(from.content());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_gold()) {
      set_gold(from.gold());
    }
    if (from.has_bindgold()) {
      set_bindgold(from.bindgold());
    }
    if (from.has_exp()) {
      set_exp(from.exp());
    }
    if (from.has_sendtime()) {
      set_sendtime(from.sendtime());
    }
    if (from.has_expiredtime()) {
      set_expiredtime(from.expiredtime());
    }
    if (from.has_have_attachment()) {
      set_have_attachment(from.have_attachment());
    }
    if (from.has_mail_item()) {
      mutable_mail_item()->::Protocol::MailItem::MergeFrom(from.mail_item());
    }
  }
}

void MailInfo::CopyFrom(const MailInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MailInfo::IsInitialized() const {

  return true;
}

void MailInfo::Swap(MailInfo* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(flag_, other->flag_);
    std::swap(system_, other->system_);
    std::swap(sender_, other->sender_);
    std::swap(receiver_, other->receiver_);
    std::swap(title_, other->title_);
    std::swap(content_, other->content_);
    std::swap(money_, other->money_);
    std::swap(gold_, other->gold_);
    std::swap(bindgold_, other->bindgold_);
    std::swap(exp_, other->exp_);
    std::swap(sendtime_, other->sendtime_);
    std::swap(expiredtime_, other->expiredtime_);
    std::swap(have_attachment_, other->have_attachment_);
    std::swap(mail_item_, other->mail_item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MailInfo::GetTypeName() const {
  return "Protocol.MailInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetMail::kReserveFieldNumber;
#endif  // !_MSC_VER

RequestGetMail::RequestGetMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetMail::InitAsDefaultInstance() {
}

RequestGetMail::RequestGetMail(const RequestGetMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetMail::SharedCtor() {
  _cached_size_ = 0;
  reserve_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetMail::~RequestGetMail() {
  SharedDtor();
}

void RequestGetMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetMail& RequestGetMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

RequestGetMail* RequestGetMail::default_instance_ = NULL;

RequestGetMail* RequestGetMail::New() const {
  return new RequestGetMail;
}

void RequestGetMail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    reserve_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 reserve = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &reserve_)));
          set_has_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 reserve = 1;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->reserve(), output);
  }

}

int RequestGetMail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 reserve = 1;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->reserve());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetMail*>(&from));
}

void RequestGetMail::MergeFrom(const RequestGetMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_reserve()) {
      set_reserve(from.reserve());
    }
  }
}

void RequestGetMail::CopyFrom(const RequestGetMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetMail::IsInitialized() const {

  return true;
}

void RequestGetMail::Swap(RequestGetMail* other) {
  if (other != this) {
    std::swap(reserve_, other->reserve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetMail::GetTypeName() const {
  return "Protocol.RequestGetMail";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetMail::kMailListFieldNumber;
#endif  // !_MSC_VER

ResponseGetMail::ResponseGetMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetMail::InitAsDefaultInstance() {
}

ResponseGetMail::ResponseGetMail(const ResponseGetMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetMail::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetMail::~ResponseGetMail() {
  SharedDtor();
}

void ResponseGetMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetMail& ResponseGetMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

ResponseGetMail* ResponseGetMail::default_instance_ = NULL;

ResponseGetMail* ResponseGetMail::New() const {
  return new ResponseGetMail;
}

void ResponseGetMail::Clear() {
  mail_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Protocol.MailInfo mail_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mail_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mail_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_mail_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Protocol.MailInfo mail_list = 1;
  for (int i = 0; i < this->mail_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mail_list(i), output);
  }

}

int ResponseGetMail::ByteSize() const {
  int total_size = 0;

  // repeated .Protocol.MailInfo mail_list = 1;
  total_size += 1 * this->mail_list_size();
  for (int i = 0; i < this->mail_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mail_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetMail*>(&from));
}

void ResponseGetMail::MergeFrom(const ResponseGetMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  mail_list_.MergeFrom(from.mail_list_);
}

void ResponseGetMail::CopyFrom(const ResponseGetMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetMail::IsInitialized() const {

  return true;
}

void ResponseGetMail::Swap(ResponseGetMail* other) {
  if (other != this) {
    mail_list_.Swap(&other->mail_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetMail::GetTypeName() const {
  return "Protocol.ResponseGetMail";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestReadMail::kIdFieldNumber;
#endif  // !_MSC_VER

RequestReadMail::RequestReadMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestReadMail::InitAsDefaultInstance() {
}

RequestReadMail::RequestReadMail(const RequestReadMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestReadMail::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestReadMail::~RequestReadMail() {
  SharedDtor();
}

void RequestReadMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestReadMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestReadMail& RequestReadMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

RequestReadMail* RequestReadMail::default_instance_ = NULL;

RequestReadMail* RequestReadMail::New() const {
  return new RequestReadMail;
}

void RequestReadMail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestReadMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestReadMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

}

int RequestReadMail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestReadMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestReadMail*>(&from));
}

void RequestReadMail::MergeFrom(const RequestReadMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
}

void RequestReadMail::CopyFrom(const RequestReadMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestReadMail::IsInitialized() const {

  return true;
}

void RequestReadMail::Swap(RequestReadMail* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestReadMail::GetTypeName() const {
  return "Protocol.RequestReadMail";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseReadMail::kMailFieldNumber;
#endif  // !_MSC_VER

ResponseReadMail::ResponseReadMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseReadMail::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  mail_ = const_cast< ::Protocol::MailInfo*>(
      ::Protocol::MailInfo::internal_default_instance());
#else
  mail_ = const_cast< ::Protocol::MailInfo*>(&::Protocol::MailInfo::default_instance());
#endif
}

ResponseReadMail::ResponseReadMail(const ResponseReadMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseReadMail::SharedCtor() {
  _cached_size_ = 0;
  mail_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseReadMail::~ResponseReadMail() {
  SharedDtor();
}

void ResponseReadMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete mail_;
  }
}

void ResponseReadMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseReadMail& ResponseReadMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

ResponseReadMail* ResponseReadMail::default_instance_ = NULL;

ResponseReadMail* ResponseReadMail::New() const {
  return new ResponseReadMail;
}

void ResponseReadMail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mail()) {
      if (mail_ != NULL) mail_->::Protocol::MailInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseReadMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.MailInfo mail = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mail()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseReadMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.MailInfo mail = 1;
  if (has_mail()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mail(), output);
  }

}

int ResponseReadMail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.MailInfo mail = 1;
    if (has_mail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mail());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseReadMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseReadMail*>(&from));
}

void ResponseReadMail::MergeFrom(const ResponseReadMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mail()) {
      mutable_mail()->::Protocol::MailInfo::MergeFrom(from.mail());
    }
  }
}

void ResponseReadMail::CopyFrom(const ResponseReadMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseReadMail::IsInitialized() const {

  return true;
}

void ResponseReadMail::Swap(ResponseReadMail* other) {
  if (other != this) {
    std::swap(mail_, other->mail_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseReadMail::GetTypeName() const {
  return "Protocol.ResponseReadMail";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestTakeOutAttachment::kIdListFieldNumber;
#endif  // !_MSC_VER

RequestTakeOutAttachment::RequestTakeOutAttachment()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestTakeOutAttachment::InitAsDefaultInstance() {
}

RequestTakeOutAttachment::RequestTakeOutAttachment(const RequestTakeOutAttachment& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestTakeOutAttachment::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestTakeOutAttachment::~RequestTakeOutAttachment() {
  SharedDtor();
}

void RequestTakeOutAttachment::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestTakeOutAttachment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestTakeOutAttachment& RequestTakeOutAttachment::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

RequestTakeOutAttachment* RequestTakeOutAttachment::default_instance_ = NULL;

RequestTakeOutAttachment* RequestTakeOutAttachment::New() const {
  return new RequestTakeOutAttachment;
}

void RequestTakeOutAttachment::Clear() {
  id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestTakeOutAttachment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestTakeOutAttachment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id_list = 1;
  for (int i = 0; i < this->id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id_list(i), output);
  }

}

int RequestTakeOutAttachment::ByteSize() const {
  int total_size = 0;

  // repeated int32 id_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id_list(i));
    }
    total_size += 1 * this->id_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestTakeOutAttachment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestTakeOutAttachment*>(&from));
}

void RequestTakeOutAttachment::MergeFrom(const RequestTakeOutAttachment& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_list_.MergeFrom(from.id_list_);
}

void RequestTakeOutAttachment::CopyFrom(const RequestTakeOutAttachment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestTakeOutAttachment::IsInitialized() const {

  return true;
}

void RequestTakeOutAttachment::Swap(RequestTakeOutAttachment* other) {
  if (other != this) {
    id_list_.Swap(&other->id_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestTakeOutAttachment::GetTypeName() const {
  return "Protocol.RequestTakeOutAttachment";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseTakeOutAttachment::kIdListFieldNumber;
#endif  // !_MSC_VER

ResponseTakeOutAttachment::ResponseTakeOutAttachment()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseTakeOutAttachment::InitAsDefaultInstance() {
}

ResponseTakeOutAttachment::ResponseTakeOutAttachment(const ResponseTakeOutAttachment& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseTakeOutAttachment::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseTakeOutAttachment::~ResponseTakeOutAttachment() {
  SharedDtor();
}

void ResponseTakeOutAttachment::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseTakeOutAttachment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseTakeOutAttachment& ResponseTakeOutAttachment::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

ResponseTakeOutAttachment* ResponseTakeOutAttachment::default_instance_ = NULL;

ResponseTakeOutAttachment* ResponseTakeOutAttachment::New() const {
  return new ResponseTakeOutAttachment;
}

void ResponseTakeOutAttachment::Clear() {
  id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseTakeOutAttachment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseTakeOutAttachment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id_list = 1;
  for (int i = 0; i < this->id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id_list(i), output);
  }

}

int ResponseTakeOutAttachment::ByteSize() const {
  int total_size = 0;

  // repeated int32 id_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id_list(i));
    }
    total_size += 1 * this->id_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseTakeOutAttachment::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseTakeOutAttachment*>(&from));
}

void ResponseTakeOutAttachment::MergeFrom(const ResponseTakeOutAttachment& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_list_.MergeFrom(from.id_list_);
}

void ResponseTakeOutAttachment::CopyFrom(const ResponseTakeOutAttachment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseTakeOutAttachment::IsInitialized() const {

  return true;
}

void ResponseTakeOutAttachment::Swap(ResponseTakeOutAttachment* other) {
  if (other != this) {
    id_list_.Swap(&other->id_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseTakeOutAttachment::GetTypeName() const {
  return "Protocol.ResponseTakeOutAttachment";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestWriteMail::kMailFieldNumber;
const int RequestWriteMail::kLocListFieldNumber;
#endif  // !_MSC_VER

RequestWriteMail::RequestWriteMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestWriteMail::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  mail_ = const_cast< ::Protocol::MailInfo*>(
      ::Protocol::MailInfo::internal_default_instance());
#else
  mail_ = const_cast< ::Protocol::MailInfo*>(&::Protocol::MailInfo::default_instance());
#endif
}

RequestWriteMail::RequestWriteMail(const RequestWriteMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestWriteMail::SharedCtor() {
  _cached_size_ = 0;
  mail_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestWriteMail::~RequestWriteMail() {
  SharedDtor();
}

void RequestWriteMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete mail_;
  }
}

void RequestWriteMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestWriteMail& RequestWriteMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

RequestWriteMail* RequestWriteMail::default_instance_ = NULL;

RequestWriteMail* RequestWriteMail::New() const {
  return new RequestWriteMail;
}

void RequestWriteMail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mail()) {
      if (mail_ != NULL) mail_->::Protocol::MailInfo::Clear();
    }
  }
  loc_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestWriteMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Protocol.MailInfo mail = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mail()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_loc_list;
        break;
      }

      // repeated .ItemLocNum loc_list = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_loc_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_loc_list()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_loc_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestWriteMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Protocol.MailInfo mail = 1;
  if (has_mail()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->mail(), output);
  }

  // repeated .ItemLocNum loc_list = 2;
  for (int i = 0; i < this->loc_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->loc_list(i), output);
  }

}

int RequestWriteMail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Protocol.MailInfo mail = 1;
    if (has_mail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mail());
    }

  }
  // repeated .ItemLocNum loc_list = 2;
  total_size += 1 * this->loc_list_size();
  for (int i = 0; i < this->loc_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->loc_list(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestWriteMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestWriteMail*>(&from));
}

void RequestWriteMail::MergeFrom(const RequestWriteMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  loc_list_.MergeFrom(from.loc_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mail()) {
      mutable_mail()->::Protocol::MailInfo::MergeFrom(from.mail());
    }
  }
}

void RequestWriteMail::CopyFrom(const RequestWriteMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestWriteMail::IsInitialized() const {

  return true;
}

void RequestWriteMail::Swap(RequestWriteMail* other) {
  if (other != this) {
    std::swap(mail_, other->mail_);
    loc_list_.Swap(&other->loc_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestWriteMail::GetTypeName() const {
  return "Protocol.RequestWriteMail";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseWriteMail::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseWriteMail::ResponseWriteMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseWriteMail::InitAsDefaultInstance() {
}

ResponseWriteMail::ResponseWriteMail(const ResponseWriteMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseWriteMail::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseWriteMail::~ResponseWriteMail() {
  SharedDtor();
}

void ResponseWriteMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseWriteMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseWriteMail& ResponseWriteMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

ResponseWriteMail* ResponseWriteMail::default_instance_ = NULL;

ResponseWriteMail* ResponseWriteMail::New() const {
  return new ResponseWriteMail;
}

void ResponseWriteMail::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseWriteMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseWriteMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseWriteMail::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseWriteMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseWriteMail*>(&from));
}

void ResponseWriteMail::MergeFrom(const ResponseWriteMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseWriteMail::CopyFrom(const ResponseWriteMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseWriteMail::IsInitialized() const {

  return true;
}

void ResponseWriteMail::Swap(ResponseWriteMail* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseWriteMail::GetTypeName() const {
  return "Protocol.ResponseWriteMail";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestDeleteMail::kIdListFieldNumber;
#endif  // !_MSC_VER

RequestDeleteMail::RequestDeleteMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestDeleteMail::InitAsDefaultInstance() {
}

RequestDeleteMail::RequestDeleteMail(const RequestDeleteMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestDeleteMail::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestDeleteMail::~RequestDeleteMail() {
  SharedDtor();
}

void RequestDeleteMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestDeleteMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestDeleteMail& RequestDeleteMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

RequestDeleteMail* RequestDeleteMail::default_instance_ = NULL;

RequestDeleteMail* RequestDeleteMail::New() const {
  return new RequestDeleteMail;
}

void RequestDeleteMail::Clear() {
  id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestDeleteMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestDeleteMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id_list = 1;
  for (int i = 0; i < this->id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id_list(i), output);
  }

}

int RequestDeleteMail::ByteSize() const {
  int total_size = 0;

  // repeated int32 id_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id_list(i));
    }
    total_size += 1 * this->id_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestDeleteMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestDeleteMail*>(&from));
}

void RequestDeleteMail::MergeFrom(const RequestDeleteMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_list_.MergeFrom(from.id_list_);
}

void RequestDeleteMail::CopyFrom(const RequestDeleteMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestDeleteMail::IsInitialized() const {

  return true;
}

void RequestDeleteMail::Swap(RequestDeleteMail* other) {
  if (other != this) {
    id_list_.Swap(&other->id_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestDeleteMail::GetTypeName() const {
  return "Protocol.RequestDeleteMail";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseDeleteMail::kIdListFieldNumber;
#endif  // !_MSC_VER

ResponseDeleteMail::ResponseDeleteMail()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseDeleteMail::InitAsDefaultInstance() {
}

ResponseDeleteMail::ResponseDeleteMail(const ResponseDeleteMail& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseDeleteMail::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseDeleteMail::~ResponseDeleteMail() {
  SharedDtor();
}

void ResponseDeleteMail::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseDeleteMail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseDeleteMail& ResponseDeleteMail::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoMail_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoMail_2eproto();
#endif
  return *default_instance_;
}

ResponseDeleteMail* ResponseDeleteMail::default_instance_ = NULL;

ResponseDeleteMail* ResponseDeleteMail::New() const {
  return new ResponseDeleteMail;
}

void ResponseDeleteMail::Clear() {
  id_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseDeleteMail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 id_list = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_id_list())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_id_list())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_id_list;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseDeleteMail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 id_list = 1;
  for (int i = 0; i < this->id_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->id_list(i), output);
  }

}

int ResponseDeleteMail::ByteSize() const {
  int total_size = 0;

  // repeated int32 id_list = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->id_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->id_list(i));
    }
    total_size += 1 * this->id_list_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseDeleteMail::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseDeleteMail*>(&from));
}

void ResponseDeleteMail::MergeFrom(const ResponseDeleteMail& from) {
  GOOGLE_CHECK_NE(&from, this);
  id_list_.MergeFrom(from.id_list_);
}

void ResponseDeleteMail::CopyFrom(const ResponseDeleteMail& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseDeleteMail::IsInitialized() const {

  return true;
}

void ResponseDeleteMail::Swap(ResponseDeleteMail* other) {
  if (other != this) {
    id_list_.Swap(&other->id_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseDeleteMail::GetTypeName() const {
  return "Protocol.ResponseDeleteMail";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)
