// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoCharData.proto

#ifndef PROTOBUF_ProtoCharData_2eproto__INCLUDED
#define PROTOBUF_ProtoCharData_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoCharData_2eproto();
void protobuf_AssignDesc_ProtoCharData_2eproto();
void protobuf_ShutdownFile_ProtoCharData_2eproto();

class RequestCheckPing;
class ResponseCheckPing;
class RequestStartGame;
class ResponseStartGame;
class NotifyUpdateProperty;
class RequestUseLvupPoint;
class ResponseUseLvupPoint;
class RequestRecharge;
class RequestSetShortcutKey;
class RequestLookCharEquip;
class ResponseLookCharEquip;
class RequestTakeVipAward;
class ResponseTakeVipAward;
class RequestSaveSetting;

enum CharDataOpCode {
  OP_CHECK_PING = 1,
  OP_START_GAME = 2,
  OP_UPDATE_PROPERTY = 3,
  OP_USE_LVUP_POINT = 4,
  OP_RECHARGE = 5,
  OP_SET_SHORTCUT_KEY = 6,
  OP_LOOK_CHAR_EQUIP = 7,
  OP_TAKE_VIP_AWARD = 8,
  OP_SAVE_SETTING = 9
};
bool CharDataOpCode_IsValid(int value);
const CharDataOpCode CharDataOpCode_MIN = OP_CHECK_PING;
const CharDataOpCode CharDataOpCode_MAX = OP_SAVE_SETTING;
const int CharDataOpCode_ARRAYSIZE = CharDataOpCode_MAX + 1;

// ===================================================================

class RequestCheckPing : public ::google::protobuf::MessageLite {
 public:
  RequestCheckPing();
  virtual ~RequestCheckPing();

  RequestCheckPing(const RequestCheckPing& from);

  inline RequestCheckPing& operator=(const RequestCheckPing& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestCheckPing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestCheckPing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestCheckPing* other);

  // implements Message ----------------------------------------------

  RequestCheckPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestCheckPing& from);
  void MergeFrom(const RequestCheckPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestCheckPing)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestCheckPing* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCheckPing : public ::google::protobuf::MessageLite {
 public:
  ResponseCheckPing();
  virtual ~ResponseCheckPing();

  ResponseCheckPing(const ResponseCheckPing& from);

  inline ResponseCheckPing& operator=(const ResponseCheckPing& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseCheckPing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseCheckPing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseCheckPing* other);

  // implements Message ----------------------------------------------

  ResponseCheckPing* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseCheckPing& from);
  void MergeFrom(const ResponseCheckPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseCheckPing)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static ResponseCheckPing* default_instance_;
};
// -------------------------------------------------------------------

class RequestStartGame : public ::google::protobuf::MessageLite {
 public:
  RequestStartGame();
  virtual ~RequestStartGame();

  RequestStartGame(const RequestStartGame& from);

  inline RequestStartGame& operator=(const RequestStartGame& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestStartGame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestStartGame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestStartGame* other);

  // implements Message ----------------------------------------------

  RequestStartGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestStartGame& from);
  void MergeFrom(const RequestStartGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestStartGame)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestStartGame* default_instance_;
};
// -------------------------------------------------------------------

class ResponseStartGame : public ::google::protobuf::MessageLite {
 public:
  ResponseStartGame();
  virtual ~ResponseStartGame();

  ResponseStartGame(const ResponseStartGame& from);

  inline ResponseStartGame& operator=(const ResponseStartGame& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseStartGame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseStartGame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseStartGame* other);

  // implements Message ----------------------------------------------

  ResponseStartGame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseStartGame& from);
  void MergeFrom(const ResponseStartGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // optional int32 param1 = 2;
  inline bool has_param1() const;
  inline void clear_param1();
  static const int kParam1FieldNumber = 2;
  inline ::google::protobuf::int32 param1() const;
  inline void set_param1(::google::protobuf::int32 value);

  // optional int32 param2 = 3;
  inline bool has_param2() const;
  inline void clear_param2();
  static const int kParam2FieldNumber = 3;
  inline ::google::protobuf::int32 param2() const;
  inline void set_param2(::google::protobuf::int32 value);

  // optional int32 param3 = 4;
  inline bool has_param3() const;
  inline void clear_param3();
  static const int kParam3FieldNumber = 4;
  inline ::google::protobuf::int32 param3() const;
  inline void set_param3(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseStartGame)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_param1();
  inline void clear_has_param1();
  inline void set_has_param2();
  inline void clear_has_param2();
  inline void set_has_param3();
  inline void clear_has_param3();

  ::google::protobuf::int32 result_;
  ::google::protobuf::int32 param1_;
  ::google::protobuf::int32 param2_;
  ::google::protobuf::int32 param3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static ResponseStartGame* default_instance_;
};
// -------------------------------------------------------------------

class NotifyUpdateProperty : public ::google::protobuf::MessageLite {
 public:
  NotifyUpdateProperty();
  virtual ~NotifyUpdateProperty();

  NotifyUpdateProperty(const NotifyUpdateProperty& from);

  inline NotifyUpdateProperty& operator=(const NotifyUpdateProperty& from) {
    CopyFrom(from);
    return *this;
  }

  static const NotifyUpdateProperty& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyUpdateProperty* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyUpdateProperty* other);

  // implements Message ----------------------------------------------

  NotifyUpdateProperty* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyUpdateProperty& from);
  void MergeFrom(const NotifyUpdateProperty& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charlevel = 1;
  inline bool has_charlevel() const;
  inline void clear_charlevel();
  static const int kCharlevelFieldNumber = 1;
  inline ::google::protobuf::int32 charlevel() const;
  inline void set_charlevel(::google::protobuf::int32 value);

  // optional uint64 cur_exp = 2;
  inline bool has_cur_exp() const;
  inline void clear_cur_exp();
  static const int kCurExpFieldNumber = 2;
  inline ::google::protobuf::uint64 cur_exp() const;
  inline void set_cur_exp(::google::protobuf::uint64 value);

  // optional uint64 max_exp = 3;
  inline bool has_max_exp() const;
  inline void clear_max_exp();
  static const int kMaxExpFieldNumber = 3;
  inline ::google::protobuf::uint64 max_exp() const;
  inline void set_max_exp(::google::protobuf::uint64 value);

  // optional uint64 gold = 4;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 4;
  inline ::google::protobuf::uint64 gold() const;
  inline void set_gold(::google::protobuf::uint64 value);

  // optional uint64 bindgold = 5;
  inline bool has_bindgold() const;
  inline void clear_bindgold();
  static const int kBindgoldFieldNumber = 5;
  inline ::google::protobuf::uint64 bindgold() const;
  inline void set_bindgold(::google::protobuf::uint64 value);

  // optional uint64 money = 6;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 6;
  inline ::google::protobuf::uint64 money() const;
  inline void set_money(::google::protobuf::uint64 value);

  // optional uint64 safemoney = 7;
  inline bool has_safemoney() const;
  inline void clear_safemoney();
  static const int kSafemoneyFieldNumber = 7;
  inline ::google::protobuf::uint64 safemoney() const;
  inline void set_safemoney(::google::protobuf::uint64 value);

  // optional int32 lvup_point = 10;
  inline bool has_lvup_point() const;
  inline void clear_lvup_point();
  static const int kLvupPointFieldNumber = 10;
  inline ::google::protobuf::int32 lvup_point() const;
  inline void set_lvup_point(::google::protobuf::int32 value);

  // optional int32 cur_str = 11;
  inline bool has_cur_str() const;
  inline void clear_cur_str();
  static const int kCurStrFieldNumber = 11;
  inline ::google::protobuf::int32 cur_str() const;
  inline void set_cur_str(::google::protobuf::int32 value);

  // optional int32 cur_dex = 12;
  inline bool has_cur_dex() const;
  inline void clear_cur_dex();
  static const int kCurDexFieldNumber = 12;
  inline ::google::protobuf::int32 cur_dex() const;
  inline void set_cur_dex(::google::protobuf::int32 value);

  // optional int32 cur_int = 13;
  inline bool has_cur_int() const;
  inline void clear_cur_int();
  static const int kCurIntFieldNumber = 13;
  inline ::google::protobuf::int32 cur_int() const;
  inline void set_cur_int(::google::protobuf::int32 value);

  // optional int32 cur_con = 14;
  inline bool has_cur_con() const;
  inline void clear_cur_con();
  static const int kCurConFieldNumber = 14;
  inline ::google::protobuf::int32 cur_con() const;
  inline void set_cur_con(::google::protobuf::int32 value);

  // optional int32 cur_wiz = 15;
  inline bool has_cur_wiz() const;
  inline void clear_cur_wiz();
  static const int kCurWizFieldNumber = 15;
  inline ::google::protobuf::int32 cur_wiz() const;
  inline void set_cur_wiz(::google::protobuf::int32 value);

  // optional int32 cur_hp = 16;
  inline bool has_cur_hp() const;
  inline void clear_cur_hp();
  static const int kCurHpFieldNumber = 16;
  inline ::google::protobuf::int32 cur_hp() const;
  inline void set_cur_hp(::google::protobuf::int32 value);

  // optional int32 cur_mp = 17;
  inline bool has_cur_mp() const;
  inline void clear_cur_mp();
  static const int kCurMpFieldNumber = 17;
  inline ::google::protobuf::int32 cur_mp() const;
  inline void set_cur_mp(::google::protobuf::int32 value);

  // optional int32 max_hp = 18;
  inline bool has_max_hp() const;
  inline void clear_max_hp();
  static const int kMaxHpFieldNumber = 18;
  inline ::google::protobuf::int32 max_hp() const;
  inline void set_max_hp(::google::protobuf::int32 value);

  // optional int32 max_mp = 19;
  inline bool has_max_mp() const;
  inline void clear_max_mp();
  static const int kMaxMpFieldNumber = 19;
  inline ::google::protobuf::int32 max_mp() const;
  inline void set_max_mp(::google::protobuf::int32 value);

  // optional int32 attack = 20;
  inline bool has_attack() const;
  inline void clear_attack();
  static const int kAttackFieldNumber = 20;
  inline ::google::protobuf::int32 attack() const;
  inline void set_attack(::google::protobuf::int32 value);

  // optional int32 phy_defence = 21;
  inline bool has_phy_defence() const;
  inline void clear_phy_defence();
  static const int kPhyDefenceFieldNumber = 21;
  inline ::google::protobuf::int32 phy_defence() const;
  inline void set_phy_defence(::google::protobuf::int32 value);

  // optional int32 mag_defence = 22;
  inline bool has_mag_defence() const;
  inline void clear_mag_defence();
  static const int kMagDefenceFieldNumber = 22;
  inline ::google::protobuf::int32 mag_defence() const;
  inline void set_mag_defence(::google::protobuf::int32 value);

  // optional int32 move_speed = 23;
  inline bool has_move_speed() const;
  inline void clear_move_speed();
  static const int kMoveSpeedFieldNumber = 23;
  inline ::google::protobuf::int32 move_speed() const;
  inline void set_move_speed(::google::protobuf::int32 value);

  // optional int32 pk_count = 24;
  inline bool has_pk_count() const;
  inline void clear_pk_count();
  static const int kPkCountFieldNumber = 24;
  inline ::google::protobuf::int32 pk_count() const;
  inline void set_pk_count(::google::protobuf::int32 value);

  // optional float hit_chance = 25;
  inline bool has_hit_chance() const;
  inline void clear_hit_chance();
  static const int kHitChanceFieldNumber = 25;
  inline float hit_chance() const;
  inline void set_hit_chance(float value);

  // optional float dodge_chance = 26;
  inline bool has_dodge_chance() const;
  inline void clear_dodge_chance();
  static const int kDodgeChanceFieldNumber = 26;
  inline float dodge_chance() const;
  inline void set_dodge_chance(float value);

  // optional float critical = 27;
  inline bool has_critical() const;
  inline void clear_critical();
  static const int kCriticalFieldNumber = 27;
  inline float critical() const;
  inline void set_critical(float value);

  // optional float critical_dodge = 28;
  inline bool has_critical_dodge() const;
  inline void clear_critical_dodge();
  static const int kCriticalDodgeFieldNumber = 28;
  inline float critical_dodge() const;
  inline void set_critical_dodge(float value);

  // optional string matename = 29;
  inline bool has_matename() const;
  inline void clear_matename();
  static const int kMatenameFieldNumber = 29;
  inline const ::std::string& matename() const;
  inline void set_matename(const ::std::string& value);
  inline void set_matename(const char* value);
  inline void set_matename(const char* value, size_t size);
  inline ::std::string* mutable_matename();
  inline ::std::string* release_matename();
  inline void set_allocated_matename(::std::string* matename);

  // optional string guildname = 30;
  inline bool has_guildname() const;
  inline void clear_guildname();
  static const int kGuildnameFieldNumber = 30;
  inline const ::std::string& guildname() const;
  inline void set_guildname(const ::std::string& value);
  inline void set_guildname(const char* value);
  inline void set_guildname(const char* value, size_t size);
  inline ::std::string* mutable_guildname();
  inline ::std::string* release_guildname();
  inline void set_allocated_guildname(::std::string* guildname);

  // optional int32 guild_credits = 31;
  inline bool has_guild_credits() const;
  inline void clear_guild_credits();
  static const int kGuildCreditsFieldNumber = 31;
  inline ::google::protobuf::int32 guild_credits() const;
  inline void set_guild_credits(::google::protobuf::int32 value);

  // optional uint64 total_gold = 32;
  inline bool has_total_gold() const;
  inline void clear_total_gold();
  static const int kTotalGoldFieldNumber = 32;
  inline ::google::protobuf::uint64 total_gold() const;
  inline void set_total_gold(::google::protobuf::uint64 value);

  // optional int32 total_guild_credits = 33;
  inline bool has_total_guild_credits() const;
  inline void clear_total_guild_credits();
  static const int kTotalGuildCreditsFieldNumber = 33;
  inline ::google::protobuf::int32 total_guild_credits() const;
  inline void set_total_guild_credits(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.NotifyUpdateProperty)
 private:
  inline void set_has_charlevel();
  inline void clear_has_charlevel();
  inline void set_has_cur_exp();
  inline void clear_has_cur_exp();
  inline void set_has_max_exp();
  inline void clear_has_max_exp();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_bindgold();
  inline void clear_has_bindgold();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_safemoney();
  inline void clear_has_safemoney();
  inline void set_has_lvup_point();
  inline void clear_has_lvup_point();
  inline void set_has_cur_str();
  inline void clear_has_cur_str();
  inline void set_has_cur_dex();
  inline void clear_has_cur_dex();
  inline void set_has_cur_int();
  inline void clear_has_cur_int();
  inline void set_has_cur_con();
  inline void clear_has_cur_con();
  inline void set_has_cur_wiz();
  inline void clear_has_cur_wiz();
  inline void set_has_cur_hp();
  inline void clear_has_cur_hp();
  inline void set_has_cur_mp();
  inline void clear_has_cur_mp();
  inline void set_has_max_hp();
  inline void clear_has_max_hp();
  inline void set_has_max_mp();
  inline void clear_has_max_mp();
  inline void set_has_attack();
  inline void clear_has_attack();
  inline void set_has_phy_defence();
  inline void clear_has_phy_defence();
  inline void set_has_mag_defence();
  inline void clear_has_mag_defence();
  inline void set_has_move_speed();
  inline void clear_has_move_speed();
  inline void set_has_pk_count();
  inline void clear_has_pk_count();
  inline void set_has_hit_chance();
  inline void clear_has_hit_chance();
  inline void set_has_dodge_chance();
  inline void clear_has_dodge_chance();
  inline void set_has_critical();
  inline void clear_has_critical();
  inline void set_has_critical_dodge();
  inline void clear_has_critical_dodge();
  inline void set_has_matename();
  inline void clear_has_matename();
  inline void set_has_guildname();
  inline void clear_has_guildname();
  inline void set_has_guild_credits();
  inline void clear_has_guild_credits();
  inline void set_has_total_gold();
  inline void clear_has_total_gold();
  inline void set_has_total_guild_credits();
  inline void clear_has_total_guild_credits();

  ::google::protobuf::uint64 cur_exp_;
  ::google::protobuf::uint64 max_exp_;
  ::google::protobuf::uint64 gold_;
  ::google::protobuf::int32 charlevel_;
  ::google::protobuf::int32 lvup_point_;
  ::google::protobuf::uint64 bindgold_;
  ::google::protobuf::uint64 money_;
  ::google::protobuf::uint64 safemoney_;
  ::google::protobuf::int32 cur_str_;
  ::google::protobuf::int32 cur_dex_;
  ::google::protobuf::int32 cur_int_;
  ::google::protobuf::int32 cur_con_;
  ::google::protobuf::int32 cur_wiz_;
  ::google::protobuf::int32 cur_hp_;
  ::google::protobuf::int32 cur_mp_;
  ::google::protobuf::int32 max_hp_;
  ::google::protobuf::int32 max_mp_;
  ::google::protobuf::int32 attack_;
  ::google::protobuf::int32 phy_defence_;
  ::google::protobuf::int32 mag_defence_;
  ::google::protobuf::int32 move_speed_;
  ::google::protobuf::int32 pk_count_;
  float hit_chance_;
  float dodge_chance_;
  float critical_;
  float critical_dodge_;
  ::std::string* matename_;
  ::std::string* guildname_;
  ::google::protobuf::uint64 total_gold_;
  ::google::protobuf::int32 guild_credits_;
  ::google::protobuf::int32 total_guild_credits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static NotifyUpdateProperty* default_instance_;
};
// -------------------------------------------------------------------

class RequestUseLvupPoint : public ::google::protobuf::MessageLite {
 public:
  RequestUseLvupPoint();
  virtual ~RequestUseLvupPoint();

  RequestUseLvupPoint(const RequestUseLvupPoint& from);

  inline RequestUseLvupPoint& operator=(const RequestUseLvupPoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestUseLvupPoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestUseLvupPoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestUseLvupPoint* other);

  // implements Message ----------------------------------------------

  RequestUseLvupPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestUseLvupPoint& from);
  void MergeFrom(const RequestUseLvupPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 inc_str = 1;
  inline bool has_inc_str() const;
  inline void clear_inc_str();
  static const int kIncStrFieldNumber = 1;
  inline ::google::protobuf::uint32 inc_str() const;
  inline void set_inc_str(::google::protobuf::uint32 value);

  // optional uint32 inc_dex = 2;
  inline bool has_inc_dex() const;
  inline void clear_inc_dex();
  static const int kIncDexFieldNumber = 2;
  inline ::google::protobuf::uint32 inc_dex() const;
  inline void set_inc_dex(::google::protobuf::uint32 value);

  // optional uint32 inc_intgent = 3;
  inline bool has_inc_intgent() const;
  inline void clear_inc_intgent();
  static const int kIncIntgentFieldNumber = 3;
  inline ::google::protobuf::uint32 inc_intgent() const;
  inline void set_inc_intgent(::google::protobuf::uint32 value);

  // optional uint32 inc_con = 4;
  inline bool has_inc_con() const;
  inline void clear_inc_con();
  static const int kIncConFieldNumber = 4;
  inline ::google::protobuf::uint32 inc_con() const;
  inline void set_inc_con(::google::protobuf::uint32 value);

  // optional uint32 inc_wiz = 5;
  inline bool has_inc_wiz() const;
  inline void clear_inc_wiz();
  static const int kIncWizFieldNumber = 5;
  inline ::google::protobuf::uint32 inc_wiz() const;
  inline void set_inc_wiz(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestUseLvupPoint)
 private:
  inline void set_has_inc_str();
  inline void clear_has_inc_str();
  inline void set_has_inc_dex();
  inline void clear_has_inc_dex();
  inline void set_has_inc_intgent();
  inline void clear_has_inc_intgent();
  inline void set_has_inc_con();
  inline void clear_has_inc_con();
  inline void set_has_inc_wiz();
  inline void clear_has_inc_wiz();

  ::google::protobuf::uint32 inc_str_;
  ::google::protobuf::uint32 inc_dex_;
  ::google::protobuf::uint32 inc_intgent_;
  ::google::protobuf::uint32 inc_con_;
  ::google::protobuf::uint32 inc_wiz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestUseLvupPoint* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUseLvupPoint : public ::google::protobuf::MessageLite {
 public:
  ResponseUseLvupPoint();
  virtual ~ResponseUseLvupPoint();

  ResponseUseLvupPoint(const ResponseUseLvupPoint& from);

  inline ResponseUseLvupPoint& operator=(const ResponseUseLvupPoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseUseLvupPoint& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseUseLvupPoint* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseUseLvupPoint* other);

  // implements Message ----------------------------------------------

  ResponseUseLvupPoint* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseUseLvupPoint& from);
  void MergeFrom(const ResponseUseLvupPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseUseLvupPoint)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::uint32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static ResponseUseLvupPoint* default_instance_;
};
// -------------------------------------------------------------------

class RequestRecharge : public ::google::protobuf::MessageLite {
 public:
  RequestRecharge();
  virtual ~RequestRecharge();

  RequestRecharge(const RequestRecharge& from);

  inline RequestRecharge& operator=(const RequestRecharge& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestRecharge& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestRecharge* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestRecharge* other);

  // implements Message ----------------------------------------------

  RequestRecharge* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestRecharge& from);
  void MergeFrom(const RequestRecharge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::uint32 reserve() const;
  inline void set_reserve(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestRecharge)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::uint32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestRecharge* default_instance_;
};
// -------------------------------------------------------------------

class RequestSetShortcutKey : public ::google::protobuf::MessageLite {
 public:
  RequestSetShortcutKey();
  virtual ~RequestSetShortcutKey();

  RequestSetShortcutKey(const RequestSetShortcutKey& from);

  inline RequestSetShortcutKey& operator=(const RequestSetShortcutKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestSetShortcutKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSetShortcutKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSetShortcutKey* other);

  // implements Message ----------------------------------------------

  RequestSetShortcutKey* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSetShortcutKey& from);
  void MergeFrom(const RequestSetShortcutKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ShortcutKeyData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::ShortcutKeyData& data() const;
  inline ::ShortcutKeyData* mutable_data();
  inline ::ShortcutKeyData* release_data();
  inline void set_allocated_data(::ShortcutKeyData* data);

  // @@protoc_insertion_point(class_scope:Protocol.RequestSetShortcutKey)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::ShortcutKeyData* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestSetShortcutKey* default_instance_;
};
// -------------------------------------------------------------------

class RequestLookCharEquip : public ::google::protobuf::MessageLite {
 public:
  RequestLookCharEquip();
  virtual ~RequestLookCharEquip();

  RequestLookCharEquip(const RequestLookCharEquip& from);

  inline RequestLookCharEquip& operator=(const RequestLookCharEquip& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestLookCharEquip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestLookCharEquip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestLookCharEquip* other);

  // implements Message ----------------------------------------------

  RequestLookCharEquip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestLookCharEquip& from);
  void MergeFrom(const RequestLookCharEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Protocol.RequestLookCharEquip)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestLookCharEquip* default_instance_;
};
// -------------------------------------------------------------------

class ResponseLookCharEquip : public ::google::protobuf::MessageLite {
 public:
  ResponseLookCharEquip();
  virtual ~ResponseLookCharEquip();

  ResponseLookCharEquip(const ResponseLookCharEquip& from);

  inline ResponseLookCharEquip& operator=(const ResponseLookCharEquip& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseLookCharEquip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseLookCharEquip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseLookCharEquip* other);

  // implements Message ----------------------------------------------

  ResponseLookCharEquip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseLookCharEquip& from);
  void MergeFrom(const ResponseLookCharEquip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // optional int32 race = 3;
  inline bool has_race() const;
  inline void clear_race();
  static const int kRaceFieldNumber = 3;
  inline ::google::protobuf::int32 race() const;
  inline void set_race(::google::protobuf::int32 value);

  // optional string guild_name = 4;
  inline bool has_guild_name() const;
  inline void clear_guild_name();
  static const int kGuildNameFieldNumber = 4;
  inline const ::std::string& guild_name() const;
  inline void set_guild_name(const ::std::string& value);
  inline void set_guild_name(const char* value);
  inline void set_guild_name(const char* value, size_t size);
  inline ::std::string* mutable_guild_name();
  inline ::std::string* release_guild_name();
  inline void set_allocated_guild_name(::std::string* guild_name);

  // repeated .ItemData equip_items = 10;
  inline int equip_items_size() const;
  inline void clear_equip_items();
  static const int kEquipItemsFieldNumber = 10;
  inline const ::ItemData& equip_items(int index) const;
  inline ::ItemData* mutable_equip_items(int index);
  inline ::ItemData* add_equip_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      equip_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_equip_items();

  // repeated .ItemData avatar_items = 11;
  inline int avatar_items_size() const;
  inline void clear_avatar_items();
  static const int kAvatarItemsFieldNumber = 11;
  inline const ::ItemData& avatar_items(int index) const;
  inline ::ItemData* mutable_avatar_items(int index);
  inline ::ItemData* add_avatar_items();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      avatar_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_avatar_items();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseLookCharEquip)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_guild_name();
  inline void clear_has_guild_name();

  ::std::string* name_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 race_;
  ::std::string* guild_name_;
  ::google::protobuf::RepeatedPtrField< ::ItemData > equip_items_;
  ::google::protobuf::RepeatedPtrField< ::ItemData > avatar_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static ResponseLookCharEquip* default_instance_;
};
// -------------------------------------------------------------------

class RequestTakeVipAward : public ::google::protobuf::MessageLite {
 public:
  RequestTakeVipAward();
  virtual ~RequestTakeVipAward();

  RequestTakeVipAward(const RequestTakeVipAward& from);

  inline RequestTakeVipAward& operator=(const RequestTakeVipAward& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestTakeVipAward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestTakeVipAward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestTakeVipAward* other);

  // implements Message ----------------------------------------------

  RequestTakeVipAward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestTakeVipAward& from);
  void MergeFrom(const RequestTakeVipAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 vip_award_id = 1;
  inline bool has_vip_award_id() const;
  inline void clear_vip_award_id();
  static const int kVipAwardIdFieldNumber = 1;
  inline ::google::protobuf::uint32 vip_award_id() const;
  inline void set_vip_award_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestTakeVipAward)
 private:
  inline void set_has_vip_award_id();
  inline void clear_has_vip_award_id();

  ::google::protobuf::uint32 vip_award_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestTakeVipAward* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTakeVipAward : public ::google::protobuf::MessageLite {
 public:
  ResponseTakeVipAward();
  virtual ~ResponseTakeVipAward();

  ResponseTakeVipAward(const ResponseTakeVipAward& from);

  inline ResponseTakeVipAward& operator=(const ResponseTakeVipAward& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseTakeVipAward& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseTakeVipAward* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseTakeVipAward* other);

  // implements Message ----------------------------------------------

  ResponseTakeVipAward* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseTakeVipAward& from);
  void MergeFrom(const ResponseTakeVipAward& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 vip_award_id = 1;
  inline bool has_vip_award_id() const;
  inline void clear_vip_award_id();
  static const int kVipAwardIdFieldNumber = 1;
  inline ::google::protobuf::int32 vip_award_id() const;
  inline void set_vip_award_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseTakeVipAward)
 private:
  inline void set_has_vip_award_id();
  inline void clear_has_vip_award_id();

  ::google::protobuf::int32 vip_award_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static ResponseTakeVipAward* default_instance_;
};
// -------------------------------------------------------------------

class RequestSaveSetting : public ::google::protobuf::MessageLite {
 public:
  RequestSaveSetting();
  virtual ~RequestSaveSetting();

  RequestSaveSetting(const RequestSaveSetting& from);

  inline RequestSaveSetting& operator=(const RequestSaveSetting& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestSaveSetting& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestSaveSetting* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestSaveSetting* other);

  // implements Message ----------------------------------------------

  RequestSaveSetting* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestSaveSetting& from);
  void MergeFrom(const RequestSaveSetting& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SettingData setting_data = 1;
  inline bool has_setting_data() const;
  inline void clear_setting_data();
  static const int kSettingDataFieldNumber = 1;
  inline const ::SettingData& setting_data() const;
  inline ::SettingData* mutable_setting_data();
  inline ::SettingData* release_setting_data();
  inline void set_allocated_setting_data(::SettingData* setting_data);

  // @@protoc_insertion_point(class_scope:Protocol.RequestSaveSetting)
 private:
  inline void set_has_setting_data();
  inline void clear_has_setting_data();

  ::SettingData* setting_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoCharData_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoCharData_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoCharData_2eproto();
  friend void protobuf_ShutdownFile_ProtoCharData_2eproto();

  void InitAsDefaultInstance();
  static RequestSaveSetting* default_instance_;
};
// ===================================================================


// ===================================================================

// RequestCheckPing

// optional uint32 timestamp = 1;
inline bool RequestCheckPing::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCheckPing::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCheckPing::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCheckPing::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 RequestCheckPing::timestamp() const {
  return timestamp_;
}
inline void RequestCheckPing::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// ResponseCheckPing

// optional uint32 timestamp = 1;
inline bool ResponseCheckPing::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCheckPing::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCheckPing::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCheckPing::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 ResponseCheckPing::timestamp() const {
  return timestamp_;
}
inline void ResponseCheckPing::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// RequestStartGame

// optional int32 timestamp = 1;
inline bool RequestStartGame::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStartGame::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStartGame::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStartGame::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 RequestStartGame::timestamp() const {
  return timestamp_;
}
inline void RequestStartGame::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// ResponseStartGame

// optional int32 result = 1;
inline bool ResponseStartGame::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseStartGame::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseStartGame::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseStartGame::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseStartGame::result() const {
  return result_;
}
inline void ResponseStartGame::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// optional int32 param1 = 2;
inline bool ResponseStartGame::has_param1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseStartGame::set_has_param1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseStartGame::clear_has_param1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseStartGame::clear_param1() {
  param1_ = 0;
  clear_has_param1();
}
inline ::google::protobuf::int32 ResponseStartGame::param1() const {
  return param1_;
}
inline void ResponseStartGame::set_param1(::google::protobuf::int32 value) {
  set_has_param1();
  param1_ = value;
}

// optional int32 param2 = 3;
inline bool ResponseStartGame::has_param2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseStartGame::set_has_param2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseStartGame::clear_has_param2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseStartGame::clear_param2() {
  param2_ = 0;
  clear_has_param2();
}
inline ::google::protobuf::int32 ResponseStartGame::param2() const {
  return param2_;
}
inline void ResponseStartGame::set_param2(::google::protobuf::int32 value) {
  set_has_param2();
  param2_ = value;
}

// optional int32 param3 = 4;
inline bool ResponseStartGame::has_param3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseStartGame::set_has_param3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseStartGame::clear_has_param3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseStartGame::clear_param3() {
  param3_ = 0;
  clear_has_param3();
}
inline ::google::protobuf::int32 ResponseStartGame::param3() const {
  return param3_;
}
inline void ResponseStartGame::set_param3(::google::protobuf::int32 value) {
  set_has_param3();
  param3_ = value;
}

// -------------------------------------------------------------------

// NotifyUpdateProperty

// optional int32 charlevel = 1;
inline bool NotifyUpdateProperty::has_charlevel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyUpdateProperty::set_has_charlevel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyUpdateProperty::clear_has_charlevel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyUpdateProperty::clear_charlevel() {
  charlevel_ = 0;
  clear_has_charlevel();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::charlevel() const {
  return charlevel_;
}
inline void NotifyUpdateProperty::set_charlevel(::google::protobuf::int32 value) {
  set_has_charlevel();
  charlevel_ = value;
}

// optional uint64 cur_exp = 2;
inline bool NotifyUpdateProperty::has_cur_exp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_exp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyUpdateProperty::clear_has_cur_exp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyUpdateProperty::clear_cur_exp() {
  cur_exp_ = GOOGLE_ULONGLONG(0);
  clear_has_cur_exp();
}
inline ::google::protobuf::uint64 NotifyUpdateProperty::cur_exp() const {
  return cur_exp_;
}
inline void NotifyUpdateProperty::set_cur_exp(::google::protobuf::uint64 value) {
  set_has_cur_exp();
  cur_exp_ = value;
}

// optional uint64 max_exp = 3;
inline bool NotifyUpdateProperty::has_max_exp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NotifyUpdateProperty::set_has_max_exp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NotifyUpdateProperty::clear_has_max_exp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NotifyUpdateProperty::clear_max_exp() {
  max_exp_ = GOOGLE_ULONGLONG(0);
  clear_has_max_exp();
}
inline ::google::protobuf::uint64 NotifyUpdateProperty::max_exp() const {
  return max_exp_;
}
inline void NotifyUpdateProperty::set_max_exp(::google::protobuf::uint64 value) {
  set_has_max_exp();
  max_exp_ = value;
}

// optional uint64 gold = 4;
inline bool NotifyUpdateProperty::has_gold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NotifyUpdateProperty::set_has_gold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NotifyUpdateProperty::clear_has_gold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NotifyUpdateProperty::clear_gold() {
  gold_ = GOOGLE_ULONGLONG(0);
  clear_has_gold();
}
inline ::google::protobuf::uint64 NotifyUpdateProperty::gold() const {
  return gold_;
}
inline void NotifyUpdateProperty::set_gold(::google::protobuf::uint64 value) {
  set_has_gold();
  gold_ = value;
}

// optional uint64 bindgold = 5;
inline bool NotifyUpdateProperty::has_bindgold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NotifyUpdateProperty::set_has_bindgold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NotifyUpdateProperty::clear_has_bindgold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NotifyUpdateProperty::clear_bindgold() {
  bindgold_ = GOOGLE_ULONGLONG(0);
  clear_has_bindgold();
}
inline ::google::protobuf::uint64 NotifyUpdateProperty::bindgold() const {
  return bindgold_;
}
inline void NotifyUpdateProperty::set_bindgold(::google::protobuf::uint64 value) {
  set_has_bindgold();
  bindgold_ = value;
}

// optional uint64 money = 6;
inline bool NotifyUpdateProperty::has_money() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NotifyUpdateProperty::set_has_money() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NotifyUpdateProperty::clear_has_money() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NotifyUpdateProperty::clear_money() {
  money_ = GOOGLE_ULONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::uint64 NotifyUpdateProperty::money() const {
  return money_;
}
inline void NotifyUpdateProperty::set_money(::google::protobuf::uint64 value) {
  set_has_money();
  money_ = value;
}

// optional uint64 safemoney = 7;
inline bool NotifyUpdateProperty::has_safemoney() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NotifyUpdateProperty::set_has_safemoney() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NotifyUpdateProperty::clear_has_safemoney() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NotifyUpdateProperty::clear_safemoney() {
  safemoney_ = GOOGLE_ULONGLONG(0);
  clear_has_safemoney();
}
inline ::google::protobuf::uint64 NotifyUpdateProperty::safemoney() const {
  return safemoney_;
}
inline void NotifyUpdateProperty::set_safemoney(::google::protobuf::uint64 value) {
  set_has_safemoney();
  safemoney_ = value;
}

// optional int32 lvup_point = 10;
inline bool NotifyUpdateProperty::has_lvup_point() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NotifyUpdateProperty::set_has_lvup_point() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NotifyUpdateProperty::clear_has_lvup_point() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NotifyUpdateProperty::clear_lvup_point() {
  lvup_point_ = 0;
  clear_has_lvup_point();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::lvup_point() const {
  return lvup_point_;
}
inline void NotifyUpdateProperty::set_lvup_point(::google::protobuf::int32 value) {
  set_has_lvup_point();
  lvup_point_ = value;
}

// optional int32 cur_str = 11;
inline bool NotifyUpdateProperty::has_cur_str() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_str() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NotifyUpdateProperty::clear_has_cur_str() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NotifyUpdateProperty::clear_cur_str() {
  cur_str_ = 0;
  clear_has_cur_str();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::cur_str() const {
  return cur_str_;
}
inline void NotifyUpdateProperty::set_cur_str(::google::protobuf::int32 value) {
  set_has_cur_str();
  cur_str_ = value;
}

// optional int32 cur_dex = 12;
inline bool NotifyUpdateProperty::has_cur_dex() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_dex() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NotifyUpdateProperty::clear_has_cur_dex() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NotifyUpdateProperty::clear_cur_dex() {
  cur_dex_ = 0;
  clear_has_cur_dex();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::cur_dex() const {
  return cur_dex_;
}
inline void NotifyUpdateProperty::set_cur_dex(::google::protobuf::int32 value) {
  set_has_cur_dex();
  cur_dex_ = value;
}

// optional int32 cur_int = 13;
inline bool NotifyUpdateProperty::has_cur_int() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_int() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NotifyUpdateProperty::clear_has_cur_int() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NotifyUpdateProperty::clear_cur_int() {
  cur_int_ = 0;
  clear_has_cur_int();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::cur_int() const {
  return cur_int_;
}
inline void NotifyUpdateProperty::set_cur_int(::google::protobuf::int32 value) {
  set_has_cur_int();
  cur_int_ = value;
}

// optional int32 cur_con = 14;
inline bool NotifyUpdateProperty::has_cur_con() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_con() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NotifyUpdateProperty::clear_has_cur_con() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NotifyUpdateProperty::clear_cur_con() {
  cur_con_ = 0;
  clear_has_cur_con();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::cur_con() const {
  return cur_con_;
}
inline void NotifyUpdateProperty::set_cur_con(::google::protobuf::int32 value) {
  set_has_cur_con();
  cur_con_ = value;
}

// optional int32 cur_wiz = 15;
inline bool NotifyUpdateProperty::has_cur_wiz() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_wiz() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NotifyUpdateProperty::clear_has_cur_wiz() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NotifyUpdateProperty::clear_cur_wiz() {
  cur_wiz_ = 0;
  clear_has_cur_wiz();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::cur_wiz() const {
  return cur_wiz_;
}
inline void NotifyUpdateProperty::set_cur_wiz(::google::protobuf::int32 value) {
  set_has_cur_wiz();
  cur_wiz_ = value;
}

// optional int32 cur_hp = 16;
inline bool NotifyUpdateProperty::has_cur_hp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_hp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NotifyUpdateProperty::clear_has_cur_hp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NotifyUpdateProperty::clear_cur_hp() {
  cur_hp_ = 0;
  clear_has_cur_hp();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::cur_hp() const {
  return cur_hp_;
}
inline void NotifyUpdateProperty::set_cur_hp(::google::protobuf::int32 value) {
  set_has_cur_hp();
  cur_hp_ = value;
}

// optional int32 cur_mp = 17;
inline bool NotifyUpdateProperty::has_cur_mp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NotifyUpdateProperty::set_has_cur_mp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NotifyUpdateProperty::clear_has_cur_mp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NotifyUpdateProperty::clear_cur_mp() {
  cur_mp_ = 0;
  clear_has_cur_mp();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::cur_mp() const {
  return cur_mp_;
}
inline void NotifyUpdateProperty::set_cur_mp(::google::protobuf::int32 value) {
  set_has_cur_mp();
  cur_mp_ = value;
}

// optional int32 max_hp = 18;
inline bool NotifyUpdateProperty::has_max_hp() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NotifyUpdateProperty::set_has_max_hp() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NotifyUpdateProperty::clear_has_max_hp() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NotifyUpdateProperty::clear_max_hp() {
  max_hp_ = 0;
  clear_has_max_hp();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::max_hp() const {
  return max_hp_;
}
inline void NotifyUpdateProperty::set_max_hp(::google::protobuf::int32 value) {
  set_has_max_hp();
  max_hp_ = value;
}

// optional int32 max_mp = 19;
inline bool NotifyUpdateProperty::has_max_mp() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NotifyUpdateProperty::set_has_max_mp() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NotifyUpdateProperty::clear_has_max_mp() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NotifyUpdateProperty::clear_max_mp() {
  max_mp_ = 0;
  clear_has_max_mp();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::max_mp() const {
  return max_mp_;
}
inline void NotifyUpdateProperty::set_max_mp(::google::protobuf::int32 value) {
  set_has_max_mp();
  max_mp_ = value;
}

// optional int32 attack = 20;
inline bool NotifyUpdateProperty::has_attack() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NotifyUpdateProperty::set_has_attack() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NotifyUpdateProperty::clear_has_attack() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NotifyUpdateProperty::clear_attack() {
  attack_ = 0;
  clear_has_attack();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::attack() const {
  return attack_;
}
inline void NotifyUpdateProperty::set_attack(::google::protobuf::int32 value) {
  set_has_attack();
  attack_ = value;
}

// optional int32 phy_defence = 21;
inline bool NotifyUpdateProperty::has_phy_defence() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NotifyUpdateProperty::set_has_phy_defence() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NotifyUpdateProperty::clear_has_phy_defence() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NotifyUpdateProperty::clear_phy_defence() {
  phy_defence_ = 0;
  clear_has_phy_defence();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::phy_defence() const {
  return phy_defence_;
}
inline void NotifyUpdateProperty::set_phy_defence(::google::protobuf::int32 value) {
  set_has_phy_defence();
  phy_defence_ = value;
}

// optional int32 mag_defence = 22;
inline bool NotifyUpdateProperty::has_mag_defence() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NotifyUpdateProperty::set_has_mag_defence() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NotifyUpdateProperty::clear_has_mag_defence() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NotifyUpdateProperty::clear_mag_defence() {
  mag_defence_ = 0;
  clear_has_mag_defence();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::mag_defence() const {
  return mag_defence_;
}
inline void NotifyUpdateProperty::set_mag_defence(::google::protobuf::int32 value) {
  set_has_mag_defence();
  mag_defence_ = value;
}

// optional int32 move_speed = 23;
inline bool NotifyUpdateProperty::has_move_speed() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NotifyUpdateProperty::set_has_move_speed() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NotifyUpdateProperty::clear_has_move_speed() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NotifyUpdateProperty::clear_move_speed() {
  move_speed_ = 0;
  clear_has_move_speed();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::move_speed() const {
  return move_speed_;
}
inline void NotifyUpdateProperty::set_move_speed(::google::protobuf::int32 value) {
  set_has_move_speed();
  move_speed_ = value;
}

// optional int32 pk_count = 24;
inline bool NotifyUpdateProperty::has_pk_count() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NotifyUpdateProperty::set_has_pk_count() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NotifyUpdateProperty::clear_has_pk_count() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NotifyUpdateProperty::clear_pk_count() {
  pk_count_ = 0;
  clear_has_pk_count();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::pk_count() const {
  return pk_count_;
}
inline void NotifyUpdateProperty::set_pk_count(::google::protobuf::int32 value) {
  set_has_pk_count();
  pk_count_ = value;
}

// optional float hit_chance = 25;
inline bool NotifyUpdateProperty::has_hit_chance() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NotifyUpdateProperty::set_has_hit_chance() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NotifyUpdateProperty::clear_has_hit_chance() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NotifyUpdateProperty::clear_hit_chance() {
  hit_chance_ = 0;
  clear_has_hit_chance();
}
inline float NotifyUpdateProperty::hit_chance() const {
  return hit_chance_;
}
inline void NotifyUpdateProperty::set_hit_chance(float value) {
  set_has_hit_chance();
  hit_chance_ = value;
}

// optional float dodge_chance = 26;
inline bool NotifyUpdateProperty::has_dodge_chance() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NotifyUpdateProperty::set_has_dodge_chance() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NotifyUpdateProperty::clear_has_dodge_chance() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NotifyUpdateProperty::clear_dodge_chance() {
  dodge_chance_ = 0;
  clear_has_dodge_chance();
}
inline float NotifyUpdateProperty::dodge_chance() const {
  return dodge_chance_;
}
inline void NotifyUpdateProperty::set_dodge_chance(float value) {
  set_has_dodge_chance();
  dodge_chance_ = value;
}

// optional float critical = 27;
inline bool NotifyUpdateProperty::has_critical() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NotifyUpdateProperty::set_has_critical() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NotifyUpdateProperty::clear_has_critical() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NotifyUpdateProperty::clear_critical() {
  critical_ = 0;
  clear_has_critical();
}
inline float NotifyUpdateProperty::critical() const {
  return critical_;
}
inline void NotifyUpdateProperty::set_critical(float value) {
  set_has_critical();
  critical_ = value;
}

// optional float critical_dodge = 28;
inline bool NotifyUpdateProperty::has_critical_dodge() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NotifyUpdateProperty::set_has_critical_dodge() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NotifyUpdateProperty::clear_has_critical_dodge() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NotifyUpdateProperty::clear_critical_dodge() {
  critical_dodge_ = 0;
  clear_has_critical_dodge();
}
inline float NotifyUpdateProperty::critical_dodge() const {
  return critical_dodge_;
}
inline void NotifyUpdateProperty::set_critical_dodge(float value) {
  set_has_critical_dodge();
  critical_dodge_ = value;
}

// optional string matename = 29;
inline bool NotifyUpdateProperty::has_matename() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NotifyUpdateProperty::set_has_matename() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NotifyUpdateProperty::clear_has_matename() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NotifyUpdateProperty::clear_matename() {
  if (matename_ != &::google::protobuf::internal::kEmptyString) {
    matename_->clear();
  }
  clear_has_matename();
}
inline const ::std::string& NotifyUpdateProperty::matename() const {
  return *matename_;
}
inline void NotifyUpdateProperty::set_matename(const ::std::string& value) {
  set_has_matename();
  if (matename_ == &::google::protobuf::internal::kEmptyString) {
    matename_ = new ::std::string;
  }
  matename_->assign(value);
}
inline void NotifyUpdateProperty::set_matename(const char* value) {
  set_has_matename();
  if (matename_ == &::google::protobuf::internal::kEmptyString) {
    matename_ = new ::std::string;
  }
  matename_->assign(value);
}
inline void NotifyUpdateProperty::set_matename(const char* value, size_t size) {
  set_has_matename();
  if (matename_ == &::google::protobuf::internal::kEmptyString) {
    matename_ = new ::std::string;
  }
  matename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyUpdateProperty::mutable_matename() {
  set_has_matename();
  if (matename_ == &::google::protobuf::internal::kEmptyString) {
    matename_ = new ::std::string;
  }
  return matename_;
}
inline ::std::string* NotifyUpdateProperty::release_matename() {
  clear_has_matename();
  if (matename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matename_;
    matename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyUpdateProperty::set_allocated_matename(::std::string* matename) {
  if (matename_ != &::google::protobuf::internal::kEmptyString) {
    delete matename_;
  }
  if (matename) {
    set_has_matename();
    matename_ = matename;
  } else {
    clear_has_matename();
    matename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string guildname = 30;
inline bool NotifyUpdateProperty::has_guildname() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NotifyUpdateProperty::set_has_guildname() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NotifyUpdateProperty::clear_has_guildname() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NotifyUpdateProperty::clear_guildname() {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    guildname_->clear();
  }
  clear_has_guildname();
}
inline const ::std::string& NotifyUpdateProperty::guildname() const {
  return *guildname_;
}
inline void NotifyUpdateProperty::set_guildname(const ::std::string& value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void NotifyUpdateProperty::set_guildname(const char* value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void NotifyUpdateProperty::set_guildname(const char* value, size_t size) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyUpdateProperty::mutable_guildname() {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  return guildname_;
}
inline ::std::string* NotifyUpdateProperty::release_guildname() {
  clear_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guildname_;
    guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyUpdateProperty::set_allocated_guildname(::std::string* guildname) {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    delete guildname_;
  }
  if (guildname) {
    set_has_guildname();
    guildname_ = guildname;
  } else {
    clear_has_guildname();
    guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 guild_credits = 31;
inline bool NotifyUpdateProperty::has_guild_credits() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NotifyUpdateProperty::set_has_guild_credits() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NotifyUpdateProperty::clear_has_guild_credits() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NotifyUpdateProperty::clear_guild_credits() {
  guild_credits_ = 0;
  clear_has_guild_credits();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::guild_credits() const {
  return guild_credits_;
}
inline void NotifyUpdateProperty::set_guild_credits(::google::protobuf::int32 value) {
  set_has_guild_credits();
  guild_credits_ = value;
}

// optional uint64 total_gold = 32;
inline bool NotifyUpdateProperty::has_total_gold() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NotifyUpdateProperty::set_has_total_gold() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NotifyUpdateProperty::clear_has_total_gold() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NotifyUpdateProperty::clear_total_gold() {
  total_gold_ = GOOGLE_ULONGLONG(0);
  clear_has_total_gold();
}
inline ::google::protobuf::uint64 NotifyUpdateProperty::total_gold() const {
  return total_gold_;
}
inline void NotifyUpdateProperty::set_total_gold(::google::protobuf::uint64 value) {
  set_has_total_gold();
  total_gold_ = value;
}

// optional int32 total_guild_credits = 33;
inline bool NotifyUpdateProperty::has_total_guild_credits() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void NotifyUpdateProperty::set_has_total_guild_credits() {
  _has_bits_[0] |= 0x40000000u;
}
inline void NotifyUpdateProperty::clear_has_total_guild_credits() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void NotifyUpdateProperty::clear_total_guild_credits() {
  total_guild_credits_ = 0;
  clear_has_total_guild_credits();
}
inline ::google::protobuf::int32 NotifyUpdateProperty::total_guild_credits() const {
  return total_guild_credits_;
}
inline void NotifyUpdateProperty::set_total_guild_credits(::google::protobuf::int32 value) {
  set_has_total_guild_credits();
  total_guild_credits_ = value;
}

// -------------------------------------------------------------------

// RequestUseLvupPoint

// optional uint32 inc_str = 1;
inline bool RequestUseLvupPoint::has_inc_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUseLvupPoint::set_has_inc_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUseLvupPoint::clear_has_inc_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUseLvupPoint::clear_inc_str() {
  inc_str_ = 0u;
  clear_has_inc_str();
}
inline ::google::protobuf::uint32 RequestUseLvupPoint::inc_str() const {
  return inc_str_;
}
inline void RequestUseLvupPoint::set_inc_str(::google::protobuf::uint32 value) {
  set_has_inc_str();
  inc_str_ = value;
}

// optional uint32 inc_dex = 2;
inline bool RequestUseLvupPoint::has_inc_dex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUseLvupPoint::set_has_inc_dex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUseLvupPoint::clear_has_inc_dex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUseLvupPoint::clear_inc_dex() {
  inc_dex_ = 0u;
  clear_has_inc_dex();
}
inline ::google::protobuf::uint32 RequestUseLvupPoint::inc_dex() const {
  return inc_dex_;
}
inline void RequestUseLvupPoint::set_inc_dex(::google::protobuf::uint32 value) {
  set_has_inc_dex();
  inc_dex_ = value;
}

// optional uint32 inc_intgent = 3;
inline bool RequestUseLvupPoint::has_inc_intgent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUseLvupPoint::set_has_inc_intgent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUseLvupPoint::clear_has_inc_intgent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUseLvupPoint::clear_inc_intgent() {
  inc_intgent_ = 0u;
  clear_has_inc_intgent();
}
inline ::google::protobuf::uint32 RequestUseLvupPoint::inc_intgent() const {
  return inc_intgent_;
}
inline void RequestUseLvupPoint::set_inc_intgent(::google::protobuf::uint32 value) {
  set_has_inc_intgent();
  inc_intgent_ = value;
}

// optional uint32 inc_con = 4;
inline bool RequestUseLvupPoint::has_inc_con() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestUseLvupPoint::set_has_inc_con() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestUseLvupPoint::clear_has_inc_con() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestUseLvupPoint::clear_inc_con() {
  inc_con_ = 0u;
  clear_has_inc_con();
}
inline ::google::protobuf::uint32 RequestUseLvupPoint::inc_con() const {
  return inc_con_;
}
inline void RequestUseLvupPoint::set_inc_con(::google::protobuf::uint32 value) {
  set_has_inc_con();
  inc_con_ = value;
}

// optional uint32 inc_wiz = 5;
inline bool RequestUseLvupPoint::has_inc_wiz() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestUseLvupPoint::set_has_inc_wiz() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestUseLvupPoint::clear_has_inc_wiz() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestUseLvupPoint::clear_inc_wiz() {
  inc_wiz_ = 0u;
  clear_has_inc_wiz();
}
inline ::google::protobuf::uint32 RequestUseLvupPoint::inc_wiz() const {
  return inc_wiz_;
}
inline void RequestUseLvupPoint::set_inc_wiz(::google::protobuf::uint32 value) {
  set_has_inc_wiz();
  inc_wiz_ = value;
}

// -------------------------------------------------------------------

// ResponseUseLvupPoint

// optional uint32 result = 1;
inline bool ResponseUseLvupPoint::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUseLvupPoint::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUseLvupPoint::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUseLvupPoint::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 ResponseUseLvupPoint::result() const {
  return result_;
}
inline void ResponseUseLvupPoint::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestRecharge

// optional uint32 reserve = 1;
inline bool RequestRecharge::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRecharge::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRecharge::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRecharge::clear_reserve() {
  reserve_ = 0u;
  clear_has_reserve();
}
inline ::google::protobuf::uint32 RequestRecharge::reserve() const {
  return reserve_;
}
inline void RequestRecharge::set_reserve(::google::protobuf::uint32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// RequestSetShortcutKey

// optional .ShortcutKeyData data = 1;
inline bool RequestSetShortcutKey::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSetShortcutKey::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSetShortcutKey::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSetShortcutKey::clear_data() {
  if (data_ != NULL) data_->::ShortcutKeyData::Clear();
  clear_has_data();
}
inline const ::ShortcutKeyData& RequestSetShortcutKey::data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_ != NULL ? *data_ : *default_instance().data_;
#else
  return data_ != NULL ? *data_ : *default_instance_->data_;
#endif
}
inline ::ShortcutKeyData* RequestSetShortcutKey::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::ShortcutKeyData;
  return data_;
}
inline ::ShortcutKeyData* RequestSetShortcutKey::release_data() {
  clear_has_data();
  ::ShortcutKeyData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void RequestSetShortcutKey::set_allocated_data(::ShortcutKeyData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// -------------------------------------------------------------------

// RequestLookCharEquip

// optional string name = 1;
inline bool RequestLookCharEquip::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLookCharEquip::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLookCharEquip::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLookCharEquip::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RequestLookCharEquip::name() const {
  return *name_;
}
inline void RequestLookCharEquip::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestLookCharEquip::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestLookCharEquip::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestLookCharEquip::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RequestLookCharEquip::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestLookCharEquip::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResponseLookCharEquip

// optional string name = 1;
inline bool ResponseLookCharEquip::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseLookCharEquip::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseLookCharEquip::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseLookCharEquip::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ResponseLookCharEquip::name() const {
  return *name_;
}
inline void ResponseLookCharEquip::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ResponseLookCharEquip::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ResponseLookCharEquip::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseLookCharEquip::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ResponseLookCharEquip::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseLookCharEquip::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 level = 2;
inline bool ResponseLookCharEquip::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseLookCharEquip::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseLookCharEquip::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseLookCharEquip::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ResponseLookCharEquip::level() const {
  return level_;
}
inline void ResponseLookCharEquip::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional int32 race = 3;
inline bool ResponseLookCharEquip::has_race() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseLookCharEquip::set_has_race() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseLookCharEquip::clear_has_race() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseLookCharEquip::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::google::protobuf::int32 ResponseLookCharEquip::race() const {
  return race_;
}
inline void ResponseLookCharEquip::set_race(::google::protobuf::int32 value) {
  set_has_race();
  race_ = value;
}

// optional string guild_name = 4;
inline bool ResponseLookCharEquip::has_guild_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseLookCharEquip::set_has_guild_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseLookCharEquip::clear_has_guild_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseLookCharEquip::clear_guild_name() {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    guild_name_->clear();
  }
  clear_has_guild_name();
}
inline const ::std::string& ResponseLookCharEquip::guild_name() const {
  return *guild_name_;
}
inline void ResponseLookCharEquip::set_guild_name(const ::std::string& value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ResponseLookCharEquip::set_guild_name(const char* value) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(value);
}
inline void ResponseLookCharEquip::set_guild_name(const char* value, size_t size) {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  guild_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseLookCharEquip::mutable_guild_name() {
  set_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    guild_name_ = new ::std::string;
  }
  return guild_name_;
}
inline ::std::string* ResponseLookCharEquip::release_guild_name() {
  clear_has_guild_name();
  if (guild_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guild_name_;
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseLookCharEquip::set_allocated_guild_name(::std::string* guild_name) {
  if (guild_name_ != &::google::protobuf::internal::kEmptyString) {
    delete guild_name_;
  }
  if (guild_name) {
    set_has_guild_name();
    guild_name_ = guild_name;
  } else {
    clear_has_guild_name();
    guild_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ItemData equip_items = 10;
inline int ResponseLookCharEquip::equip_items_size() const {
  return equip_items_.size();
}
inline void ResponseLookCharEquip::clear_equip_items() {
  equip_items_.Clear();
}
inline const ::ItemData& ResponseLookCharEquip::equip_items(int index) const {
  return equip_items_.Get(index);
}
inline ::ItemData* ResponseLookCharEquip::mutable_equip_items(int index) {
  return equip_items_.Mutable(index);
}
inline ::ItemData* ResponseLookCharEquip::add_equip_items() {
  return equip_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
ResponseLookCharEquip::equip_items() const {
  return equip_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
ResponseLookCharEquip::mutable_equip_items() {
  return &equip_items_;
}

// repeated .ItemData avatar_items = 11;
inline int ResponseLookCharEquip::avatar_items_size() const {
  return avatar_items_.size();
}
inline void ResponseLookCharEquip::clear_avatar_items() {
  avatar_items_.Clear();
}
inline const ::ItemData& ResponseLookCharEquip::avatar_items(int index) const {
  return avatar_items_.Get(index);
}
inline ::ItemData* ResponseLookCharEquip::mutable_avatar_items(int index) {
  return avatar_items_.Mutable(index);
}
inline ::ItemData* ResponseLookCharEquip::add_avatar_items() {
  return avatar_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
ResponseLookCharEquip::avatar_items() const {
  return avatar_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
ResponseLookCharEquip::mutable_avatar_items() {
  return &avatar_items_;
}

// -------------------------------------------------------------------

// RequestTakeVipAward

// optional uint32 vip_award_id = 1;
inline bool RequestTakeVipAward::has_vip_award_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTakeVipAward::set_has_vip_award_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTakeVipAward::clear_has_vip_award_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTakeVipAward::clear_vip_award_id() {
  vip_award_id_ = 0u;
  clear_has_vip_award_id();
}
inline ::google::protobuf::uint32 RequestTakeVipAward::vip_award_id() const {
  return vip_award_id_;
}
inline void RequestTakeVipAward::set_vip_award_id(::google::protobuf::uint32 value) {
  set_has_vip_award_id();
  vip_award_id_ = value;
}

// -------------------------------------------------------------------

// ResponseTakeVipAward

// optional int32 vip_award_id = 1;
inline bool ResponseTakeVipAward::has_vip_award_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTakeVipAward::set_has_vip_award_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTakeVipAward::clear_has_vip_award_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTakeVipAward::clear_vip_award_id() {
  vip_award_id_ = 0;
  clear_has_vip_award_id();
}
inline ::google::protobuf::int32 ResponseTakeVipAward::vip_award_id() const {
  return vip_award_id_;
}
inline void ResponseTakeVipAward::set_vip_award_id(::google::protobuf::int32 value) {
  set_has_vip_award_id();
  vip_award_id_ = value;
}

// -------------------------------------------------------------------

// RequestSaveSetting

// optional .SettingData setting_data = 1;
inline bool RequestSaveSetting::has_setting_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSaveSetting::set_has_setting_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSaveSetting::clear_has_setting_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSaveSetting::clear_setting_data() {
  if (setting_data_ != NULL) setting_data_->::SettingData::Clear();
  clear_has_setting_data();
}
inline const ::SettingData& RequestSaveSetting::setting_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return setting_data_ != NULL ? *setting_data_ : *default_instance().setting_data_;
#else
  return setting_data_ != NULL ? *setting_data_ : *default_instance_->setting_data_;
#endif
}
inline ::SettingData* RequestSaveSetting::mutable_setting_data() {
  set_has_setting_data();
  if (setting_data_ == NULL) setting_data_ = new ::SettingData;
  return setting_data_;
}
inline ::SettingData* RequestSaveSetting::release_setting_data() {
  clear_has_setting_data();
  ::SettingData* temp = setting_data_;
  setting_data_ = NULL;
  return temp;
}
inline void RequestSaveSetting::set_allocated_setting_data(::SettingData* setting_data) {
  delete setting_data_;
  setting_data_ = setting_data;
  if (setting_data) {
    set_has_setting_data();
  } else {
    clear_has_setting_data();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoCharData_2eproto__INCLUDED
