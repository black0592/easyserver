// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoMail.proto

#ifndef PROTOBUF_ProtoMail_2eproto__INCLUDED
#define PROTOBUF_ProtoMail_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoMail_2eproto();
void protobuf_AssignDesc_ProtoMail_2eproto();
void protobuf_ShutdownFile_ProtoMail_2eproto();

class MailItem;
class MailInfo;
class RequestGetMail;
class ResponseGetMail;
class RequestReadMail;
class ResponseReadMail;
class RequestTakeOutAttachment;
class ResponseTakeOutAttachment;
class RequestWriteMail;
class ResponseWriteMail;
class RequestDeleteMail;
class ResponseDeleteMail;

enum MailOpCode {
  OP_GET_MAILS = 1,
  OP_READ_MAIL = 2,
  OP_TAKEOUT_ATTACHMENT = 3,
  OP_WRITE_MAIL = 4,
  OP_DELETE_MAIL = 5
};
bool MailOpCode_IsValid(int value);
const MailOpCode MailOpCode_MIN = OP_GET_MAILS;
const MailOpCode MailOpCode_MAX = OP_DELETE_MAIL;
const int MailOpCode_ARRAYSIZE = MailOpCode_MAX + 1;

enum MailFlag {
  MAILFLAG_NEW = 0,
  MAILFLAG_READ = 1,
  MAILFLAG_TAKEN = 2
};
bool MailFlag_IsValid(int value);
const MailFlag MailFlag_MIN = MAILFLAG_NEW;
const MailFlag MailFlag_MAX = MAILFLAG_TAKEN;
const int MailFlag_ARRAYSIZE = MailFlag_MAX + 1;

// ===================================================================

class MailItem : public ::google::protobuf::MessageLite {
 public:
  MailItem();
  virtual ~MailItem();

  MailItem(const MailItem& from);

  inline MailItem& operator=(const MailItem& from) {
    CopyFrom(from);
    return *this;
  }

  static const MailItem& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MailItem* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MailItem* other);

  // implements Message ----------------------------------------------

  MailItem* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MailItem& from);
  void MergeFrom(const MailItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ItemData item_list = 1;
  inline int item_list_size() const;
  inline void clear_item_list();
  static const int kItemListFieldNumber = 1;
  inline const ::ItemData& item_list(int index) const;
  inline ::ItemData* mutable_item_list(int index);
  inline ::ItemData* add_item_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
      item_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
      mutable_item_list();

  // @@protoc_insertion_point(class_scope:Protocol.MailItem)
 private:

  ::google::protobuf::RepeatedPtrField< ::ItemData > item_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static MailItem* default_instance_;
};
// -------------------------------------------------------------------

class MailInfo : public ::google::protobuf::MessageLite {
 public:
  MailInfo();
  virtual ~MailInfo();

  MailInfo(const MailInfo& from);

  inline MailInfo& operator=(const MailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MailInfo* other);

  // implements Message ----------------------------------------------

  MailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MailInfo& from);
  void MergeFrom(const MailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional .Protocol.MailFlag flag = 2;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 2;
  inline ::Protocol::MailFlag flag() const;
  inline void set_flag(::Protocol::MailFlag value);

  // optional int32 system = 3;
  inline bool has_system() const;
  inline void clear_system();
  static const int kSystemFieldNumber = 3;
  inline ::google::protobuf::int32 system() const;
  inline void set_system(::google::protobuf::int32 value);

  // optional string sender = 4;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 4;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // optional string receiver = 5;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 5;
  inline const ::std::string& receiver() const;
  inline void set_receiver(const ::std::string& value);
  inline void set_receiver(const char* value);
  inline void set_receiver(const char* value, size_t size);
  inline ::std::string* mutable_receiver();
  inline ::std::string* release_receiver();
  inline void set_allocated_receiver(::std::string* receiver);

  // optional string title = 6;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 6;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string content = 7;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 7;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional uint64 money = 8;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 8;
  inline ::google::protobuf::uint64 money() const;
  inline void set_money(::google::protobuf::uint64 value);

  // optional uint64 gold = 9;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 9;
  inline ::google::protobuf::uint64 gold() const;
  inline void set_gold(::google::protobuf::uint64 value);

  // optional uint64 bindgold = 10;
  inline bool has_bindgold() const;
  inline void clear_bindgold();
  static const int kBindgoldFieldNumber = 10;
  inline ::google::protobuf::uint64 bindgold() const;
  inline void set_bindgold(::google::protobuf::uint64 value);

  // optional uint64 exp = 11;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 11;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // optional uint32 sendtime = 12;
  inline bool has_sendtime() const;
  inline void clear_sendtime();
  static const int kSendtimeFieldNumber = 12;
  inline ::google::protobuf::uint32 sendtime() const;
  inline void set_sendtime(::google::protobuf::uint32 value);

  // optional uint32 expiredtime = 13;
  inline bool has_expiredtime() const;
  inline void clear_expiredtime();
  static const int kExpiredtimeFieldNumber = 13;
  inline ::google::protobuf::uint32 expiredtime() const;
  inline void set_expiredtime(::google::protobuf::uint32 value);

  // optional bool have_attachment = 14;
  inline bool has_have_attachment() const;
  inline void clear_have_attachment();
  static const int kHaveAttachmentFieldNumber = 14;
  inline bool have_attachment() const;
  inline void set_have_attachment(bool value);

  // optional .Protocol.MailItem mail_item = 15;
  inline bool has_mail_item() const;
  inline void clear_mail_item();
  static const int kMailItemFieldNumber = 15;
  inline const ::Protocol::MailItem& mail_item() const;
  inline ::Protocol::MailItem* mutable_mail_item();
  inline ::Protocol::MailItem* release_mail_item();
  inline void set_allocated_mail_item(::Protocol::MailItem* mail_item);

  // @@protoc_insertion_point(class_scope:Protocol.MailInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_flag();
  inline void clear_has_flag();
  inline void set_has_system();
  inline void clear_has_system();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_receiver();
  inline void clear_has_receiver();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_bindgold();
  inline void clear_has_bindgold();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_sendtime();
  inline void clear_has_sendtime();
  inline void set_has_expiredtime();
  inline void clear_has_expiredtime();
  inline void set_has_have_attachment();
  inline void clear_has_have_attachment();
  inline void set_has_mail_item();
  inline void clear_has_mail_item();

  ::google::protobuf::int32 id_;
  int flag_;
  ::std::string* sender_;
  ::std::string* receiver_;
  ::std::string* title_;
  ::std::string* content_;
  ::google::protobuf::int32 system_;
  ::google::protobuf::uint32 sendtime_;
  ::google::protobuf::uint64 money_;
  ::google::protobuf::uint64 gold_;
  ::google::protobuf::uint64 bindgold_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint32 expiredtime_;
  bool have_attachment_;
  ::Protocol::MailItem* mail_item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static MailInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetMail : public ::google::protobuf::MessageLite {
 public:
  RequestGetMail();
  virtual ~RequestGetMail();

  RequestGetMail(const RequestGetMail& from);

  inline RequestGetMail& operator=(const RequestGetMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetMail* other);

  // implements Message ----------------------------------------------

  RequestGetMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetMail& from);
  void MergeFrom(const RequestGetMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 reserve = 1;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 1;
  inline ::google::protobuf::int32 reserve() const;
  inline void set_reserve(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetMail)
 private:
  inline void set_has_reserve();
  inline void clear_has_reserve();

  ::google::protobuf::int32 reserve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static RequestGetMail* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetMail : public ::google::protobuf::MessageLite {
 public:
  ResponseGetMail();
  virtual ~ResponseGetMail();

  ResponseGetMail(const ResponseGetMail& from);

  inline ResponseGetMail& operator=(const ResponseGetMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetMail* other);

  // implements Message ----------------------------------------------

  ResponseGetMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetMail& from);
  void MergeFrom(const ResponseGetMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Protocol.MailInfo mail_list = 1;
  inline int mail_list_size() const;
  inline void clear_mail_list();
  static const int kMailListFieldNumber = 1;
  inline const ::Protocol::MailInfo& mail_list(int index) const;
  inline ::Protocol::MailInfo* mutable_mail_list(int index);
  inline ::Protocol::MailInfo* add_mail_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::MailInfo >&
      mail_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::MailInfo >*
      mutable_mail_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetMail)
 private:

  ::google::protobuf::RepeatedPtrField< ::Protocol::MailInfo > mail_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetMail* default_instance_;
};
// -------------------------------------------------------------------

class RequestReadMail : public ::google::protobuf::MessageLite {
 public:
  RequestReadMail();
  virtual ~RequestReadMail();

  RequestReadMail(const RequestReadMail& from);

  inline RequestReadMail& operator=(const RequestReadMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestReadMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestReadMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestReadMail* other);

  // implements Message ----------------------------------------------

  RequestReadMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestReadMail& from);
  void MergeFrom(const RequestReadMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestReadMail)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static RequestReadMail* default_instance_;
};
// -------------------------------------------------------------------

class ResponseReadMail : public ::google::protobuf::MessageLite {
 public:
  ResponseReadMail();
  virtual ~ResponseReadMail();

  ResponseReadMail(const ResponseReadMail& from);

  inline ResponseReadMail& operator=(const ResponseReadMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseReadMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseReadMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseReadMail* other);

  // implements Message ----------------------------------------------

  ResponseReadMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseReadMail& from);
  void MergeFrom(const ResponseReadMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.MailInfo mail = 1;
  inline bool has_mail() const;
  inline void clear_mail();
  static const int kMailFieldNumber = 1;
  inline const ::Protocol::MailInfo& mail() const;
  inline ::Protocol::MailInfo* mutable_mail();
  inline ::Protocol::MailInfo* release_mail();
  inline void set_allocated_mail(::Protocol::MailInfo* mail);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseReadMail)
 private:
  inline void set_has_mail();
  inline void clear_has_mail();

  ::Protocol::MailInfo* mail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static ResponseReadMail* default_instance_;
};
// -------------------------------------------------------------------

class RequestTakeOutAttachment : public ::google::protobuf::MessageLite {
 public:
  RequestTakeOutAttachment();
  virtual ~RequestTakeOutAttachment();

  RequestTakeOutAttachment(const RequestTakeOutAttachment& from);

  inline RequestTakeOutAttachment& operator=(const RequestTakeOutAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestTakeOutAttachment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestTakeOutAttachment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestTakeOutAttachment* other);

  // implements Message ----------------------------------------------

  RequestTakeOutAttachment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestTakeOutAttachment& from);
  void MergeFrom(const RequestTakeOutAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:Protocol.RequestTakeOutAttachment)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static RequestTakeOutAttachment* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTakeOutAttachment : public ::google::protobuf::MessageLite {
 public:
  ResponseTakeOutAttachment();
  virtual ~ResponseTakeOutAttachment();

  ResponseTakeOutAttachment(const ResponseTakeOutAttachment& from);

  inline ResponseTakeOutAttachment& operator=(const ResponseTakeOutAttachment& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseTakeOutAttachment& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseTakeOutAttachment* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseTakeOutAttachment* other);

  // implements Message ----------------------------------------------

  ResponseTakeOutAttachment* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseTakeOutAttachment& from);
  void MergeFrom(const ResponseTakeOutAttachment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseTakeOutAttachment)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static ResponseTakeOutAttachment* default_instance_;
};
// -------------------------------------------------------------------

class RequestWriteMail : public ::google::protobuf::MessageLite {
 public:
  RequestWriteMail();
  virtual ~RequestWriteMail();

  RequestWriteMail(const RequestWriteMail& from);

  inline RequestWriteMail& operator=(const RequestWriteMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestWriteMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestWriteMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestWriteMail* other);

  // implements Message ----------------------------------------------

  RequestWriteMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestWriteMail& from);
  void MergeFrom(const RequestWriteMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.MailInfo mail = 1;
  inline bool has_mail() const;
  inline void clear_mail();
  static const int kMailFieldNumber = 1;
  inline const ::Protocol::MailInfo& mail() const;
  inline ::Protocol::MailInfo* mutable_mail();
  inline ::Protocol::MailInfo* release_mail();
  inline void set_allocated_mail(::Protocol::MailInfo* mail);

  // repeated .ItemLocNum loc_list = 2;
  inline int loc_list_size() const;
  inline void clear_loc_list();
  static const int kLocListFieldNumber = 2;
  inline const ::ItemLocNum& loc_list(int index) const;
  inline ::ItemLocNum* mutable_loc_list(int index);
  inline ::ItemLocNum* add_loc_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ItemLocNum >&
      loc_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ItemLocNum >*
      mutable_loc_list();

  // @@protoc_insertion_point(class_scope:Protocol.RequestWriteMail)
 private:
  inline void set_has_mail();
  inline void clear_has_mail();

  ::Protocol::MailInfo* mail_;
  ::google::protobuf::RepeatedPtrField< ::ItemLocNum > loc_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static RequestWriteMail* default_instance_;
};
// -------------------------------------------------------------------

class ResponseWriteMail : public ::google::protobuf::MessageLite {
 public:
  ResponseWriteMail();
  virtual ~ResponseWriteMail();

  ResponseWriteMail(const ResponseWriteMail& from);

  inline ResponseWriteMail& operator=(const ResponseWriteMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseWriteMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseWriteMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseWriteMail* other);

  // implements Message ----------------------------------------------

  ResponseWriteMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseWriteMail& from);
  void MergeFrom(const ResponseWriteMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseWriteMail)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static ResponseWriteMail* default_instance_;
};
// -------------------------------------------------------------------

class RequestDeleteMail : public ::google::protobuf::MessageLite {
 public:
  RequestDeleteMail();
  virtual ~RequestDeleteMail();

  RequestDeleteMail(const RequestDeleteMail& from);

  inline RequestDeleteMail& operator=(const RequestDeleteMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestDeleteMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestDeleteMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestDeleteMail* other);

  // implements Message ----------------------------------------------

  RequestDeleteMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestDeleteMail& from);
  void MergeFrom(const RequestDeleteMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:Protocol.RequestDeleteMail)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static RequestDeleteMail* default_instance_;
};
// -------------------------------------------------------------------

class ResponseDeleteMail : public ::google::protobuf::MessageLite {
 public:
  ResponseDeleteMail();
  virtual ~ResponseDeleteMail();

  ResponseDeleteMail(const ResponseDeleteMail& from);

  inline ResponseDeleteMail& operator=(const ResponseDeleteMail& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseDeleteMail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseDeleteMail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseDeleteMail* other);

  // implements Message ----------------------------------------------

  ResponseDeleteMail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseDeleteMail& from);
  void MergeFrom(const ResponseDeleteMail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 id_list = 1;
  inline int id_list_size() const;
  inline void clear_id_list();
  static const int kIdListFieldNumber = 1;
  inline ::google::protobuf::int32 id_list(int index) const;
  inline void set_id_list(int index, ::google::protobuf::int32 value);
  inline void add_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id_list();

  // @@protoc_insertion_point(class_scope:Protocol.ResponseDeleteMail)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoMail_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoMail_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoMail_2eproto();
  friend void protobuf_ShutdownFile_ProtoMail_2eproto();

  void InitAsDefaultInstance();
  static ResponseDeleteMail* default_instance_;
};
// ===================================================================


// ===================================================================

// MailItem

// repeated .ItemData item_list = 1;
inline int MailItem::item_list_size() const {
  return item_list_.size();
}
inline void MailItem::clear_item_list() {
  item_list_.Clear();
}
inline const ::ItemData& MailItem::item_list(int index) const {
  return item_list_.Get(index);
}
inline ::ItemData* MailItem::mutable_item_list(int index) {
  return item_list_.Mutable(index);
}
inline ::ItemData* MailItem::add_item_list() {
  return item_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemData >&
MailItem::item_list() const {
  return item_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemData >*
MailItem::mutable_item_list() {
  return &item_list_;
}

// -------------------------------------------------------------------

// MailInfo

// optional int32 id = 1;
inline bool MailInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MailInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MailInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MailInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MailInfo::id() const {
  return id_;
}
inline void MailInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional .Protocol.MailFlag flag = 2;
inline bool MailInfo::has_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MailInfo::set_has_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MailInfo::clear_has_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MailInfo::clear_flag() {
  flag_ = 0;
  clear_has_flag();
}
inline ::Protocol::MailFlag MailInfo::flag() const {
  return static_cast< ::Protocol::MailFlag >(flag_);
}
inline void MailInfo::set_flag(::Protocol::MailFlag value) {
  assert(::Protocol::MailFlag_IsValid(value));
  set_has_flag();
  flag_ = value;
}

// optional int32 system = 3;
inline bool MailInfo::has_system() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MailInfo::set_has_system() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MailInfo::clear_has_system() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MailInfo::clear_system() {
  system_ = 0;
  clear_has_system();
}
inline ::google::protobuf::int32 MailInfo::system() const {
  return system_;
}
inline void MailInfo::set_system(::google::protobuf::int32 value) {
  set_has_system();
  system_ = value;
}

// optional string sender = 4;
inline bool MailInfo::has_sender() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MailInfo::set_has_sender() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MailInfo::clear_has_sender() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MailInfo::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& MailInfo::sender() const {
  return *sender_;
}
inline void MailInfo::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void MailInfo::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void MailInfo::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MailInfo::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* MailInfo::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MailInfo::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string receiver = 5;
inline bool MailInfo::has_receiver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MailInfo::set_has_receiver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MailInfo::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MailInfo::clear_receiver() {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    receiver_->clear();
  }
  clear_has_receiver();
}
inline const ::std::string& MailInfo::receiver() const {
  return *receiver_;
}
inline void MailInfo::set_receiver(const ::std::string& value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void MailInfo::set_receiver(const char* value) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(value);
}
inline void MailInfo::set_receiver(const char* value, size_t size) {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  receiver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MailInfo::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    receiver_ = new ::std::string;
  }
  return receiver_;
}
inline ::std::string* MailInfo::release_receiver() {
  clear_has_receiver();
  if (receiver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiver_;
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MailInfo::set_allocated_receiver(::std::string* receiver) {
  if (receiver_ != &::google::protobuf::internal::kEmptyString) {
    delete receiver_;
  }
  if (receiver) {
    set_has_receiver();
    receiver_ = receiver;
  } else {
    clear_has_receiver();
    receiver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string title = 6;
inline bool MailInfo::has_title() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MailInfo::set_has_title() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MailInfo::clear_has_title() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MailInfo::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& MailInfo::title() const {
  return *title_;
}
inline void MailInfo::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MailInfo::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MailInfo::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MailInfo::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* MailInfo::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MailInfo::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 7;
inline bool MailInfo::has_content() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MailInfo::set_has_content() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MailInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MailInfo::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& MailInfo::content() const {
  return *content_;
}
inline void MailInfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MailInfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MailInfo::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MailInfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* MailInfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MailInfo::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 money = 8;
inline bool MailInfo::has_money() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MailInfo::set_has_money() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MailInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MailInfo::clear_money() {
  money_ = GOOGLE_ULONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::uint64 MailInfo::money() const {
  return money_;
}
inline void MailInfo::set_money(::google::protobuf::uint64 value) {
  set_has_money();
  money_ = value;
}

// optional uint64 gold = 9;
inline bool MailInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MailInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MailInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MailInfo::clear_gold() {
  gold_ = GOOGLE_ULONGLONG(0);
  clear_has_gold();
}
inline ::google::protobuf::uint64 MailInfo::gold() const {
  return gold_;
}
inline void MailInfo::set_gold(::google::protobuf::uint64 value) {
  set_has_gold();
  gold_ = value;
}

// optional uint64 bindgold = 10;
inline bool MailInfo::has_bindgold() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MailInfo::set_has_bindgold() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MailInfo::clear_has_bindgold() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MailInfo::clear_bindgold() {
  bindgold_ = GOOGLE_ULONGLONG(0);
  clear_has_bindgold();
}
inline ::google::protobuf::uint64 MailInfo::bindgold() const {
  return bindgold_;
}
inline void MailInfo::set_bindgold(::google::protobuf::uint64 value) {
  set_has_bindgold();
  bindgold_ = value;
}

// optional uint64 exp = 11;
inline bool MailInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MailInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MailInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MailInfo::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 MailInfo::exp() const {
  return exp_;
}
inline void MailInfo::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// optional uint32 sendtime = 12;
inline bool MailInfo::has_sendtime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MailInfo::set_has_sendtime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MailInfo::clear_has_sendtime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MailInfo::clear_sendtime() {
  sendtime_ = 0u;
  clear_has_sendtime();
}
inline ::google::protobuf::uint32 MailInfo::sendtime() const {
  return sendtime_;
}
inline void MailInfo::set_sendtime(::google::protobuf::uint32 value) {
  set_has_sendtime();
  sendtime_ = value;
}

// optional uint32 expiredtime = 13;
inline bool MailInfo::has_expiredtime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MailInfo::set_has_expiredtime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MailInfo::clear_has_expiredtime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MailInfo::clear_expiredtime() {
  expiredtime_ = 0u;
  clear_has_expiredtime();
}
inline ::google::protobuf::uint32 MailInfo::expiredtime() const {
  return expiredtime_;
}
inline void MailInfo::set_expiredtime(::google::protobuf::uint32 value) {
  set_has_expiredtime();
  expiredtime_ = value;
}

// optional bool have_attachment = 14;
inline bool MailInfo::has_have_attachment() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MailInfo::set_has_have_attachment() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MailInfo::clear_has_have_attachment() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MailInfo::clear_have_attachment() {
  have_attachment_ = false;
  clear_has_have_attachment();
}
inline bool MailInfo::have_attachment() const {
  return have_attachment_;
}
inline void MailInfo::set_have_attachment(bool value) {
  set_has_have_attachment();
  have_attachment_ = value;
}

// optional .Protocol.MailItem mail_item = 15;
inline bool MailInfo::has_mail_item() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MailInfo::set_has_mail_item() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MailInfo::clear_has_mail_item() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MailInfo::clear_mail_item() {
  if (mail_item_ != NULL) mail_item_->::Protocol::MailItem::Clear();
  clear_has_mail_item();
}
inline const ::Protocol::MailItem& MailInfo::mail_item() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mail_item_ != NULL ? *mail_item_ : *default_instance().mail_item_;
#else
  return mail_item_ != NULL ? *mail_item_ : *default_instance_->mail_item_;
#endif
}
inline ::Protocol::MailItem* MailInfo::mutable_mail_item() {
  set_has_mail_item();
  if (mail_item_ == NULL) mail_item_ = new ::Protocol::MailItem;
  return mail_item_;
}
inline ::Protocol::MailItem* MailInfo::release_mail_item() {
  clear_has_mail_item();
  ::Protocol::MailItem* temp = mail_item_;
  mail_item_ = NULL;
  return temp;
}
inline void MailInfo::set_allocated_mail_item(::Protocol::MailItem* mail_item) {
  delete mail_item_;
  mail_item_ = mail_item;
  if (mail_item) {
    set_has_mail_item();
  } else {
    clear_has_mail_item();
  }
}

// -------------------------------------------------------------------

// RequestGetMail

// optional int32 reserve = 1;
inline bool RequestGetMail::has_reserve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetMail::set_has_reserve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetMail::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetMail::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline ::google::protobuf::int32 RequestGetMail::reserve() const {
  return reserve_;
}
inline void RequestGetMail::set_reserve(::google::protobuf::int32 value) {
  set_has_reserve();
  reserve_ = value;
}

// -------------------------------------------------------------------

// ResponseGetMail

// repeated .Protocol.MailInfo mail_list = 1;
inline int ResponseGetMail::mail_list_size() const {
  return mail_list_.size();
}
inline void ResponseGetMail::clear_mail_list() {
  mail_list_.Clear();
}
inline const ::Protocol::MailInfo& ResponseGetMail::mail_list(int index) const {
  return mail_list_.Get(index);
}
inline ::Protocol::MailInfo* ResponseGetMail::mutable_mail_list(int index) {
  return mail_list_.Mutable(index);
}
inline ::Protocol::MailInfo* ResponseGetMail::add_mail_list() {
  return mail_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::MailInfo >&
ResponseGetMail::mail_list() const {
  return mail_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::MailInfo >*
ResponseGetMail::mutable_mail_list() {
  return &mail_list_;
}

// -------------------------------------------------------------------

// RequestReadMail

// optional int32 id = 1;
inline bool RequestReadMail::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestReadMail::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestReadMail::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestReadMail::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestReadMail::id() const {
  return id_;
}
inline void RequestReadMail::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ResponseReadMail

// optional .Protocol.MailInfo mail = 1;
inline bool ResponseReadMail::has_mail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseReadMail::set_has_mail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseReadMail::clear_has_mail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseReadMail::clear_mail() {
  if (mail_ != NULL) mail_->::Protocol::MailInfo::Clear();
  clear_has_mail();
}
inline const ::Protocol::MailInfo& ResponseReadMail::mail() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mail_ != NULL ? *mail_ : *default_instance().mail_;
#else
  return mail_ != NULL ? *mail_ : *default_instance_->mail_;
#endif
}
inline ::Protocol::MailInfo* ResponseReadMail::mutable_mail() {
  set_has_mail();
  if (mail_ == NULL) mail_ = new ::Protocol::MailInfo;
  return mail_;
}
inline ::Protocol::MailInfo* ResponseReadMail::release_mail() {
  clear_has_mail();
  ::Protocol::MailInfo* temp = mail_;
  mail_ = NULL;
  return temp;
}
inline void ResponseReadMail::set_allocated_mail(::Protocol::MailInfo* mail) {
  delete mail_;
  mail_ = mail;
  if (mail) {
    set_has_mail();
  } else {
    clear_has_mail();
  }
}

// -------------------------------------------------------------------

// RequestTakeOutAttachment

// repeated int32 id_list = 1;
inline int RequestTakeOutAttachment::id_list_size() const {
  return id_list_.size();
}
inline void RequestTakeOutAttachment::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 RequestTakeOutAttachment::id_list(int index) const {
  return id_list_.Get(index);
}
inline void RequestTakeOutAttachment::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void RequestTakeOutAttachment::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestTakeOutAttachment::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestTakeOutAttachment::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// ResponseTakeOutAttachment

// repeated int32 id_list = 1;
inline int ResponseTakeOutAttachment::id_list_size() const {
  return id_list_.size();
}
inline void ResponseTakeOutAttachment::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 ResponseTakeOutAttachment::id_list(int index) const {
  return id_list_.Get(index);
}
inline void ResponseTakeOutAttachment::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void ResponseTakeOutAttachment::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ResponseTakeOutAttachment::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ResponseTakeOutAttachment::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// RequestWriteMail

// optional .Protocol.MailInfo mail = 1;
inline bool RequestWriteMail::has_mail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestWriteMail::set_has_mail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestWriteMail::clear_has_mail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestWriteMail::clear_mail() {
  if (mail_ != NULL) mail_->::Protocol::MailInfo::Clear();
  clear_has_mail();
}
inline const ::Protocol::MailInfo& RequestWriteMail::mail() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return mail_ != NULL ? *mail_ : *default_instance().mail_;
#else
  return mail_ != NULL ? *mail_ : *default_instance_->mail_;
#endif
}
inline ::Protocol::MailInfo* RequestWriteMail::mutable_mail() {
  set_has_mail();
  if (mail_ == NULL) mail_ = new ::Protocol::MailInfo;
  return mail_;
}
inline ::Protocol::MailInfo* RequestWriteMail::release_mail() {
  clear_has_mail();
  ::Protocol::MailInfo* temp = mail_;
  mail_ = NULL;
  return temp;
}
inline void RequestWriteMail::set_allocated_mail(::Protocol::MailInfo* mail) {
  delete mail_;
  mail_ = mail;
  if (mail) {
    set_has_mail();
  } else {
    clear_has_mail();
  }
}

// repeated .ItemLocNum loc_list = 2;
inline int RequestWriteMail::loc_list_size() const {
  return loc_list_.size();
}
inline void RequestWriteMail::clear_loc_list() {
  loc_list_.Clear();
}
inline const ::ItemLocNum& RequestWriteMail::loc_list(int index) const {
  return loc_list_.Get(index);
}
inline ::ItemLocNum* RequestWriteMail::mutable_loc_list(int index) {
  return loc_list_.Mutable(index);
}
inline ::ItemLocNum* RequestWriteMail::add_loc_list() {
  return loc_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ItemLocNum >&
RequestWriteMail::loc_list() const {
  return loc_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ItemLocNum >*
RequestWriteMail::mutable_loc_list() {
  return &loc_list_;
}

// -------------------------------------------------------------------

// ResponseWriteMail

// optional int32 result = 1;
inline bool ResponseWriteMail::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseWriteMail::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseWriteMail::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseWriteMail::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseWriteMail::result() const {
  return result_;
}
inline void ResponseWriteMail::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestDeleteMail

// repeated int32 id_list = 1;
inline int RequestDeleteMail::id_list_size() const {
  return id_list_.size();
}
inline void RequestDeleteMail::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 RequestDeleteMail::id_list(int index) const {
  return id_list_.Get(index);
}
inline void RequestDeleteMail::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void RequestDeleteMail::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestDeleteMail::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestDeleteMail::mutable_id_list() {
  return &id_list_;
}

// -------------------------------------------------------------------

// ResponseDeleteMail

// repeated int32 id_list = 1;
inline int ResponseDeleteMail::id_list_size() const {
  return id_list_.size();
}
inline void ResponseDeleteMail::clear_id_list() {
  id_list_.Clear();
}
inline ::google::protobuf::int32 ResponseDeleteMail::id_list(int index) const {
  return id_list_.Get(index);
}
inline void ResponseDeleteMail::set_id_list(int index, ::google::protobuf::int32 value) {
  id_list_.Set(index, value);
}
inline void ResponseDeleteMail::add_id_list(::google::protobuf::int32 value) {
  id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ResponseDeleteMail::id_list() const {
  return id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ResponseDeleteMail::mutable_id_list() {
  return &id_list_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoMail_2eproto__INCLUDED
