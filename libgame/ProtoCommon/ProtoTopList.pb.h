// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoTopList.proto

#ifndef PROTOBUF_ProtoTopList_2eproto__INCLUDED
#define PROTOBUF_ProtoTopList_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "ProtoGameData.pb.h"
// @@protoc_insertion_point(includes)

namespace Protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoTopList_2eproto();
void protobuf_AssignDesc_ProtoTopList_2eproto();
void protobuf_ShutdownFile_ProtoTopList_2eproto();

class TopLevelInfo;
class TopGradeInfo;
class TopMoneyInfo;
class TopGuildGardeInfo;
class TopListInfo;
class RequestGetTopList;
class ResponseGetTopList;

enum TopListOpCode {
  OP_TOPLIST_GET_LIST = 1
};
bool TopListOpCode_IsValid(int value);
const TopListOpCode TopListOpCode_MIN = OP_TOPLIST_GET_LIST;
const TopListOpCode TopListOpCode_MAX = OP_TOPLIST_GET_LIST;
const int TopListOpCode_ARRAYSIZE = TopListOpCode_MAX + 1;

enum TopListType {
  TOP_LEVEL = 0,
  TOP_GRADE = 1,
  TOP_MONEY = 2,
  TOP_GUILD_GRADE = 3,
  TOP_Count = 4
};
bool TopListType_IsValid(int value);
const TopListType TopListType_MIN = TOP_LEVEL;
const TopListType TopListType_MAX = TOP_Count;
const int TopListType_ARRAYSIZE = TopListType_MAX + 1;

// ===================================================================

class TopLevelInfo : public ::google::protobuf::MessageLite {
 public:
  TopLevelInfo();
  virtual ~TopLevelInfo();

  TopLevelInfo(const TopLevelInfo& from);

  inline TopLevelInfo& operator=(const TopLevelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TopLevelInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TopLevelInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TopLevelInfo* other);

  // implements Message ----------------------------------------------

  TopLevelInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TopLevelInfo& from);
  void MergeFrom(const TopLevelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // optional int32 country = 2;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 2;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional int32 charid = 3;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 3;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string charname = 4;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 4;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 charrace = 5;
  inline bool has_charrace() const;
  inline void clear_charrace();
  static const int kCharraceFieldNumber = 5;
  inline ::google::protobuf::int32 charrace() const;
  inline void set_charrace(::google::protobuf::int32 value);

  // optional int32 charlevel = 6;
  inline bool has_charlevel() const;
  inline void clear_charlevel();
  static const int kCharlevelFieldNumber = 6;
  inline ::google::protobuf::int32 charlevel() const;
  inline void set_charlevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.TopLevelInfo)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_charrace();
  inline void clear_has_charrace();
  inline void set_has_charlevel();
  inline void clear_has_charlevel();

  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 country_;
  ::std::string* charname_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 charrace_;
  ::google::protobuf::int32 charlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoTopList_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoTopList_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoTopList_2eproto();
  friend void protobuf_ShutdownFile_ProtoTopList_2eproto();

  void InitAsDefaultInstance();
  static TopLevelInfo* default_instance_;
};
// -------------------------------------------------------------------

class TopGradeInfo : public ::google::protobuf::MessageLite {
 public:
  TopGradeInfo();
  virtual ~TopGradeInfo();

  TopGradeInfo(const TopGradeInfo& from);

  inline TopGradeInfo& operator=(const TopGradeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TopGradeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TopGradeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TopGradeInfo* other);

  // implements Message ----------------------------------------------

  TopGradeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TopGradeInfo& from);
  void MergeFrom(const TopGradeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // optional int32 country = 2;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 2;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional int32 charid = 3;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 3;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string charname = 4;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 4;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 charrace = 5;
  inline bool has_charrace() const;
  inline void clear_charrace();
  static const int kCharraceFieldNumber = 5;
  inline ::google::protobuf::int32 charrace() const;
  inline void set_charrace(::google::protobuf::int32 value);

  // optional int32 chargrade = 6;
  inline bool has_chargrade() const;
  inline void clear_chargrade();
  static const int kChargradeFieldNumber = 6;
  inline ::google::protobuf::int32 chargrade() const;
  inline void set_chargrade(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.TopGradeInfo)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_charrace();
  inline void clear_has_charrace();
  inline void set_has_chargrade();
  inline void clear_has_chargrade();

  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 country_;
  ::std::string* charname_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 charrace_;
  ::google::protobuf::int32 chargrade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoTopList_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoTopList_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoTopList_2eproto();
  friend void protobuf_ShutdownFile_ProtoTopList_2eproto();

  void InitAsDefaultInstance();
  static TopGradeInfo* default_instance_;
};
// -------------------------------------------------------------------

class TopMoneyInfo : public ::google::protobuf::MessageLite {
 public:
  TopMoneyInfo();
  virtual ~TopMoneyInfo();

  TopMoneyInfo(const TopMoneyInfo& from);

  inline TopMoneyInfo& operator=(const TopMoneyInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TopMoneyInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TopMoneyInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TopMoneyInfo* other);

  // implements Message ----------------------------------------------

  TopMoneyInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TopMoneyInfo& from);
  void MergeFrom(const TopMoneyInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // optional int32 country = 2;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 2;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional int32 charid = 3;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 3;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string charname = 4;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 4;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // optional int32 charrace = 5;
  inline bool has_charrace() const;
  inline void clear_charrace();
  static const int kCharraceFieldNumber = 5;
  inline ::google::protobuf::int32 charrace() const;
  inline void set_charrace(::google::protobuf::int32 value);

  // optional int32 charmoney = 6;
  inline bool has_charmoney() const;
  inline void clear_charmoney();
  static const int kCharmoneyFieldNumber = 6;
  inline ::google::protobuf::int32 charmoney() const;
  inline void set_charmoney(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.TopMoneyInfo)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_charname();
  inline void clear_has_charname();
  inline void set_has_charrace();
  inline void clear_has_charrace();
  inline void set_has_charmoney();
  inline void clear_has_charmoney();

  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 country_;
  ::std::string* charname_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 charrace_;
  ::google::protobuf::int32 charmoney_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoTopList_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoTopList_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoTopList_2eproto();
  friend void protobuf_ShutdownFile_ProtoTopList_2eproto();

  void InitAsDefaultInstance();
  static TopMoneyInfo* default_instance_;
};
// -------------------------------------------------------------------

class TopGuildGardeInfo : public ::google::protobuf::MessageLite {
 public:
  TopGuildGardeInfo();
  virtual ~TopGuildGardeInfo();

  TopGuildGardeInfo(const TopGuildGardeInfo& from);

  inline TopGuildGardeInfo& operator=(const TopGuildGardeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TopGuildGardeInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TopGuildGardeInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TopGuildGardeInfo* other);

  // implements Message ----------------------------------------------

  TopGuildGardeInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TopGuildGardeInfo& from);
  void MergeFrom(const TopGuildGardeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 order = 1;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // optional int32 country = 2;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 2;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);

  // optional int32 guildid = 3;
  inline bool has_guildid() const;
  inline void clear_guildid();
  static const int kGuildidFieldNumber = 3;
  inline ::google::protobuf::int32 guildid() const;
  inline void set_guildid(::google::protobuf::int32 value);

  // optional string guildname = 4;
  inline bool has_guildname() const;
  inline void clear_guildname();
  static const int kGuildnameFieldNumber = 4;
  inline const ::std::string& guildname() const;
  inline void set_guildname(const ::std::string& value);
  inline void set_guildname(const char* value);
  inline void set_guildname(const char* value, size_t size);
  inline ::std::string* mutable_guildname();
  inline ::std::string* release_guildname();
  inline void set_allocated_guildname(::std::string* guildname);

  // optional string master = 5;
  inline bool has_master() const;
  inline void clear_master();
  static const int kMasterFieldNumber = 5;
  inline const ::std::string& master() const;
  inline void set_master(const ::std::string& value);
  inline void set_master(const char* value);
  inline void set_master(const char* value, size_t size);
  inline ::std::string* mutable_master();
  inline ::std::string* release_master();
  inline void set_allocated_master(::std::string* master);

  // optional int32 guildgrade = 6;
  inline bool has_guildgrade() const;
  inline void clear_guildgrade();
  static const int kGuildgradeFieldNumber = 6;
  inline ::google::protobuf::int32 guildgrade() const;
  inline void set_guildgrade(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.TopGuildGardeInfo)
 private:
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_guildid();
  inline void clear_has_guildid();
  inline void set_has_guildname();
  inline void clear_has_guildname();
  inline void set_has_master();
  inline void clear_has_master();
  inline void set_has_guildgrade();
  inline void clear_has_guildgrade();

  ::google::protobuf::int32 order_;
  ::google::protobuf::int32 country_;
  ::std::string* guildname_;
  ::google::protobuf::int32 guildid_;
  ::google::protobuf::int32 guildgrade_;
  ::std::string* master_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoTopList_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoTopList_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoTopList_2eproto();
  friend void protobuf_ShutdownFile_ProtoTopList_2eproto();

  void InitAsDefaultInstance();
  static TopGuildGardeInfo* default_instance_;
};
// -------------------------------------------------------------------

class TopListInfo : public ::google::protobuf::MessageLite {
 public:
  TopListInfo();
  virtual ~TopListInfo();

  TopListInfo(const TopListInfo& from);

  inline TopListInfo& operator=(const TopListInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const TopListInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TopListInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TopListInfo* other);

  // implements Message ----------------------------------------------

  TopListInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TopListInfo& from);
  void MergeFrom(const TopListInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.TopLevelInfo level_info = 1;
  inline bool has_level_info() const;
  inline void clear_level_info();
  static const int kLevelInfoFieldNumber = 1;
  inline const ::Protocol::TopLevelInfo& level_info() const;
  inline ::Protocol::TopLevelInfo* mutable_level_info();
  inline ::Protocol::TopLevelInfo* release_level_info();
  inline void set_allocated_level_info(::Protocol::TopLevelInfo* level_info);

  // optional .Protocol.TopGradeInfo grade_info = 2;
  inline bool has_grade_info() const;
  inline void clear_grade_info();
  static const int kGradeInfoFieldNumber = 2;
  inline const ::Protocol::TopGradeInfo& grade_info() const;
  inline ::Protocol::TopGradeInfo* mutable_grade_info();
  inline ::Protocol::TopGradeInfo* release_grade_info();
  inline void set_allocated_grade_info(::Protocol::TopGradeInfo* grade_info);

  // optional .Protocol.TopMoneyInfo money_info = 3;
  inline bool has_money_info() const;
  inline void clear_money_info();
  static const int kMoneyInfoFieldNumber = 3;
  inline const ::Protocol::TopMoneyInfo& money_info() const;
  inline ::Protocol::TopMoneyInfo* mutable_money_info();
  inline ::Protocol::TopMoneyInfo* release_money_info();
  inline void set_allocated_money_info(::Protocol::TopMoneyInfo* money_info);

  // optional .Protocol.TopGuildGardeInfo guildgarde_info = 4;
  inline bool has_guildgarde_info() const;
  inline void clear_guildgarde_info();
  static const int kGuildgardeInfoFieldNumber = 4;
  inline const ::Protocol::TopGuildGardeInfo& guildgarde_info() const;
  inline ::Protocol::TopGuildGardeInfo* mutable_guildgarde_info();
  inline ::Protocol::TopGuildGardeInfo* release_guildgarde_info();
  inline void set_allocated_guildgarde_info(::Protocol::TopGuildGardeInfo* guildgarde_info);

  // @@protoc_insertion_point(class_scope:Protocol.TopListInfo)
 private:
  inline void set_has_level_info();
  inline void clear_has_level_info();
  inline void set_has_grade_info();
  inline void clear_has_grade_info();
  inline void set_has_money_info();
  inline void clear_has_money_info();
  inline void set_has_guildgarde_info();
  inline void clear_has_guildgarde_info();

  ::Protocol::TopLevelInfo* level_info_;
  ::Protocol::TopGradeInfo* grade_info_;
  ::Protocol::TopMoneyInfo* money_info_;
  ::Protocol::TopGuildGardeInfo* guildgarde_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoTopList_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoTopList_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoTopList_2eproto();
  friend void protobuf_ShutdownFile_ProtoTopList_2eproto();

  void InitAsDefaultInstance();
  static TopListInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetTopList : public ::google::protobuf::MessageLite {
 public:
  RequestGetTopList();
  virtual ~RequestGetTopList();

  RequestGetTopList(const RequestGetTopList& from);

  inline RequestGetTopList& operator=(const RequestGetTopList& from) {
    CopyFrom(from);
    return *this;
  }

  static const RequestGetTopList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RequestGetTopList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RequestGetTopList* other);

  // implements Message ----------------------------------------------

  RequestGetTopList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RequestGetTopList& from);
  void MergeFrom(const RequestGetTopList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.TopListType top_type = 1;
  inline bool has_top_type() const;
  inline void clear_top_type();
  static const int kTopTypeFieldNumber = 1;
  inline ::Protocol::TopListType top_type() const;
  inline void set_top_type(::Protocol::TopListType value);

  // @@protoc_insertion_point(class_scope:Protocol.RequestGetTopList)
 private:
  inline void set_has_top_type();
  inline void clear_has_top_type();

  int top_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoTopList_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoTopList_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoTopList_2eproto();
  friend void protobuf_ShutdownFile_ProtoTopList_2eproto();

  void InitAsDefaultInstance();
  static RequestGetTopList* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetTopList : public ::google::protobuf::MessageLite {
 public:
  ResponseGetTopList();
  virtual ~ResponseGetTopList();

  ResponseGetTopList(const ResponseGetTopList& from);

  inline ResponseGetTopList& operator=(const ResponseGetTopList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResponseGetTopList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponseGetTopList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResponseGetTopList* other);

  // implements Message ----------------------------------------------

  ResponseGetTopList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponseGetTopList& from);
  void MergeFrom(const ResponseGetTopList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Protocol.TopListType top_type = 1;
  inline bool has_top_type() const;
  inline void clear_top_type();
  static const int kTopTypeFieldNumber = 1;
  inline ::Protocol::TopListType top_type() const;
  inline void set_top_type(::Protocol::TopListType value);

  // repeated .Protocol.TopListInfo top_list = 2;
  inline int top_list_size() const;
  inline void clear_top_list();
  static const int kTopListFieldNumber = 2;
  inline const ::Protocol::TopListInfo& top_list(int index) const;
  inline ::Protocol::TopListInfo* mutable_top_list(int index);
  inline ::Protocol::TopListInfo* add_top_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Protocol::TopListInfo >&
      top_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Protocol::TopListInfo >*
      mutable_top_list();

  // optional int32 my_order = 3;
  inline bool has_my_order() const;
  inline void clear_my_order();
  static const int kMyOrderFieldNumber = 3;
  inline ::google::protobuf::int32 my_order() const;
  inline void set_my_order(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Protocol.ResponseGetTopList)
 private:
  inline void set_has_top_type();
  inline void clear_has_top_type();
  inline void set_has_my_order();
  inline void clear_has_my_order();

  ::google::protobuf::RepeatedPtrField< ::Protocol::TopListInfo > top_list_;
  int top_type_;
  ::google::protobuf::int32 my_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_ProtoTopList_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_ProtoTopList_2eproto();
  #endif
  friend void protobuf_AssignDesc_ProtoTopList_2eproto();
  friend void protobuf_ShutdownFile_ProtoTopList_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetTopList* default_instance_;
};
// ===================================================================


// ===================================================================

// TopLevelInfo

// optional int32 order = 1;
inline bool TopLevelInfo::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopLevelInfo::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopLevelInfo::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopLevelInfo::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 TopLevelInfo::order() const {
  return order_;
}
inline void TopLevelInfo::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// optional int32 country = 2;
inline bool TopLevelInfo::has_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopLevelInfo::set_has_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopLevelInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopLevelInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 TopLevelInfo::country() const {
  return country_;
}
inline void TopLevelInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional int32 charid = 3;
inline bool TopLevelInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopLevelInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopLevelInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopLevelInfo::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 TopLevelInfo::charid() const {
  return charid_;
}
inline void TopLevelInfo::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string charname = 4;
inline bool TopLevelInfo::has_charname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopLevelInfo::set_has_charname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopLevelInfo::clear_has_charname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopLevelInfo::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& TopLevelInfo::charname() const {
  return *charname_;
}
inline void TopLevelInfo::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void TopLevelInfo::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void TopLevelInfo::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopLevelInfo::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* TopLevelInfo::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopLevelInfo::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 charrace = 5;
inline bool TopLevelInfo::has_charrace() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopLevelInfo::set_has_charrace() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopLevelInfo::clear_has_charrace() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopLevelInfo::clear_charrace() {
  charrace_ = 0;
  clear_has_charrace();
}
inline ::google::protobuf::int32 TopLevelInfo::charrace() const {
  return charrace_;
}
inline void TopLevelInfo::set_charrace(::google::protobuf::int32 value) {
  set_has_charrace();
  charrace_ = value;
}

// optional int32 charlevel = 6;
inline bool TopLevelInfo::has_charlevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopLevelInfo::set_has_charlevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopLevelInfo::clear_has_charlevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopLevelInfo::clear_charlevel() {
  charlevel_ = 0;
  clear_has_charlevel();
}
inline ::google::protobuf::int32 TopLevelInfo::charlevel() const {
  return charlevel_;
}
inline void TopLevelInfo::set_charlevel(::google::protobuf::int32 value) {
  set_has_charlevel();
  charlevel_ = value;
}

// -------------------------------------------------------------------

// TopGradeInfo

// optional int32 order = 1;
inline bool TopGradeInfo::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopGradeInfo::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopGradeInfo::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopGradeInfo::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 TopGradeInfo::order() const {
  return order_;
}
inline void TopGradeInfo::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// optional int32 country = 2;
inline bool TopGradeInfo::has_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopGradeInfo::set_has_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopGradeInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopGradeInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 TopGradeInfo::country() const {
  return country_;
}
inline void TopGradeInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional int32 charid = 3;
inline bool TopGradeInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopGradeInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopGradeInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopGradeInfo::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 TopGradeInfo::charid() const {
  return charid_;
}
inline void TopGradeInfo::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string charname = 4;
inline bool TopGradeInfo::has_charname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopGradeInfo::set_has_charname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopGradeInfo::clear_has_charname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopGradeInfo::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& TopGradeInfo::charname() const {
  return *charname_;
}
inline void TopGradeInfo::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void TopGradeInfo::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void TopGradeInfo::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopGradeInfo::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* TopGradeInfo::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopGradeInfo::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 charrace = 5;
inline bool TopGradeInfo::has_charrace() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopGradeInfo::set_has_charrace() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopGradeInfo::clear_has_charrace() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopGradeInfo::clear_charrace() {
  charrace_ = 0;
  clear_has_charrace();
}
inline ::google::protobuf::int32 TopGradeInfo::charrace() const {
  return charrace_;
}
inline void TopGradeInfo::set_charrace(::google::protobuf::int32 value) {
  set_has_charrace();
  charrace_ = value;
}

// optional int32 chargrade = 6;
inline bool TopGradeInfo::has_chargrade() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopGradeInfo::set_has_chargrade() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopGradeInfo::clear_has_chargrade() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopGradeInfo::clear_chargrade() {
  chargrade_ = 0;
  clear_has_chargrade();
}
inline ::google::protobuf::int32 TopGradeInfo::chargrade() const {
  return chargrade_;
}
inline void TopGradeInfo::set_chargrade(::google::protobuf::int32 value) {
  set_has_chargrade();
  chargrade_ = value;
}

// -------------------------------------------------------------------

// TopMoneyInfo

// optional int32 order = 1;
inline bool TopMoneyInfo::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopMoneyInfo::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopMoneyInfo::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopMoneyInfo::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 TopMoneyInfo::order() const {
  return order_;
}
inline void TopMoneyInfo::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// optional int32 country = 2;
inline bool TopMoneyInfo::has_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopMoneyInfo::set_has_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopMoneyInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopMoneyInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 TopMoneyInfo::country() const {
  return country_;
}
inline void TopMoneyInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional int32 charid = 3;
inline bool TopMoneyInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopMoneyInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopMoneyInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopMoneyInfo::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 TopMoneyInfo::charid() const {
  return charid_;
}
inline void TopMoneyInfo::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string charname = 4;
inline bool TopMoneyInfo::has_charname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopMoneyInfo::set_has_charname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopMoneyInfo::clear_has_charname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopMoneyInfo::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& TopMoneyInfo::charname() const {
  return *charname_;
}
inline void TopMoneyInfo::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void TopMoneyInfo::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void TopMoneyInfo::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopMoneyInfo::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* TopMoneyInfo::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopMoneyInfo::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 charrace = 5;
inline bool TopMoneyInfo::has_charrace() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopMoneyInfo::set_has_charrace() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopMoneyInfo::clear_has_charrace() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopMoneyInfo::clear_charrace() {
  charrace_ = 0;
  clear_has_charrace();
}
inline ::google::protobuf::int32 TopMoneyInfo::charrace() const {
  return charrace_;
}
inline void TopMoneyInfo::set_charrace(::google::protobuf::int32 value) {
  set_has_charrace();
  charrace_ = value;
}

// optional int32 charmoney = 6;
inline bool TopMoneyInfo::has_charmoney() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopMoneyInfo::set_has_charmoney() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopMoneyInfo::clear_has_charmoney() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopMoneyInfo::clear_charmoney() {
  charmoney_ = 0;
  clear_has_charmoney();
}
inline ::google::protobuf::int32 TopMoneyInfo::charmoney() const {
  return charmoney_;
}
inline void TopMoneyInfo::set_charmoney(::google::protobuf::int32 value) {
  set_has_charmoney();
  charmoney_ = value;
}

// -------------------------------------------------------------------

// TopGuildGardeInfo

// optional int32 order = 1;
inline bool TopGuildGardeInfo::has_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopGuildGardeInfo::set_has_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopGuildGardeInfo::clear_has_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopGuildGardeInfo::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 TopGuildGardeInfo::order() const {
  return order_;
}
inline void TopGuildGardeInfo::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// optional int32 country = 2;
inline bool TopGuildGardeInfo::has_country() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopGuildGardeInfo::set_has_country() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopGuildGardeInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopGuildGardeInfo::clear_country() {
  country_ = 0;
  clear_has_country();
}
inline ::google::protobuf::int32 TopGuildGardeInfo::country() const {
  return country_;
}
inline void TopGuildGardeInfo::set_country(::google::protobuf::int32 value) {
  set_has_country();
  country_ = value;
}

// optional int32 guildid = 3;
inline bool TopGuildGardeInfo::has_guildid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopGuildGardeInfo::set_has_guildid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopGuildGardeInfo::clear_has_guildid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopGuildGardeInfo::clear_guildid() {
  guildid_ = 0;
  clear_has_guildid();
}
inline ::google::protobuf::int32 TopGuildGardeInfo::guildid() const {
  return guildid_;
}
inline void TopGuildGardeInfo::set_guildid(::google::protobuf::int32 value) {
  set_has_guildid();
  guildid_ = value;
}

// optional string guildname = 4;
inline bool TopGuildGardeInfo::has_guildname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopGuildGardeInfo::set_has_guildname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopGuildGardeInfo::clear_has_guildname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopGuildGardeInfo::clear_guildname() {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    guildname_->clear();
  }
  clear_has_guildname();
}
inline const ::std::string& TopGuildGardeInfo::guildname() const {
  return *guildname_;
}
inline void TopGuildGardeInfo::set_guildname(const ::std::string& value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void TopGuildGardeInfo::set_guildname(const char* value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void TopGuildGardeInfo::set_guildname(const char* value, size_t size) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopGuildGardeInfo::mutable_guildname() {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  return guildname_;
}
inline ::std::string* TopGuildGardeInfo::release_guildname() {
  clear_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guildname_;
    guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopGuildGardeInfo::set_allocated_guildname(::std::string* guildname) {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    delete guildname_;
  }
  if (guildname) {
    set_has_guildname();
    guildname_ = guildname;
  } else {
    clear_has_guildname();
    guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string master = 5;
inline bool TopGuildGardeInfo::has_master() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopGuildGardeInfo::set_has_master() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopGuildGardeInfo::clear_has_master() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopGuildGardeInfo::clear_master() {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    master_->clear();
  }
  clear_has_master();
}
inline const ::std::string& TopGuildGardeInfo::master() const {
  return *master_;
}
inline void TopGuildGardeInfo::set_master(const ::std::string& value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void TopGuildGardeInfo::set_master(const char* value) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(value);
}
inline void TopGuildGardeInfo::set_master(const char* value, size_t size) {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  master_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TopGuildGardeInfo::mutable_master() {
  set_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    master_ = new ::std::string;
  }
  return master_;
}
inline ::std::string* TopGuildGardeInfo::release_master() {
  clear_has_master();
  if (master_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = master_;
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TopGuildGardeInfo::set_allocated_master(::std::string* master) {
  if (master_ != &::google::protobuf::internal::kEmptyString) {
    delete master_;
  }
  if (master) {
    set_has_master();
    master_ = master;
  } else {
    clear_has_master();
    master_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 guildgrade = 6;
inline bool TopGuildGardeInfo::has_guildgrade() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopGuildGardeInfo::set_has_guildgrade() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopGuildGardeInfo::clear_has_guildgrade() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopGuildGardeInfo::clear_guildgrade() {
  guildgrade_ = 0;
  clear_has_guildgrade();
}
inline ::google::protobuf::int32 TopGuildGardeInfo::guildgrade() const {
  return guildgrade_;
}
inline void TopGuildGardeInfo::set_guildgrade(::google::protobuf::int32 value) {
  set_has_guildgrade();
  guildgrade_ = value;
}

// -------------------------------------------------------------------

// TopListInfo

// optional .Protocol.TopLevelInfo level_info = 1;
inline bool TopListInfo::has_level_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopListInfo::set_has_level_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopListInfo::clear_has_level_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopListInfo::clear_level_info() {
  if (level_info_ != NULL) level_info_->::Protocol::TopLevelInfo::Clear();
  clear_has_level_info();
}
inline const ::Protocol::TopLevelInfo& TopListInfo::level_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return level_info_ != NULL ? *level_info_ : *default_instance().level_info_;
#else
  return level_info_ != NULL ? *level_info_ : *default_instance_->level_info_;
#endif
}
inline ::Protocol::TopLevelInfo* TopListInfo::mutable_level_info() {
  set_has_level_info();
  if (level_info_ == NULL) level_info_ = new ::Protocol::TopLevelInfo;
  return level_info_;
}
inline ::Protocol::TopLevelInfo* TopListInfo::release_level_info() {
  clear_has_level_info();
  ::Protocol::TopLevelInfo* temp = level_info_;
  level_info_ = NULL;
  return temp;
}
inline void TopListInfo::set_allocated_level_info(::Protocol::TopLevelInfo* level_info) {
  delete level_info_;
  level_info_ = level_info;
  if (level_info) {
    set_has_level_info();
  } else {
    clear_has_level_info();
  }
}

// optional .Protocol.TopGradeInfo grade_info = 2;
inline bool TopListInfo::has_grade_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopListInfo::set_has_grade_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopListInfo::clear_has_grade_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopListInfo::clear_grade_info() {
  if (grade_info_ != NULL) grade_info_->::Protocol::TopGradeInfo::Clear();
  clear_has_grade_info();
}
inline const ::Protocol::TopGradeInfo& TopListInfo::grade_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return grade_info_ != NULL ? *grade_info_ : *default_instance().grade_info_;
#else
  return grade_info_ != NULL ? *grade_info_ : *default_instance_->grade_info_;
#endif
}
inline ::Protocol::TopGradeInfo* TopListInfo::mutable_grade_info() {
  set_has_grade_info();
  if (grade_info_ == NULL) grade_info_ = new ::Protocol::TopGradeInfo;
  return grade_info_;
}
inline ::Protocol::TopGradeInfo* TopListInfo::release_grade_info() {
  clear_has_grade_info();
  ::Protocol::TopGradeInfo* temp = grade_info_;
  grade_info_ = NULL;
  return temp;
}
inline void TopListInfo::set_allocated_grade_info(::Protocol::TopGradeInfo* grade_info) {
  delete grade_info_;
  grade_info_ = grade_info;
  if (grade_info) {
    set_has_grade_info();
  } else {
    clear_has_grade_info();
  }
}

// optional .Protocol.TopMoneyInfo money_info = 3;
inline bool TopListInfo::has_money_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopListInfo::set_has_money_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopListInfo::clear_has_money_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopListInfo::clear_money_info() {
  if (money_info_ != NULL) money_info_->::Protocol::TopMoneyInfo::Clear();
  clear_has_money_info();
}
inline const ::Protocol::TopMoneyInfo& TopListInfo::money_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return money_info_ != NULL ? *money_info_ : *default_instance().money_info_;
#else
  return money_info_ != NULL ? *money_info_ : *default_instance_->money_info_;
#endif
}
inline ::Protocol::TopMoneyInfo* TopListInfo::mutable_money_info() {
  set_has_money_info();
  if (money_info_ == NULL) money_info_ = new ::Protocol::TopMoneyInfo;
  return money_info_;
}
inline ::Protocol::TopMoneyInfo* TopListInfo::release_money_info() {
  clear_has_money_info();
  ::Protocol::TopMoneyInfo* temp = money_info_;
  money_info_ = NULL;
  return temp;
}
inline void TopListInfo::set_allocated_money_info(::Protocol::TopMoneyInfo* money_info) {
  delete money_info_;
  money_info_ = money_info;
  if (money_info) {
    set_has_money_info();
  } else {
    clear_has_money_info();
  }
}

// optional .Protocol.TopGuildGardeInfo guildgarde_info = 4;
inline bool TopListInfo::has_guildgarde_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopListInfo::set_has_guildgarde_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopListInfo::clear_has_guildgarde_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopListInfo::clear_guildgarde_info() {
  if (guildgarde_info_ != NULL) guildgarde_info_->::Protocol::TopGuildGardeInfo::Clear();
  clear_has_guildgarde_info();
}
inline const ::Protocol::TopGuildGardeInfo& TopListInfo::guildgarde_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guildgarde_info_ != NULL ? *guildgarde_info_ : *default_instance().guildgarde_info_;
#else
  return guildgarde_info_ != NULL ? *guildgarde_info_ : *default_instance_->guildgarde_info_;
#endif
}
inline ::Protocol::TopGuildGardeInfo* TopListInfo::mutable_guildgarde_info() {
  set_has_guildgarde_info();
  if (guildgarde_info_ == NULL) guildgarde_info_ = new ::Protocol::TopGuildGardeInfo;
  return guildgarde_info_;
}
inline ::Protocol::TopGuildGardeInfo* TopListInfo::release_guildgarde_info() {
  clear_has_guildgarde_info();
  ::Protocol::TopGuildGardeInfo* temp = guildgarde_info_;
  guildgarde_info_ = NULL;
  return temp;
}
inline void TopListInfo::set_allocated_guildgarde_info(::Protocol::TopGuildGardeInfo* guildgarde_info) {
  delete guildgarde_info_;
  guildgarde_info_ = guildgarde_info;
  if (guildgarde_info) {
    set_has_guildgarde_info();
  } else {
    clear_has_guildgarde_info();
  }
}

// -------------------------------------------------------------------

// RequestGetTopList

// optional .Protocol.TopListType top_type = 1;
inline bool RequestGetTopList::has_top_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetTopList::set_has_top_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetTopList::clear_has_top_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetTopList::clear_top_type() {
  top_type_ = 0;
  clear_has_top_type();
}
inline ::Protocol::TopListType RequestGetTopList::top_type() const {
  return static_cast< ::Protocol::TopListType >(top_type_);
}
inline void RequestGetTopList::set_top_type(::Protocol::TopListType value) {
  assert(::Protocol::TopListType_IsValid(value));
  set_has_top_type();
  top_type_ = value;
}

// -------------------------------------------------------------------

// ResponseGetTopList

// optional .Protocol.TopListType top_type = 1;
inline bool ResponseGetTopList::has_top_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetTopList::set_has_top_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetTopList::clear_has_top_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetTopList::clear_top_type() {
  top_type_ = 0;
  clear_has_top_type();
}
inline ::Protocol::TopListType ResponseGetTopList::top_type() const {
  return static_cast< ::Protocol::TopListType >(top_type_);
}
inline void ResponseGetTopList::set_top_type(::Protocol::TopListType value) {
  assert(::Protocol::TopListType_IsValid(value));
  set_has_top_type();
  top_type_ = value;
}

// repeated .Protocol.TopListInfo top_list = 2;
inline int ResponseGetTopList::top_list_size() const {
  return top_list_.size();
}
inline void ResponseGetTopList::clear_top_list() {
  top_list_.Clear();
}
inline const ::Protocol::TopListInfo& ResponseGetTopList::top_list(int index) const {
  return top_list_.Get(index);
}
inline ::Protocol::TopListInfo* ResponseGetTopList::mutable_top_list(int index) {
  return top_list_.Mutable(index);
}
inline ::Protocol::TopListInfo* ResponseGetTopList::add_top_list() {
  return top_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Protocol::TopListInfo >&
ResponseGetTopList::top_list() const {
  return top_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Protocol::TopListInfo >*
ResponseGetTopList::mutable_top_list() {
  return &top_list_;
}

// optional int32 my_order = 3;
inline bool ResponseGetTopList::has_my_order() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseGetTopList::set_has_my_order() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseGetTopList::clear_has_my_order() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseGetTopList::clear_my_order() {
  my_order_ = 0;
  clear_has_my_order();
}
inline ::google::protobuf::int32 ResponseGetTopList::my_order() const {
  return my_order_;
}
inline void ResponseGetTopList::set_my_order(::google::protobuf::int32 value) {
  set_has_my_order();
  my_order_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoTopList_2eproto__INCLUDED
