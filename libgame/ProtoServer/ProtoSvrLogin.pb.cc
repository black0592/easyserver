// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoSvrLogin.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ProtoSvrLogin.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace LoginCmd {

void protobuf_ShutdownFile_ProtoSvrLogin_2eproto() {
  delete RequestRegisterGameServer::default_instance_;
  delete ResponseRegisterGameServer::default_instance_;
  delete UpdateGameServerInfo::default_instance_;
  delete RequestUserEndTime::default_instance_;
  delete ResponseUserEndTime::default_instance_;
  delete RequestGetUserCashInfo::default_instance_;
  delete ResponseGetUserCashInfo::default_instance_;
  delete RequestUpdateUserCashInfo::default_instance_;
  delete ResponseUpdateUserCashInfo::default_instance_;
  delete RequestStopAccount::default_instance_;
  delete GameServerPing::default_instance_;
  delete RequestRegisterGatewayServer::default_instance_;
  delete ResponseRegisterGatewayServer::default_instance_;
  delete RequestRegUserToGateway::default_instance_;
  delete ResponseRegUserToGateway::default_instance_;
  delete NotifyUnregLoginUser::default_instance_;
  delete NotifyUnregGatewayUser::default_instance_;
  delete MsgGatewayServerPing::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_ProtoSvrLogin_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_ProtoSvrLogin_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::protobuf_AddDesc_ProtoSvrServerData_2eproto();
  RequestRegisterGameServer::default_instance_ = new RequestRegisterGameServer();
  ResponseRegisterGameServer::default_instance_ = new ResponseRegisterGameServer();
  UpdateGameServerInfo::default_instance_ = new UpdateGameServerInfo();
  RequestUserEndTime::default_instance_ = new RequestUserEndTime();
  ResponseUserEndTime::default_instance_ = new ResponseUserEndTime();
  RequestGetUserCashInfo::default_instance_ = new RequestGetUserCashInfo();
  ResponseGetUserCashInfo::default_instance_ = new ResponseGetUserCashInfo();
  RequestUpdateUserCashInfo::default_instance_ = new RequestUpdateUserCashInfo();
  ResponseUpdateUserCashInfo::default_instance_ = new ResponseUpdateUserCashInfo();
  RequestStopAccount::default_instance_ = new RequestStopAccount();
  GameServerPing::default_instance_ = new GameServerPing();
  RequestRegisterGatewayServer::default_instance_ = new RequestRegisterGatewayServer();
  ResponseRegisterGatewayServer::default_instance_ = new ResponseRegisterGatewayServer();
  RequestRegUserToGateway::default_instance_ = new RequestRegUserToGateway();
  ResponseRegUserToGateway::default_instance_ = new ResponseRegUserToGateway();
  NotifyUnregLoginUser::default_instance_ = new NotifyUnregLoginUser();
  NotifyUnregGatewayUser::default_instance_ = new NotifyUnregGatewayUser();
  MsgGatewayServerPing::default_instance_ = new MsgGatewayServerPing();
  RequestRegisterGameServer::default_instance_->InitAsDefaultInstance();
  ResponseRegisterGameServer::default_instance_->InitAsDefaultInstance();
  UpdateGameServerInfo::default_instance_->InitAsDefaultInstance();
  RequestUserEndTime::default_instance_->InitAsDefaultInstance();
  ResponseUserEndTime::default_instance_->InitAsDefaultInstance();
  RequestGetUserCashInfo::default_instance_->InitAsDefaultInstance();
  ResponseGetUserCashInfo::default_instance_->InitAsDefaultInstance();
  RequestUpdateUserCashInfo::default_instance_->InitAsDefaultInstance();
  ResponseUpdateUserCashInfo::default_instance_->InitAsDefaultInstance();
  RequestStopAccount::default_instance_->InitAsDefaultInstance();
  GameServerPing::default_instance_->InitAsDefaultInstance();
  RequestRegisterGatewayServer::default_instance_->InitAsDefaultInstance();
  ResponseRegisterGatewayServer::default_instance_->InitAsDefaultInstance();
  RequestRegUserToGateway::default_instance_->InitAsDefaultInstance();
  ResponseRegUserToGateway::default_instance_->InitAsDefaultInstance();
  NotifyUnregLoginUser::default_instance_->InitAsDefaultInstance();
  NotifyUnregGatewayUser::default_instance_->InitAsDefaultInstance();
  MsgGatewayServerPing::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ProtoSvrLogin_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_ProtoSvrLogin_2eproto_once_);
void protobuf_AddDesc_ProtoSvrLogin_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_ProtoSvrLogin_2eproto_once_,
                 &protobuf_AddDesc_ProtoSvrLogin_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ProtoSvrLogin_2eproto {
  StaticDescriptorInitializer_ProtoSvrLogin_2eproto() {
    protobuf_AddDesc_ProtoSvrLogin_2eproto();
  }
} static_descriptor_initializer_ProtoSvrLogin_2eproto_;
#endif
bool SvrGame2LoginOpCode_IsValid(int value) {
  switch(value) {
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 99:
      return true;
    default:
      return false;
  }
}

bool SvrGateway2LoginOpCode_IsValid(int value) {
  switch(value) {
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 199:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRegisterGameServer::kIdFieldNumber;
const int RequestRegisterGameServer::kNameFieldNumber;
const int RequestRegisterGameServer::kPortFieldNumber;
#endif  // !_MSC_VER

RequestRegisterGameServer::RequestRegisterGameServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestRegisterGameServer::InitAsDefaultInstance() {
}

RequestRegisterGameServer::RequestRegisterGameServer(const RequestRegisterGameServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestRegisterGameServer::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegisterGameServer::~RequestRegisterGameServer() {
  SharedDtor();
}

void RequestRegisterGameServer::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRegisterGameServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegisterGameServer& RequestRegisterGameServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

RequestRegisterGameServer* RequestRegisterGameServer::default_instance_ = NULL;

RequestRegisterGameServer* RequestRegisterGameServer::New() const {
  return new RequestRegisterGameServer;
}

void RequestRegisterGameServer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestRegisterGameServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // optional int32 port = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestRegisterGameServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional int32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->port(), output);
  }

}

int RequestRegisterGameServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 port = 3;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegisterGameServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegisterGameServer*>(&from));
}

void RequestRegisterGameServer::MergeFrom(const RequestRegisterGameServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
}

void RequestRegisterGameServer::CopyFrom(const RequestRegisterGameServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegisterGameServer::IsInitialized() const {

  return true;
}

void RequestRegisterGameServer::Swap(RequestRegisterGameServer* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegisterGameServer::GetTypeName() const {
  return "LoginCmd.RequestRegisterGameServer";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseRegisterGameServer::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseRegisterGameServer::ResponseRegisterGameServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseRegisterGameServer::InitAsDefaultInstance() {
}

ResponseRegisterGameServer::ResponseRegisterGameServer(const ResponseRegisterGameServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseRegisterGameServer::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseRegisterGameServer::~ResponseRegisterGameServer() {
  SharedDtor();
}

void ResponseRegisterGameServer::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseRegisterGameServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseRegisterGameServer& ResponseRegisterGameServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseRegisterGameServer* ResponseRegisterGameServer::default_instance_ = NULL;

ResponseRegisterGameServer* ResponseRegisterGameServer::New() const {
  return new ResponseRegisterGameServer;
}

void ResponseRegisterGameServer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseRegisterGameServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseRegisterGameServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseRegisterGameServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseRegisterGameServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseRegisterGameServer*>(&from));
}

void ResponseRegisterGameServer::MergeFrom(const ResponseRegisterGameServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseRegisterGameServer::CopyFrom(const ResponseRegisterGameServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseRegisterGameServer::IsInitialized() const {

  return true;
}

void ResponseRegisterGameServer::Swap(ResponseRegisterGameServer* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseRegisterGameServer::GetTypeName() const {
  return "LoginCmd.ResponseRegisterGameServer";
}


// ===================================================================

#ifndef _MSC_VER
const int UpdateGameServerInfo::kServerIdFieldNumber;
const int UpdateGameServerInfo::kOnlineNumFieldNumber;
const int UpdateGameServerInfo::kMaxNumFieldNumber;
const int UpdateGameServerInfo::kStateFieldNumber;
#endif  // !_MSC_VER

UpdateGameServerInfo::UpdateGameServerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void UpdateGameServerInfo::InitAsDefaultInstance() {
}

UpdateGameServerInfo::UpdateGameServerInfo(const UpdateGameServerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void UpdateGameServerInfo::SharedCtor() {
  _cached_size_ = 0;
  server_id_ = 0;
  online_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  max_num_ = 0;
  state_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpdateGameServerInfo::~UpdateGameServerInfo() {
  SharedDtor();
}

void UpdateGameServerInfo::SharedDtor() {
  if (online_num_ != &::google::protobuf::internal::kEmptyString) {
    delete online_num_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UpdateGameServerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UpdateGameServerInfo& UpdateGameServerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

UpdateGameServerInfo* UpdateGameServerInfo::default_instance_ = NULL;

UpdateGameServerInfo* UpdateGameServerInfo::New() const {
  return new UpdateGameServerInfo;
}

void UpdateGameServerInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    server_id_ = 0;
    if (has_online_num()) {
      if (online_num_ != &::google::protobuf::internal::kEmptyString) {
        online_num_->clear();
      }
    }
    max_num_ = 0;
    state_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool UpdateGameServerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 server_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &server_id_)));
          set_has_server_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_online_num;
        break;
      }

      // optional string online_num = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_online_num:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_online_num()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_max_num;
        break;
      }

      // optional int32 max_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_num_)));
          set_has_max_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_state;
        break;
      }

      // optional int32 state = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_state:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &state_)));
          set_has_state();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void UpdateGameServerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 server_id = 1;
  if (has_server_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->server_id(), output);
  }

  // optional string online_num = 2;
  if (has_online_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->online_num(), output);
  }

  // optional int32 max_num = 3;
  if (has_max_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->max_num(), output);
  }

  // optional int32 state = 4;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->state(), output);
  }

}

int UpdateGameServerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 server_id = 1;
    if (has_server_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->server_id());
    }

    // optional string online_num = 2;
    if (has_online_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->online_num());
    }

    // optional int32 max_num = 3;
    if (has_max_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_num());
    }

    // optional int32 state = 4;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->state());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpdateGameServerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UpdateGameServerInfo*>(&from));
}

void UpdateGameServerInfo::MergeFrom(const UpdateGameServerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_server_id()) {
      set_server_id(from.server_id());
    }
    if (from.has_online_num()) {
      set_online_num(from.online_num());
    }
    if (from.has_max_num()) {
      set_max_num(from.max_num());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
}

void UpdateGameServerInfo::CopyFrom(const UpdateGameServerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateGameServerInfo::IsInitialized() const {

  return true;
}

void UpdateGameServerInfo::Swap(UpdateGameServerInfo* other) {
  if (other != this) {
    std::swap(server_id_, other->server_id_);
    std::swap(online_num_, other->online_num_);
    std::swap(max_num_, other->max_num_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UpdateGameServerInfo::GetTypeName() const {
  return "LoginCmd.UpdateGameServerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUserEndTime::kCharidFieldNumber;
const int RequestUserEndTime::kAccountFieldNumber;
#endif  // !_MSC_VER

RequestUserEndTime::RequestUserEndTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestUserEndTime::InitAsDefaultInstance() {
}

RequestUserEndTime::RequestUserEndTime(const RequestUserEndTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestUserEndTime::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUserEndTime::~RequestUserEndTime() {
  SharedDtor();
}

void RequestUserEndTime::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUserEndTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUserEndTime& RequestUserEndTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

RequestUserEndTime* RequestUserEndTime::default_instance_ = NULL;

RequestUserEndTime* RequestUserEndTime::New() const {
  return new RequestUserEndTime;
}

void RequestUserEndTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestUserEndTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestUserEndTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->charid(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

}

int RequestUserEndTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUserEndTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUserEndTime*>(&from));
}

void RequestUserEndTime::MergeFrom(const RequestUserEndTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
  }
}

void RequestUserEndTime::CopyFrom(const RequestUserEndTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUserEndTime::IsInitialized() const {

  return true;
}

void RequestUserEndTime::Swap(RequestUserEndTime* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(account_, other->account_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUserEndTime::GetTypeName() const {
  return "LoginCmd.RequestUserEndTime";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseUserEndTime::kCharidFieldNumber;
const int ResponseUserEndTime::kAccountFieldNumber;
const int ResponseUserEndTime::kEndTimeFieldNumber;
#endif  // !_MSC_VER

ResponseUserEndTime::ResponseUserEndTime()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseUserEndTime::InitAsDefaultInstance() {
}

ResponseUserEndTime::ResponseUserEndTime(const ResponseUserEndTime& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseUserEndTime::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  end_time_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseUserEndTime::~ResponseUserEndTime() {
  SharedDtor();
}

void ResponseUserEndTime::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseUserEndTime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseUserEndTime& ResponseUserEndTime::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseUserEndTime* ResponseUserEndTime::default_instance_ = NULL;

ResponseUserEndTime* ResponseUserEndTime::New() const {
  return new ResponseUserEndTime;
}

void ResponseUserEndTime::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    end_time_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseUserEndTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_end_time;
        break;
      }

      // optional int32 end_time = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_end_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_time_)));
          set_has_end_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseUserEndTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->charid(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

  // optional int32 end_time = 3;
  if (has_end_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->end_time(), output);
  }

}

int ResponseUserEndTime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional int32 end_time = 3;
    if (has_end_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end_time());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseUserEndTime::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseUserEndTime*>(&from));
}

void ResponseUserEndTime::MergeFrom(const ResponseUserEndTime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_end_time()) {
      set_end_time(from.end_time());
    }
  }
}

void ResponseUserEndTime::CopyFrom(const ResponseUserEndTime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseUserEndTime::IsInitialized() const {

  return true;
}

void ResponseUserEndTime::Swap(ResponseUserEndTime* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(account_, other->account_);
    std::swap(end_time_, other->end_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseUserEndTime::GetTypeName() const {
  return "LoginCmd.ResponseUserEndTime";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestGetUserCashInfo::kCharidFieldNumber;
const int RequestGetUserCashInfo::kAccountFieldNumber;
#endif  // !_MSC_VER

RequestGetUserCashInfo::RequestGetUserCashInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestGetUserCashInfo::InitAsDefaultInstance() {
}

RequestGetUserCashInfo::RequestGetUserCashInfo(const RequestGetUserCashInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestGetUserCashInfo::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestGetUserCashInfo::~RequestGetUserCashInfo() {
  SharedDtor();
}

void RequestGetUserCashInfo::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestGetUserCashInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestGetUserCashInfo& RequestGetUserCashInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

RequestGetUserCashInfo* RequestGetUserCashInfo::default_instance_ = NULL;

RequestGetUserCashInfo* RequestGetUserCashInfo::New() const {
  return new RequestGetUserCashInfo;
}

void RequestGetUserCashInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestGetUserCashInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestGetUserCashInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->charid(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

}

int RequestGetUserCashInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestGetUserCashInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestGetUserCashInfo*>(&from));
}

void RequestGetUserCashInfo::MergeFrom(const RequestGetUserCashInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
  }
}

void RequestGetUserCashInfo::CopyFrom(const RequestGetUserCashInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestGetUserCashInfo::IsInitialized() const {

  return true;
}

void RequestGetUserCashInfo::Swap(RequestGetUserCashInfo* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(account_, other->account_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestGetUserCashInfo::GetTypeName() const {
  return "LoginCmd.RequestGetUserCashInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseGetUserCashInfo::kCharidFieldNumber;
const int ResponseGetUserCashInfo::kAccountFieldNumber;
const int ResponseGetUserCashInfo::kCashpointFieldNumber;
const int ResponseGetUserCashInfo::kCreditsFieldNumber;
#endif  // !_MSC_VER

ResponseGetUserCashInfo::ResponseGetUserCashInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseGetUserCashInfo::InitAsDefaultInstance() {
}

ResponseGetUserCashInfo::ResponseGetUserCashInfo(const ResponseGetUserCashInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseGetUserCashInfo::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cashpoint_ = 0;
  credits_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseGetUserCashInfo::~ResponseGetUserCashInfo() {
  SharedDtor();
}

void ResponseGetUserCashInfo::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseGetUserCashInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseGetUserCashInfo& ResponseGetUserCashInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseGetUserCashInfo* ResponseGetUserCashInfo::default_instance_ = NULL;

ResponseGetUserCashInfo* ResponseGetUserCashInfo::New() const {
  return new ResponseGetUserCashInfo;
}

void ResponseGetUserCashInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    cashpoint_ = 0;
    credits_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseGetUserCashInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_cashpoint;
        break;
      }

      // optional int32 cashpoint = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cashpoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cashpoint_)));
          set_has_cashpoint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_credits;
        break;
      }

      // optional int32 credits = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_credits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &credits_)));
          set_has_credits();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseGetUserCashInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->charid(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

  // optional int32 cashpoint = 3;
  if (has_cashpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->cashpoint(), output);
  }

  // optional int32 credits = 4;
  if (has_credits()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->credits(), output);
  }

}

int ResponseGetUserCashInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional int32 cashpoint = 3;
    if (has_cashpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cashpoint());
    }

    // optional int32 credits = 4;
    if (has_credits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->credits());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseGetUserCashInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseGetUserCashInfo*>(&from));
}

void ResponseGetUserCashInfo::MergeFrom(const ResponseGetUserCashInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_cashpoint()) {
      set_cashpoint(from.cashpoint());
    }
    if (from.has_credits()) {
      set_credits(from.credits());
    }
  }
}

void ResponseGetUserCashInfo::CopyFrom(const ResponseGetUserCashInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseGetUserCashInfo::IsInitialized() const {

  return true;
}

void ResponseGetUserCashInfo::Swap(ResponseGetUserCashInfo* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(account_, other->account_);
    std::swap(cashpoint_, other->cashpoint_);
    std::swap(credits_, other->credits_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseGetUserCashInfo::GetTypeName() const {
  return "LoginCmd.ResponseGetUserCashInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestUpdateUserCashInfo::kCharidFieldNumber;
const int RequestUpdateUserCashInfo::kAccountFieldNumber;
const int RequestUpdateUserCashInfo::kCashpointFieldNumber;
const int RequestUpdateUserCashInfo::kCreditsFieldNumber;
const int RequestUpdateUserCashInfo::kTypeFieldNumber;
#endif  // !_MSC_VER

RequestUpdateUserCashInfo::RequestUpdateUserCashInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestUpdateUserCashInfo::InitAsDefaultInstance() {
}

RequestUpdateUserCashInfo::RequestUpdateUserCashInfo(const RequestUpdateUserCashInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestUpdateUserCashInfo::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cashpoint_ = 0;
  credits_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestUpdateUserCashInfo::~RequestUpdateUserCashInfo() {
  SharedDtor();
}

void RequestUpdateUserCashInfo::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestUpdateUserCashInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestUpdateUserCashInfo& RequestUpdateUserCashInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

RequestUpdateUserCashInfo* RequestUpdateUserCashInfo::default_instance_ = NULL;

RequestUpdateUserCashInfo* RequestUpdateUserCashInfo::New() const {
  return new RequestUpdateUserCashInfo;
}

void RequestUpdateUserCashInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    cashpoint_ = 0;
    credits_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestUpdateUserCashInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_cashpoint;
        break;
      }

      // optional int32 cashpoint = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cashpoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cashpoint_)));
          set_has_cashpoint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_credits;
        break;
      }

      // optional int32 credits = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_credits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &credits_)));
          set_has_credits();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional int32 type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestUpdateUserCashInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->charid(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

  // optional int32 cashpoint = 3;
  if (has_cashpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->cashpoint(), output);
  }

  // optional int32 credits = 4;
  if (has_credits()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->credits(), output);
  }

  // optional int32 type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->type(), output);
  }

}

int RequestUpdateUserCashInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional int32 cashpoint = 3;
    if (has_cashpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cashpoint());
    }

    // optional int32 credits = 4;
    if (has_credits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->credits());
    }

    // optional int32 type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestUpdateUserCashInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestUpdateUserCashInfo*>(&from));
}

void RequestUpdateUserCashInfo::MergeFrom(const RequestUpdateUserCashInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_cashpoint()) {
      set_cashpoint(from.cashpoint());
    }
    if (from.has_credits()) {
      set_credits(from.credits());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void RequestUpdateUserCashInfo::CopyFrom(const RequestUpdateUserCashInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestUpdateUserCashInfo::IsInitialized() const {

  return true;
}

void RequestUpdateUserCashInfo::Swap(RequestUpdateUserCashInfo* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(account_, other->account_);
    std::swap(cashpoint_, other->cashpoint_);
    std::swap(credits_, other->credits_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestUpdateUserCashInfo::GetTypeName() const {
  return "LoginCmd.RequestUpdateUserCashInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseUpdateUserCashInfo::kCharidFieldNumber;
const int ResponseUpdateUserCashInfo::kAccountFieldNumber;
const int ResponseUpdateUserCashInfo::kCashpointFieldNumber;
const int ResponseUpdateUserCashInfo::kCreditsFieldNumber;
const int ResponseUpdateUserCashInfo::kTypeFieldNumber;
#endif  // !_MSC_VER

ResponseUpdateUserCashInfo::ResponseUpdateUserCashInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseUpdateUserCashInfo::InitAsDefaultInstance() {
}

ResponseUpdateUserCashInfo::ResponseUpdateUserCashInfo(const ResponseUpdateUserCashInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseUpdateUserCashInfo::SharedCtor() {
  _cached_size_ = 0;
  charid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  cashpoint_ = 0;
  credits_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseUpdateUserCashInfo::~ResponseUpdateUserCashInfo() {
  SharedDtor();
}

void ResponseUpdateUserCashInfo::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseUpdateUserCashInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseUpdateUserCashInfo& ResponseUpdateUserCashInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseUpdateUserCashInfo* ResponseUpdateUserCashInfo::default_instance_ = NULL;

ResponseUpdateUserCashInfo* ResponseUpdateUserCashInfo::New() const {
  return new ResponseUpdateUserCashInfo;
}

void ResponseUpdateUserCashInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    charid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    cashpoint_ = 0;
    credits_ = 0;
    type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseUpdateUserCashInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 charid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // optional string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_cashpoint;
        break;
      }

      // optional int32 cashpoint = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_cashpoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &cashpoint_)));
          set_has_cashpoint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_credits;
        break;
      }

      // optional int32 credits = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_credits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &credits_)));
          set_has_credits();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional int32 type = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseUpdateUserCashInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 charid = 1;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->charid(), output);
  }

  // optional string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

  // optional int32 cashpoint = 3;
  if (has_cashpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->cashpoint(), output);
  }

  // optional int32 credits = 4;
  if (has_credits()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->credits(), output);
  }

  // optional int32 type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->type(), output);
  }

}

int ResponseUpdateUserCashInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 charid = 1;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->charid());
    }

    // optional string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional int32 cashpoint = 3;
    if (has_cashpoint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->cashpoint());
    }

    // optional int32 credits = 4;
    if (has_credits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->credits());
    }

    // optional int32 type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseUpdateUserCashInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseUpdateUserCashInfo*>(&from));
}

void ResponseUpdateUserCashInfo::MergeFrom(const ResponseUpdateUserCashInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_charid()) {
      set_charid(from.charid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_cashpoint()) {
      set_cashpoint(from.cashpoint());
    }
    if (from.has_credits()) {
      set_credits(from.credits());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
  }
}

void ResponseUpdateUserCashInfo::CopyFrom(const ResponseUpdateUserCashInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseUpdateUserCashInfo::IsInitialized() const {

  return true;
}

void ResponseUpdateUserCashInfo::Swap(ResponseUpdateUserCashInfo* other) {
  if (other != this) {
    std::swap(charid_, other->charid_);
    std::swap(account_, other->account_);
    std::swap(cashpoint_, other->cashpoint_);
    std::swap(credits_, other->credits_);
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseUpdateUserCashInfo::GetTypeName() const {
  return "LoginCmd.ResponseUpdateUserCashInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestStopAccount::kAccountFieldNumber;
const int RequestStopAccount::kCharnameFieldNumber;
#endif  // !_MSC_VER

RequestStopAccount::RequestStopAccount()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestStopAccount::InitAsDefaultInstance() {
}

RequestStopAccount::RequestStopAccount(const RequestStopAccount& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestStopAccount::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestStopAccount::~RequestStopAccount() {
  SharedDtor();
}

void RequestStopAccount::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestStopAccount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestStopAccount& RequestStopAccount::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

RequestStopAccount* RequestStopAccount::default_instance_ = NULL;

RequestStopAccount* RequestStopAccount::New() const {
  return new RequestStopAccount;
}

void RequestStopAccount::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_charname()) {
      if (charname_ != &::google::protobuf::internal::kEmptyString) {
        charname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestStopAccount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_charname;
        break;
      }

      // optional string charname = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_charname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charname()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestStopAccount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  // optional string charname = 2;
  if (has_charname()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->charname(), output);
  }

}

int RequestStopAccount::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string charname = 2;
    if (has_charname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charname());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestStopAccount::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestStopAccount*>(&from));
}

void RequestStopAccount::MergeFrom(const RequestStopAccount& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_charname()) {
      set_charname(from.charname());
    }
  }
}

void RequestStopAccount::CopyFrom(const RequestStopAccount& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestStopAccount::IsInitialized() const {

  return true;
}

void RequestStopAccount::Swap(RequestStopAccount* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(charname_, other->charname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestStopAccount::GetTypeName() const {
  return "LoginCmd.RequestStopAccount";
}


// ===================================================================

#ifndef _MSC_VER
const int GameServerPing::kTimestampFieldNumber;
#endif  // !_MSC_VER

GameServerPing::GameServerPing()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void GameServerPing::InitAsDefaultInstance() {
}

GameServerPing::GameServerPing(const GameServerPing& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void GameServerPing::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GameServerPing::~GameServerPing() {
  SharedDtor();
}

void GameServerPing::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GameServerPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GameServerPing& GameServerPing::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

GameServerPing* GameServerPing::default_instance_ = NULL;

GameServerPing* GameServerPing::New() const {
  return new GameServerPing;
}

void GameServerPing::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool GameServerPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GameServerPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->timestamp(), output);
  }

}

int GameServerPing::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GameServerPing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GameServerPing*>(&from));
}

void GameServerPing::MergeFrom(const GameServerPing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void GameServerPing::CopyFrom(const GameServerPing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameServerPing::IsInitialized() const {

  return true;
}

void GameServerPing::Swap(GameServerPing* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GameServerPing::GetTypeName() const {
  return "LoginCmd.GameServerPing";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRegisterGatewayServer::kZoneidFieldNumber;
const int RequestRegisterGatewayServer::kIdFieldNumber;
const int RequestRegisterGatewayServer::kNameFieldNumber;
const int RequestRegisterGatewayServer::kIpFieldNumber;
const int RequestRegisterGatewayServer::kPortFieldNumber;
#endif  // !_MSC_VER

RequestRegisterGatewayServer::RequestRegisterGatewayServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestRegisterGatewayServer::InitAsDefaultInstance() {
}

RequestRegisterGatewayServer::RequestRegisterGatewayServer(const RequestRegisterGatewayServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestRegisterGatewayServer::SharedCtor() {
  _cached_size_ = 0;
  zoneid_ = 0;
  id_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegisterGatewayServer::~RequestRegisterGatewayServer() {
  SharedDtor();
}

void RequestRegisterGatewayServer::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRegisterGatewayServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegisterGatewayServer& RequestRegisterGatewayServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

RequestRegisterGatewayServer* RequestRegisterGatewayServer::default_instance_ = NULL;

RequestRegisterGatewayServer* RequestRegisterGatewayServer::New() const {
  return new RequestRegisterGatewayServer;
}

void RequestRegisterGatewayServer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zoneid_ = 0;
    id_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::kEmptyString) {
        ip_->clear();
      }
    }
    port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestRegisterGatewayServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zoneid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_id;
        break;
      }

      // optional int32 id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional string name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_ip;
        break;
      }

      // optional string ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_port;
        break;
      }

      // optional int32 port = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestRegisterGatewayServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 zoneid = 1;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zoneid(), output);
  }

  // optional int32 id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->id(), output);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->name(), output);
  }

  // optional string ip = 4;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->ip(), output);
  }

  // optional int32 port = 5;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->port(), output);
  }

}

int RequestRegisterGatewayServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 zoneid = 1;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zoneid());
    }

    // optional int32 id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string ip = 4;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // optional int32 port = 5;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegisterGatewayServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegisterGatewayServer*>(&from));
}

void RequestRegisterGatewayServer::MergeFrom(const RequestRegisterGatewayServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
}

void RequestRegisterGatewayServer::CopyFrom(const RequestRegisterGatewayServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegisterGatewayServer::IsInitialized() const {

  return true;
}

void RequestRegisterGatewayServer::Swap(RequestRegisterGatewayServer* other) {
  if (other != this) {
    std::swap(zoneid_, other->zoneid_);
    std::swap(id_, other->id_);
    std::swap(name_, other->name_);
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegisterGatewayServer::GetTypeName() const {
  return "LoginCmd.RequestRegisterGatewayServer";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseRegisterGatewayServer::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseRegisterGatewayServer::ResponseRegisterGatewayServer()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseRegisterGatewayServer::InitAsDefaultInstance() {
}

ResponseRegisterGatewayServer::ResponseRegisterGatewayServer(const ResponseRegisterGatewayServer& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseRegisterGatewayServer::SharedCtor() {
  _cached_size_ = 0;
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseRegisterGatewayServer::~ResponseRegisterGatewayServer() {
  SharedDtor();
}

void ResponseRegisterGatewayServer::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseRegisterGatewayServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseRegisterGatewayServer& ResponseRegisterGatewayServer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseRegisterGatewayServer* ResponseRegisterGatewayServer::default_instance_ = NULL;

ResponseRegisterGatewayServer* ResponseRegisterGatewayServer::New() const {
  return new ResponseRegisterGatewayServer;
}

void ResponseRegisterGatewayServer::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseRegisterGatewayServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 result = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseRegisterGatewayServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->result(), output);
  }

}

int ResponseRegisterGatewayServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseRegisterGatewayServer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseRegisterGatewayServer*>(&from));
}

void ResponseRegisterGatewayServer::MergeFrom(const ResponseRegisterGatewayServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseRegisterGatewayServer::CopyFrom(const ResponseRegisterGatewayServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseRegisterGatewayServer::IsInitialized() const {

  return true;
}

void ResponseRegisterGatewayServer::Swap(ResponseRegisterGatewayServer* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseRegisterGatewayServer::GetTypeName() const {
  return "LoginCmd.ResponseRegisterGatewayServer";
}


// ===================================================================

#ifndef _MSC_VER
const int RequestRegUserToGateway::kZoneidFieldNumber;
const int RequestRegUserToGateway::kGatewayidFieldNumber;
const int RequestRegUserToGateway::kAccountFieldNumber;
const int RequestRegUserToGateway::kKeyFieldNumber;
#endif  // !_MSC_VER

RequestRegUserToGateway::RequestRegUserToGateway()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RequestRegUserToGateway::InitAsDefaultInstance() {
}

RequestRegUserToGateway::RequestRegUserToGateway(const RequestRegUserToGateway& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RequestRegUserToGateway::SharedCtor() {
  _cached_size_ = 0;
  zoneid_ = 0;
  gatewayid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RequestRegUserToGateway::~RequestRegUserToGateway() {
  SharedDtor();
}

void RequestRegUserToGateway::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RequestRegUserToGateway::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RequestRegUserToGateway& RequestRegUserToGateway::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

RequestRegUserToGateway* RequestRegUserToGateway::default_instance_ = NULL;

RequestRegUserToGateway* RequestRegUserToGateway::New() const {
  return new RequestRegUserToGateway;
}

void RequestRegUserToGateway::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zoneid_ = 0;
    gatewayid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RequestRegUserToGateway::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zoneid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gatewayid;
        break;
      }

      // optional int32 gatewayid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gatewayid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gatewayid_)));
          set_has_gatewayid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_account;
        break;
      }

      // optional string account = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_key;
        break;
      }

      // optional string key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RequestRegUserToGateway::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 zoneid = 1;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zoneid(), output);
  }

  // optional int32 gatewayid = 2;
  if (has_gatewayid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->gatewayid(), output);
  }

  // optional string account = 3;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->account(), output);
  }

  // optional string key = 4;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->key(), output);
  }

}

int RequestRegUserToGateway::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 zoneid = 1;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zoneid());
    }

    // optional int32 gatewayid = 2;
    if (has_gatewayid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gatewayid());
    }

    // optional string account = 3;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string key = 4;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RequestRegUserToGateway::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RequestRegUserToGateway*>(&from));
}

void RequestRegUserToGateway::MergeFrom(const RequestRegUserToGateway& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
    if (from.has_gatewayid()) {
      set_gatewayid(from.gatewayid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
}

void RequestRegUserToGateway::CopyFrom(const RequestRegUserToGateway& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RequestRegUserToGateway::IsInitialized() const {

  return true;
}

void RequestRegUserToGateway::Swap(RequestRegUserToGateway* other) {
  if (other != this) {
    std::swap(zoneid_, other->zoneid_);
    std::swap(gatewayid_, other->gatewayid_);
    std::swap(account_, other->account_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RequestRegUserToGateway::GetTypeName() const {
  return "LoginCmd.RequestRegUserToGateway";
}


// ===================================================================

#ifndef _MSC_VER
const int ResponseRegUserToGateway::kZoneidFieldNumber;
const int ResponseRegUserToGateway::kGatewayidFieldNumber;
const int ResponseRegUserToGateway::kAccountFieldNumber;
const int ResponseRegUserToGateway::kKeyFieldNumber;
const int ResponseRegUserToGateway::kResultFieldNumber;
#endif  // !_MSC_VER

ResponseRegUserToGateway::ResponseRegUserToGateway()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ResponseRegUserToGateway::InitAsDefaultInstance() {
}

ResponseRegUserToGateway::ResponseRegUserToGateway(const ResponseRegUserToGateway& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ResponseRegUserToGateway::SharedCtor() {
  _cached_size_ = 0;
  zoneid_ = 0;
  gatewayid_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  result_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponseRegUserToGateway::~ResponseRegUserToGateway() {
  SharedDtor();
}

void ResponseRegUserToGateway::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ResponseRegUserToGateway::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponseRegUserToGateway& ResponseRegUserToGateway::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

ResponseRegUserToGateway* ResponseRegUserToGateway::default_instance_ = NULL;

ResponseRegUserToGateway* ResponseRegUserToGateway::New() const {
  return new ResponseRegUserToGateway;
}

void ResponseRegUserToGateway::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    zoneid_ = 0;
    gatewayid_ = 0;
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    result_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ResponseRegUserToGateway::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 zoneid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &zoneid_)));
          set_has_zoneid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_gatewayid;
        break;
      }

      // optional int32 gatewayid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_gatewayid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &gatewayid_)));
          set_has_gatewayid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_account;
        break;
      }

      // optional string account = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_key;
        break;
      }

      // optional string key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_result;
        break;
      }

      // optional int32 result = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &result_)));
          set_has_result();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResponseRegUserToGateway::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 zoneid = 1;
  if (has_zoneid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->zoneid(), output);
  }

  // optional int32 gatewayid = 2;
  if (has_gatewayid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->gatewayid(), output);
  }

  // optional string account = 3;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->account(), output);
  }

  // optional string key = 4;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->key(), output);
  }

  // optional int32 result = 5;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->result(), output);
  }

}

int ResponseRegUserToGateway::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 zoneid = 1;
    if (has_zoneid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->zoneid());
    }

    // optional int32 gatewayid = 2;
    if (has_gatewayid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->gatewayid());
    }

    // optional string account = 3;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string key = 4;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional int32 result = 5;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->result());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponseRegUserToGateway::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponseRegUserToGateway*>(&from));
}

void ResponseRegUserToGateway::MergeFrom(const ResponseRegUserToGateway& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_zoneid()) {
      set_zoneid(from.zoneid());
    }
    if (from.has_gatewayid()) {
      set_gatewayid(from.gatewayid());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_result()) {
      set_result(from.result());
    }
  }
}

void ResponseRegUserToGateway::CopyFrom(const ResponseRegUserToGateway& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponseRegUserToGateway::IsInitialized() const {

  return true;
}

void ResponseRegUserToGateway::Swap(ResponseRegUserToGateway* other) {
  if (other != this) {
    std::swap(zoneid_, other->zoneid_);
    std::swap(gatewayid_, other->gatewayid_);
    std::swap(account_, other->account_);
    std::swap(key_, other->key_);
    std::swap(result_, other->result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ResponseRegUserToGateway::GetTypeName() const {
  return "LoginCmd.ResponseRegUserToGateway";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyUnregLoginUser::kAccountFieldNumber;
const int NotifyUnregLoginUser::kKeyFieldNumber;
#endif  // !_MSC_VER

NotifyUnregLoginUser::NotifyUnregLoginUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyUnregLoginUser::InitAsDefaultInstance() {
}

NotifyUnregLoginUser::NotifyUnregLoginUser(const NotifyUnregLoginUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyUnregLoginUser::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyUnregLoginUser::~NotifyUnregLoginUser() {
  SharedDtor();
}

void NotifyUnregLoginUser::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyUnregLoginUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyUnregLoginUser& NotifyUnregLoginUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

NotifyUnregLoginUser* NotifyUnregLoginUser::default_instance_ = NULL;

NotifyUnregLoginUser* NotifyUnregLoginUser::New() const {
  return new NotifyUnregLoginUser;
}

void NotifyUnregLoginUser::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyUnregLoginUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyUnregLoginUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->key(), output);
  }

}

int NotifyUnregLoginUser::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyUnregLoginUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyUnregLoginUser*>(&from));
}

void NotifyUnregLoginUser::MergeFrom(const NotifyUnregLoginUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
}

void NotifyUnregLoginUser::CopyFrom(const NotifyUnregLoginUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyUnregLoginUser::IsInitialized() const {

  return true;
}

void NotifyUnregLoginUser::Swap(NotifyUnregLoginUser* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyUnregLoginUser::GetTypeName() const {
  return "LoginCmd.NotifyUnregLoginUser";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyUnregGatewayUser::kAccountFieldNumber;
const int NotifyUnregGatewayUser::kKeyFieldNumber;
#endif  // !_MSC_VER

NotifyUnregGatewayUser::NotifyUnregGatewayUser()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void NotifyUnregGatewayUser::InitAsDefaultInstance() {
}

NotifyUnregGatewayUser::NotifyUnregGatewayUser(const NotifyUnregGatewayUser& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void NotifyUnregGatewayUser::SharedCtor() {
  _cached_size_ = 0;
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyUnregGatewayUser::~NotifyUnregGatewayUser() {
  SharedDtor();
}

void NotifyUnregGatewayUser::SharedDtor() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyUnregGatewayUser::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyUnregGatewayUser& NotifyUnregGatewayUser::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

NotifyUnregGatewayUser* NotifyUnregGatewayUser::default_instance_ = NULL;

NotifyUnregGatewayUser* NotifyUnregGatewayUser::New() const {
  return new NotifyUnregGatewayUser;
}

void NotifyUnregGatewayUser::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool NotifyUnregGatewayUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string account = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NotifyUnregGatewayUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string account = 1;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->account(), output);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->key(), output);
  }

}

int NotifyUnregGatewayUser::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string account = 1;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // optional string key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyUnregGatewayUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyUnregGatewayUser*>(&from));
}

void NotifyUnregGatewayUser::MergeFrom(const NotifyUnregGatewayUser& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
  }
}

void NotifyUnregGatewayUser::CopyFrom(const NotifyUnregGatewayUser& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyUnregGatewayUser::IsInitialized() const {

  return true;
}

void NotifyUnregGatewayUser::Swap(NotifyUnregGatewayUser* other) {
  if (other != this) {
    std::swap(account_, other->account_);
    std::swap(key_, other->key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyUnregGatewayUser::GetTypeName() const {
  return "LoginCmd.NotifyUnregGatewayUser";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgGatewayServerPing::kTimestampFieldNumber;
#endif  // !_MSC_VER

MsgGatewayServerPing::MsgGatewayServerPing()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void MsgGatewayServerPing::InitAsDefaultInstance() {
}

MsgGatewayServerPing::MsgGatewayServerPing(const MsgGatewayServerPing& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void MsgGatewayServerPing::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgGatewayServerPing::~MsgGatewayServerPing() {
  SharedDtor();
}

void MsgGatewayServerPing::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgGatewayServerPing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgGatewayServerPing& MsgGatewayServerPing::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_ProtoSvrLogin_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_ProtoSvrLogin_2eproto();
#endif
  return *default_instance_;
}

MsgGatewayServerPing* MsgGatewayServerPing::default_instance_ = NULL;

MsgGatewayServerPing* MsgGatewayServerPing::New() const {
  return new MsgGatewayServerPing;
}

void MsgGatewayServerPing::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool MsgGatewayServerPing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MsgGatewayServerPing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->timestamp(), output);
  }

}

int MsgGatewayServerPing::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgGatewayServerPing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgGatewayServerPing*>(&from));
}

void MsgGatewayServerPing::MergeFrom(const MsgGatewayServerPing& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void MsgGatewayServerPing::CopyFrom(const MsgGatewayServerPing& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgGatewayServerPing::IsInitialized() const {

  return true;
}

void MsgGatewayServerPing::Swap(MsgGatewayServerPing* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgGatewayServerPing::GetTypeName() const {
  return "LoginCmd.MsgGatewayServerPing";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace LoginCmd

// @@protoc_insertion_point(global_scope)
