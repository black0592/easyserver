// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoSvrLogin.proto

#ifndef PROTOBUF_ProtoSvrLogin_2eproto__INCLUDED
#define PROTOBUF_ProtoSvrLogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ProtoSvrServerData.pb.h"
// @@protoc_insertion_point(includes)

namespace LoginCmd {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

class RequestRegisterGameServer;
class ResponseRegisterGameServer;
class UpdateGameServerInfo;
class RequestUserEndTime;
class ResponseUserEndTime;
class RequestGetUserCashInfo;
class ResponseGetUserCashInfo;
class RequestUpdateUserCashInfo;
class ResponseUpdateUserCashInfo;
class RequestStopAccount;
class GameServerPing;
class RequestRegisterGatewayServer;
class ResponseRegisterGatewayServer;
class RequestRegUserToGateway;
class ResponseRegUserToGateway;
class NotifyUnregLoginUser;
class NotifyUnregGatewayUser;
class MsgGatewayServerPing;

enum SvrGame2LoginOpCode {
  SVR_OP_GAME_TO_LOGIN_START = 50,
  SVR_OP_REGISTER_GAMESERVER = 51,
  SVR_OP_UPDATE_GAMESERVER_INFO = 52,
  SVR_OP_USER_END_TIME = 53,
  SVR_OP_GET_USER_CASH_INFO = 54,
  SVR_OP_UPDATE_USER_CASH_INFO = 55,
  SVR_OP_STOP_ACCOUNT = 56,
  SVR_OP_GAMESERVER_PING = 57,
  SVR_OP_GAME_TO_LOGIN_END = 99
};
bool SvrGame2LoginOpCode_IsValid(int value);
const SvrGame2LoginOpCode SvrGame2LoginOpCode_MIN = SVR_OP_GAME_TO_LOGIN_START;
const SvrGame2LoginOpCode SvrGame2LoginOpCode_MAX = SVR_OP_GAME_TO_LOGIN_END;
const int SvrGame2LoginOpCode_ARRAYSIZE = SvrGame2LoginOpCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SvrGame2LoginOpCode_descriptor();
inline const ::std::string& SvrGame2LoginOpCode_Name(SvrGame2LoginOpCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SvrGame2LoginOpCode_descriptor(), value);
}
inline bool SvrGame2LoginOpCode_Parse(
    const ::std::string& name, SvrGame2LoginOpCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SvrGame2LoginOpCode>(
    SvrGame2LoginOpCode_descriptor(), name, value);
}
enum SvrGateway2LoginOpCode {
  SVR_OP_GATEWAY_TO_LOGIN_START = 100,
  SVR_OP_REGISTER_GATEWAYSERVER = 101,
  SVR_OP_REG_USER_TO_GATEWAY = 102,
  SVR_OP_UNREG_LOGINUSER = 103,
  SVR_OP_UNREG_GATEWAYUSER = 104,
  SVR_OP_GATEWAY_PING_LOGIN = 105,
  SVR_OP_GATEWAY_TO_LOGIN_END = 199
};
bool SvrGateway2LoginOpCode_IsValid(int value);
const SvrGateway2LoginOpCode SvrGateway2LoginOpCode_MIN = SVR_OP_GATEWAY_TO_LOGIN_START;
const SvrGateway2LoginOpCode SvrGateway2LoginOpCode_MAX = SVR_OP_GATEWAY_TO_LOGIN_END;
const int SvrGateway2LoginOpCode_ARRAYSIZE = SvrGateway2LoginOpCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SvrGateway2LoginOpCode_descriptor();
inline const ::std::string& SvrGateway2LoginOpCode_Name(SvrGateway2LoginOpCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SvrGateway2LoginOpCode_descriptor(), value);
}
inline bool SvrGateway2LoginOpCode_Parse(
    const ::std::string& name, SvrGateway2LoginOpCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SvrGateway2LoginOpCode>(
    SvrGateway2LoginOpCode_descriptor(), name, value);
}
// ===================================================================

class RequestRegisterGameServer : public ::google::protobuf::Message {
 public:
  RequestRegisterGameServer();
  virtual ~RequestRegisterGameServer();

  RequestRegisterGameServer(const RequestRegisterGameServer& from);

  inline RequestRegisterGameServer& operator=(const RequestRegisterGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRegisterGameServer& default_instance();

  void Swap(RequestRegisterGameServer* other);

  // implements Message ----------------------------------------------

  RequestRegisterGameServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRegisterGameServer& from);
  void MergeFrom(const RequestRegisterGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 port = 3;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 3;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.RequestRegisterGameServer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static RequestRegisterGameServer* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRegisterGameServer : public ::google::protobuf::Message {
 public:
  ResponseRegisterGameServer();
  virtual ~ResponseRegisterGameServer();

  ResponseRegisterGameServer(const ResponseRegisterGameServer& from);

  inline ResponseRegisterGameServer& operator=(const ResponseRegisterGameServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRegisterGameServer& default_instance();

  void Swap(ResponseRegisterGameServer* other);

  // implements Message ----------------------------------------------

  ResponseRegisterGameServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRegisterGameServer& from);
  void MergeFrom(const ResponseRegisterGameServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.ResponseRegisterGameServer)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static ResponseRegisterGameServer* default_instance_;
};
// -------------------------------------------------------------------

class UpdateGameServerInfo : public ::google::protobuf::Message {
 public:
  UpdateGameServerInfo();
  virtual ~UpdateGameServerInfo();

  UpdateGameServerInfo(const UpdateGameServerInfo& from);

  inline UpdateGameServerInfo& operator=(const UpdateGameServerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateGameServerInfo& default_instance();

  void Swap(UpdateGameServerInfo* other);

  // implements Message ----------------------------------------------

  UpdateGameServerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateGameServerInfo& from);
  void MergeFrom(const UpdateGameServerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 server_id = 1;
  inline bool has_server_id() const;
  inline void clear_server_id();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::int32 server_id() const;
  inline void set_server_id(::google::protobuf::int32 value);

  // optional string online_num = 2;
  inline bool has_online_num() const;
  inline void clear_online_num();
  static const int kOnlineNumFieldNumber = 2;
  inline const ::std::string& online_num() const;
  inline void set_online_num(const ::std::string& value);
  inline void set_online_num(const char* value);
  inline void set_online_num(const char* value, size_t size);
  inline ::std::string* mutable_online_num();
  inline ::std::string* release_online_num();
  inline void set_allocated_online_num(::std::string* online_num);

  // optional int32 max_num = 3;
  inline bool has_max_num() const;
  inline void clear_max_num();
  static const int kMaxNumFieldNumber = 3;
  inline ::google::protobuf::int32 max_num() const;
  inline void set_max_num(::google::protobuf::int32 value);

  // optional int32 state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.UpdateGameServerInfo)
 private:
  inline void set_has_server_id();
  inline void clear_has_server_id();
  inline void set_has_online_num();
  inline void clear_has_online_num();
  inline void set_has_max_num();
  inline void clear_has_max_num();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* online_num_;
  ::google::protobuf::int32 server_id_;
  ::google::protobuf::int32 max_num_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static UpdateGameServerInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestUserEndTime : public ::google::protobuf::Message {
 public:
  RequestUserEndTime();
  virtual ~RequestUserEndTime();

  RequestUserEndTime(const RequestUserEndTime& from);

  inline RequestUserEndTime& operator=(const RequestUserEndTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUserEndTime& default_instance();

  void Swap(RequestUserEndTime* other);

  // implements Message ----------------------------------------------

  RequestUserEndTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUserEndTime& from);
  void MergeFrom(const RequestUserEndTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:LoginCmd.RequestUserEndTime)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static RequestUserEndTime* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUserEndTime : public ::google::protobuf::Message {
 public:
  ResponseUserEndTime();
  virtual ~ResponseUserEndTime();

  ResponseUserEndTime(const ResponseUserEndTime& from);

  inline ResponseUserEndTime& operator=(const ResponseUserEndTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseUserEndTime& default_instance();

  void Swap(ResponseUserEndTime* other);

  // implements Message ----------------------------------------------

  ResponseUserEndTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseUserEndTime& from);
  void MergeFrom(const ResponseUserEndTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 end_time = 3;
  inline bool has_end_time() const;
  inline void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::int32 end_time() const;
  inline void set_end_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.ResponseUserEndTime)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_end_time();
  inline void clear_has_end_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 end_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static ResponseUserEndTime* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetUserCashInfo : public ::google::protobuf::Message {
 public:
  RequestGetUserCashInfo();
  virtual ~RequestGetUserCashInfo();

  RequestGetUserCashInfo(const RequestGetUserCashInfo& from);

  inline RequestGetUserCashInfo& operator=(const RequestGetUserCashInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGetUserCashInfo& default_instance();

  void Swap(RequestGetUserCashInfo* other);

  // implements Message ----------------------------------------------

  RequestGetUserCashInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGetUserCashInfo& from);
  void MergeFrom(const RequestGetUserCashInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:LoginCmd.RequestGetUserCashInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static RequestGetUserCashInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetUserCashInfo : public ::google::protobuf::Message {
 public:
  ResponseGetUserCashInfo();
  virtual ~ResponseGetUserCashInfo();

  ResponseGetUserCashInfo(const ResponseGetUserCashInfo& from);

  inline ResponseGetUserCashInfo& operator=(const ResponseGetUserCashInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGetUserCashInfo& default_instance();

  void Swap(ResponseGetUserCashInfo* other);

  // implements Message ----------------------------------------------

  ResponseGetUserCashInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseGetUserCashInfo& from);
  void MergeFrom(const ResponseGetUserCashInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 cashpoint = 3;
  inline bool has_cashpoint() const;
  inline void clear_cashpoint();
  static const int kCashpointFieldNumber = 3;
  inline ::google::protobuf::int32 cashpoint() const;
  inline void set_cashpoint(::google::protobuf::int32 value);

  // optional int32 credits = 4;
  inline bool has_credits() const;
  inline void clear_credits();
  static const int kCreditsFieldNumber = 4;
  inline ::google::protobuf::int32 credits() const;
  inline void set_credits(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.ResponseGetUserCashInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_cashpoint();
  inline void clear_has_cashpoint();
  inline void set_has_credits();
  inline void clear_has_credits();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 cashpoint_;
  ::google::protobuf::int32 credits_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static ResponseGetUserCashInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpdateUserCashInfo : public ::google::protobuf::Message {
 public:
  RequestUpdateUserCashInfo();
  virtual ~RequestUpdateUserCashInfo();

  RequestUpdateUserCashInfo(const RequestUpdateUserCashInfo& from);

  inline RequestUpdateUserCashInfo& operator=(const RequestUpdateUserCashInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUpdateUserCashInfo& default_instance();

  void Swap(RequestUpdateUserCashInfo* other);

  // implements Message ----------------------------------------------

  RequestUpdateUserCashInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUpdateUserCashInfo& from);
  void MergeFrom(const RequestUpdateUserCashInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 cashpoint = 3;
  inline bool has_cashpoint() const;
  inline void clear_cashpoint();
  static const int kCashpointFieldNumber = 3;
  inline ::google::protobuf::int32 cashpoint() const;
  inline void set_cashpoint(::google::protobuf::int32 value);

  // optional int32 credits = 4;
  inline bool has_credits() const;
  inline void clear_credits();
  static const int kCreditsFieldNumber = 4;
  inline ::google::protobuf::int32 credits() const;
  inline void set_credits(::google::protobuf::int32 value);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.RequestUpdateUserCashInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_cashpoint();
  inline void clear_has_cashpoint();
  inline void set_has_credits();
  inline void clear_has_credits();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 cashpoint_;
  ::google::protobuf::int32 credits_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static RequestUpdateUserCashInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUpdateUserCashInfo : public ::google::protobuf::Message {
 public:
  ResponseUpdateUserCashInfo();
  virtual ~ResponseUpdateUserCashInfo();

  ResponseUpdateUserCashInfo(const ResponseUpdateUserCashInfo& from);

  inline ResponseUpdateUserCashInfo& operator=(const ResponseUpdateUserCashInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseUpdateUserCashInfo& default_instance();

  void Swap(ResponseUpdateUserCashInfo* other);

  // implements Message ----------------------------------------------

  ResponseUpdateUserCashInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseUpdateUserCashInfo& from);
  void MergeFrom(const ResponseUpdateUserCashInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::int32 charid() const;
  inline void set_charid(::google::protobuf::int32 value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional int32 cashpoint = 3;
  inline bool has_cashpoint() const;
  inline void clear_cashpoint();
  static const int kCashpointFieldNumber = 3;
  inline ::google::protobuf::int32 cashpoint() const;
  inline void set_cashpoint(::google::protobuf::int32 value);

  // optional int32 credits = 4;
  inline bool has_credits() const;
  inline void clear_credits();
  static const int kCreditsFieldNumber = 4;
  inline ::google::protobuf::int32 credits() const;
  inline void set_credits(::google::protobuf::int32 value);

  // optional int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.ResponseUpdateUserCashInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_cashpoint();
  inline void clear_has_cashpoint();
  inline void set_has_credits();
  inline void clear_has_credits();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int32 charid_;
  ::google::protobuf::int32 cashpoint_;
  ::google::protobuf::int32 credits_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static ResponseUpdateUserCashInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestStopAccount : public ::google::protobuf::Message {
 public:
  RequestStopAccount();
  virtual ~RequestStopAccount();

  RequestStopAccount(const RequestStopAccount& from);

  inline RequestStopAccount& operator=(const RequestStopAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStopAccount& default_instance();

  void Swap(RequestStopAccount* other);

  // implements Message ----------------------------------------------

  RequestStopAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestStopAccount& from);
  void MergeFrom(const RequestStopAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string charname = 2;
  inline bool has_charname() const;
  inline void clear_charname();
  static const int kCharnameFieldNumber = 2;
  inline const ::std::string& charname() const;
  inline void set_charname(const ::std::string& value);
  inline void set_charname(const char* value);
  inline void set_charname(const char* value, size_t size);
  inline ::std::string* mutable_charname();
  inline ::std::string* release_charname();
  inline void set_allocated_charname(::std::string* charname);

  // @@protoc_insertion_point(class_scope:LoginCmd.RequestStopAccount)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_charname();
  inline void clear_has_charname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* charname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static RequestStopAccount* default_instance_;
};
// -------------------------------------------------------------------

class GameServerPing : public ::google::protobuf::Message {
 public:
  GameServerPing();
  virtual ~GameServerPing();

  GameServerPing(const GameServerPing& from);

  inline GameServerPing& operator=(const GameServerPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameServerPing& default_instance();

  void Swap(GameServerPing* other);

  // implements Message ----------------------------------------------

  GameServerPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameServerPing& from);
  void MergeFrom(const GameServerPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.GameServerPing)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static GameServerPing* default_instance_;
};
// -------------------------------------------------------------------

class RequestRegisterGatewayServer : public ::google::protobuf::Message {
 public:
  RequestRegisterGatewayServer();
  virtual ~RequestRegisterGatewayServer();

  RequestRegisterGatewayServer(const RequestRegisterGatewayServer& from);

  inline RequestRegisterGatewayServer& operator=(const RequestRegisterGatewayServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRegisterGatewayServer& default_instance();

  void Swap(RequestRegisterGatewayServer* other);

  // implements Message ----------------------------------------------

  RequestRegisterGatewayServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRegisterGatewayServer& from);
  void MergeFrom(const RequestRegisterGatewayServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 zoneid = 1;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 1;
  inline ::google::protobuf::int32 zoneid() const;
  inline void set_zoneid(::google::protobuf::int32 value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional int32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.RequestRegisterGatewayServer)
 private:
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 zoneid_;
  ::google::protobuf::int32 id_;
  ::std::string* name_;
  ::std::string* ip_;
  ::google::protobuf::int32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static RequestRegisterGatewayServer* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRegisterGatewayServer : public ::google::protobuf::Message {
 public:
  ResponseRegisterGatewayServer();
  virtual ~ResponseRegisterGatewayServer();

  ResponseRegisterGatewayServer(const ResponseRegisterGatewayServer& from);

  inline ResponseRegisterGatewayServer& operator=(const ResponseRegisterGatewayServer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRegisterGatewayServer& default_instance();

  void Swap(ResponseRegisterGatewayServer* other);

  // implements Message ----------------------------------------------

  ResponseRegisterGatewayServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRegisterGatewayServer& from);
  void MergeFrom(const ResponseRegisterGatewayServer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.ResponseRegisterGatewayServer)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static ResponseRegisterGatewayServer* default_instance_;
};
// -------------------------------------------------------------------

class RequestRegUserToGateway : public ::google::protobuf::Message {
 public:
  RequestRegUserToGateway();
  virtual ~RequestRegUserToGateway();

  RequestRegUserToGateway(const RequestRegUserToGateway& from);

  inline RequestRegUserToGateway& operator=(const RequestRegUserToGateway& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRegUserToGateway& default_instance();

  void Swap(RequestRegUserToGateway* other);

  // implements Message ----------------------------------------------

  RequestRegUserToGateway* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRegUserToGateway& from);
  void MergeFrom(const RequestRegUserToGateway& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 zoneid = 1;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 1;
  inline ::google::protobuf::int32 zoneid() const;
  inline void set_zoneid(::google::protobuf::int32 value);

  // optional int32 gatewayid = 2;
  inline bool has_gatewayid() const;
  inline void clear_gatewayid();
  static const int kGatewayidFieldNumber = 2;
  inline ::google::protobuf::int32 gatewayid() const;
  inline void set_gatewayid(::google::protobuf::int32 value);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:LoginCmd.RequestRegUserToGateway)
 private:
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_gatewayid();
  inline void clear_has_gatewayid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 zoneid_;
  ::google::protobuf::int32 gatewayid_;
  ::std::string* account_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static RequestRegUserToGateway* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRegUserToGateway : public ::google::protobuf::Message {
 public:
  ResponseRegUserToGateway();
  virtual ~ResponseRegUserToGateway();

  ResponseRegUserToGateway(const ResponseRegUserToGateway& from);

  inline ResponseRegUserToGateway& operator=(const ResponseRegUserToGateway& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRegUserToGateway& default_instance();

  void Swap(ResponseRegUserToGateway* other);

  // implements Message ----------------------------------------------

  ResponseRegUserToGateway* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRegUserToGateway& from);
  void MergeFrom(const ResponseRegUserToGateway& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 zoneid = 1;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 1;
  inline ::google::protobuf::int32 zoneid() const;
  inline void set_zoneid(::google::protobuf::int32 value);

  // optional int32 gatewayid = 2;
  inline bool has_gatewayid() const;
  inline void clear_gatewayid();
  static const int kGatewayidFieldNumber = 2;
  inline ::google::protobuf::int32 gatewayid() const;
  inline void set_gatewayid(::google::protobuf::int32 value);

  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional int32 result = 5;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 5;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.ResponseRegUserToGateway)
 private:
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_gatewayid();
  inline void clear_has_gatewayid();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 zoneid_;
  ::google::protobuf::int32 gatewayid_;
  ::std::string* account_;
  ::std::string* key_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static ResponseRegUserToGateway* default_instance_;
};
// -------------------------------------------------------------------

class NotifyUnregLoginUser : public ::google::protobuf::Message {
 public:
  NotifyUnregLoginUser();
  virtual ~NotifyUnregLoginUser();

  NotifyUnregLoginUser(const NotifyUnregLoginUser& from);

  inline NotifyUnregLoginUser& operator=(const NotifyUnregLoginUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyUnregLoginUser& default_instance();

  void Swap(NotifyUnregLoginUser* other);

  // implements Message ----------------------------------------------

  NotifyUnregLoginUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyUnregLoginUser& from);
  void MergeFrom(const NotifyUnregLoginUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:LoginCmd.NotifyUnregLoginUser)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static NotifyUnregLoginUser* default_instance_;
};
// -------------------------------------------------------------------

class NotifyUnregGatewayUser : public ::google::protobuf::Message {
 public:
  NotifyUnregGatewayUser();
  virtual ~NotifyUnregGatewayUser();

  NotifyUnregGatewayUser(const NotifyUnregGatewayUser& from);

  inline NotifyUnregGatewayUser& operator=(const NotifyUnregGatewayUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NotifyUnregGatewayUser& default_instance();

  void Swap(NotifyUnregGatewayUser* other);

  // implements Message ----------------------------------------------

  NotifyUnregGatewayUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NotifyUnregGatewayUser& from);
  void MergeFrom(const NotifyUnregGatewayUser& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:LoginCmd.NotifyUnregGatewayUser)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static NotifyUnregGatewayUser* default_instance_;
};
// -------------------------------------------------------------------

class MsgGatewayServerPing : public ::google::protobuf::Message {
 public:
  MsgGatewayServerPing();
  virtual ~MsgGatewayServerPing();

  MsgGatewayServerPing(const MsgGatewayServerPing& from);

  inline MsgGatewayServerPing& operator=(const MsgGatewayServerPing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgGatewayServerPing& default_instance();

  void Swap(MsgGatewayServerPing* other);

  // implements Message ----------------------------------------------

  MsgGatewayServerPing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MsgGatewayServerPing& from);
  void MergeFrom(const MsgGatewayServerPing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LoginCmd.MsgGatewayServerPing)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_AssignDesc_ProtoSvrLogin_2eproto();
  friend void protobuf_ShutdownFile_ProtoSvrLogin_2eproto();

  void InitAsDefaultInstance();
  static MsgGatewayServerPing* default_instance_;
};
// ===================================================================


// ===================================================================

// RequestRegisterGameServer

// optional int32 id = 1;
inline bool RequestRegisterGameServer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRegisterGameServer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRegisterGameServer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRegisterGameServer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestRegisterGameServer::id() const {
  return id_;
}
inline void RequestRegisterGameServer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool RequestRegisterGameServer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRegisterGameServer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRegisterGameServer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRegisterGameServer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RequestRegisterGameServer::name() const {
  return *name_;
}
inline void RequestRegisterGameServer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestRegisterGameServer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestRegisterGameServer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRegisterGameServer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RequestRegisterGameServer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestRegisterGameServer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 3;
inline bool RequestRegisterGameServer::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRegisterGameServer::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRegisterGameServer::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRegisterGameServer::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RequestRegisterGameServer::port() const {
  return port_;
}
inline void RequestRegisterGameServer::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ResponseRegisterGameServer

// optional int32 result = 1;
inline bool ResponseRegisterGameServer::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRegisterGameServer::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRegisterGameServer::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRegisterGameServer::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseRegisterGameServer::result() const {
  return result_;
}
inline void ResponseRegisterGameServer::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// UpdateGameServerInfo

// optional int32 server_id = 1;
inline bool UpdateGameServerInfo::has_server_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateGameServerInfo::set_has_server_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateGameServerInfo::clear_has_server_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateGameServerInfo::clear_server_id() {
  server_id_ = 0;
  clear_has_server_id();
}
inline ::google::protobuf::int32 UpdateGameServerInfo::server_id() const {
  return server_id_;
}
inline void UpdateGameServerInfo::set_server_id(::google::protobuf::int32 value) {
  set_has_server_id();
  server_id_ = value;
}

// optional string online_num = 2;
inline bool UpdateGameServerInfo::has_online_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateGameServerInfo::set_has_online_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateGameServerInfo::clear_has_online_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateGameServerInfo::clear_online_num() {
  if (online_num_ != &::google::protobuf::internal::kEmptyString) {
    online_num_->clear();
  }
  clear_has_online_num();
}
inline const ::std::string& UpdateGameServerInfo::online_num() const {
  return *online_num_;
}
inline void UpdateGameServerInfo::set_online_num(const ::std::string& value) {
  set_has_online_num();
  if (online_num_ == &::google::protobuf::internal::kEmptyString) {
    online_num_ = new ::std::string;
  }
  online_num_->assign(value);
}
inline void UpdateGameServerInfo::set_online_num(const char* value) {
  set_has_online_num();
  if (online_num_ == &::google::protobuf::internal::kEmptyString) {
    online_num_ = new ::std::string;
  }
  online_num_->assign(value);
}
inline void UpdateGameServerInfo::set_online_num(const char* value, size_t size) {
  set_has_online_num();
  if (online_num_ == &::google::protobuf::internal::kEmptyString) {
    online_num_ = new ::std::string;
  }
  online_num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateGameServerInfo::mutable_online_num() {
  set_has_online_num();
  if (online_num_ == &::google::protobuf::internal::kEmptyString) {
    online_num_ = new ::std::string;
  }
  return online_num_;
}
inline ::std::string* UpdateGameServerInfo::release_online_num() {
  clear_has_online_num();
  if (online_num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = online_num_;
    online_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UpdateGameServerInfo::set_allocated_online_num(::std::string* online_num) {
  if (online_num_ != &::google::protobuf::internal::kEmptyString) {
    delete online_num_;
  }
  if (online_num) {
    set_has_online_num();
    online_num_ = online_num;
  } else {
    clear_has_online_num();
    online_num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 max_num = 3;
inline bool UpdateGameServerInfo::has_max_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateGameServerInfo::set_has_max_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateGameServerInfo::clear_has_max_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateGameServerInfo::clear_max_num() {
  max_num_ = 0;
  clear_has_max_num();
}
inline ::google::protobuf::int32 UpdateGameServerInfo::max_num() const {
  return max_num_;
}
inline void UpdateGameServerInfo::set_max_num(::google::protobuf::int32 value) {
  set_has_max_num();
  max_num_ = value;
}

// optional int32 state = 4;
inline bool UpdateGameServerInfo::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateGameServerInfo::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateGameServerInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateGameServerInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 UpdateGameServerInfo::state() const {
  return state_;
}
inline void UpdateGameServerInfo::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// RequestUserEndTime

// optional int32 charid = 1;
inline bool RequestUserEndTime::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUserEndTime::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUserEndTime::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUserEndTime::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 RequestUserEndTime::charid() const {
  return charid_;
}
inline void RequestUserEndTime::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool RequestUserEndTime::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUserEndTime::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUserEndTime::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUserEndTime::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RequestUserEndTime::account() const {
  return *account_;
}
inline void RequestUserEndTime::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestUserEndTime::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestUserEndTime::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUserEndTime::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RequestUserEndTime::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestUserEndTime::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResponseUserEndTime

// optional int32 charid = 1;
inline bool ResponseUserEndTime::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUserEndTime::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUserEndTime::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUserEndTime::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 ResponseUserEndTime::charid() const {
  return charid_;
}
inline void ResponseUserEndTime::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool ResponseUserEndTime::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseUserEndTime::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseUserEndTime::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseUserEndTime::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ResponseUserEndTime::account() const {
  return *account_;
}
inline void ResponseUserEndTime::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseUserEndTime::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseUserEndTime::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseUserEndTime::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ResponseUserEndTime::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseUserEndTime::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 end_time = 3;
inline bool ResponseUserEndTime::has_end_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseUserEndTime::set_has_end_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseUserEndTime::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseUserEndTime::clear_end_time() {
  end_time_ = 0;
  clear_has_end_time();
}
inline ::google::protobuf::int32 ResponseUserEndTime::end_time() const {
  return end_time_;
}
inline void ResponseUserEndTime::set_end_time(::google::protobuf::int32 value) {
  set_has_end_time();
  end_time_ = value;
}

// -------------------------------------------------------------------

// RequestGetUserCashInfo

// optional int32 charid = 1;
inline bool RequestGetUserCashInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetUserCashInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetUserCashInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetUserCashInfo::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 RequestGetUserCashInfo::charid() const {
  return charid_;
}
inline void RequestGetUserCashInfo::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool RequestGetUserCashInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGetUserCashInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGetUserCashInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGetUserCashInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RequestGetUserCashInfo::account() const {
  return *account_;
}
inline void RequestGetUserCashInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestGetUserCashInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestGetUserCashInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGetUserCashInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RequestGetUserCashInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestGetUserCashInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResponseGetUserCashInfo

// optional int32 charid = 1;
inline bool ResponseGetUserCashInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetUserCashInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetUserCashInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetUserCashInfo::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 ResponseGetUserCashInfo::charid() const {
  return charid_;
}
inline void ResponseGetUserCashInfo::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool ResponseGetUserCashInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGetUserCashInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGetUserCashInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGetUserCashInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ResponseGetUserCashInfo::account() const {
  return *account_;
}
inline void ResponseGetUserCashInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseGetUserCashInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseGetUserCashInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseGetUserCashInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ResponseGetUserCashInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseGetUserCashInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cashpoint = 3;
inline bool ResponseGetUserCashInfo::has_cashpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseGetUserCashInfo::set_has_cashpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseGetUserCashInfo::clear_has_cashpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseGetUserCashInfo::clear_cashpoint() {
  cashpoint_ = 0;
  clear_has_cashpoint();
}
inline ::google::protobuf::int32 ResponseGetUserCashInfo::cashpoint() const {
  return cashpoint_;
}
inline void ResponseGetUserCashInfo::set_cashpoint(::google::protobuf::int32 value) {
  set_has_cashpoint();
  cashpoint_ = value;
}

// optional int32 credits = 4;
inline bool ResponseGetUserCashInfo::has_credits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseGetUserCashInfo::set_has_credits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseGetUserCashInfo::clear_has_credits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseGetUserCashInfo::clear_credits() {
  credits_ = 0;
  clear_has_credits();
}
inline ::google::protobuf::int32 ResponseGetUserCashInfo::credits() const {
  return credits_;
}
inline void ResponseGetUserCashInfo::set_credits(::google::protobuf::int32 value) {
  set_has_credits();
  credits_ = value;
}

// -------------------------------------------------------------------

// RequestUpdateUserCashInfo

// optional int32 charid = 1;
inline bool RequestUpdateUserCashInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpdateUserCashInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpdateUserCashInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpdateUserCashInfo::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 RequestUpdateUserCashInfo::charid() const {
  return charid_;
}
inline void RequestUpdateUserCashInfo::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool RequestUpdateUserCashInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUpdateUserCashInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUpdateUserCashInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUpdateUserCashInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RequestUpdateUserCashInfo::account() const {
  return *account_;
}
inline void RequestUpdateUserCashInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestUpdateUserCashInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestUpdateUserCashInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUpdateUserCashInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RequestUpdateUserCashInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestUpdateUserCashInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cashpoint = 3;
inline bool RequestUpdateUserCashInfo::has_cashpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUpdateUserCashInfo::set_has_cashpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUpdateUserCashInfo::clear_has_cashpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUpdateUserCashInfo::clear_cashpoint() {
  cashpoint_ = 0;
  clear_has_cashpoint();
}
inline ::google::protobuf::int32 RequestUpdateUserCashInfo::cashpoint() const {
  return cashpoint_;
}
inline void RequestUpdateUserCashInfo::set_cashpoint(::google::protobuf::int32 value) {
  set_has_cashpoint();
  cashpoint_ = value;
}

// optional int32 credits = 4;
inline bool RequestUpdateUserCashInfo::has_credits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestUpdateUserCashInfo::set_has_credits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestUpdateUserCashInfo::clear_has_credits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestUpdateUserCashInfo::clear_credits() {
  credits_ = 0;
  clear_has_credits();
}
inline ::google::protobuf::int32 RequestUpdateUserCashInfo::credits() const {
  return credits_;
}
inline void RequestUpdateUserCashInfo::set_credits(::google::protobuf::int32 value) {
  set_has_credits();
  credits_ = value;
}

// optional int32 type = 5;
inline bool RequestUpdateUserCashInfo::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestUpdateUserCashInfo::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestUpdateUserCashInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestUpdateUserCashInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RequestUpdateUserCashInfo::type() const {
  return type_;
}
inline void RequestUpdateUserCashInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ResponseUpdateUserCashInfo

// optional int32 charid = 1;
inline bool ResponseUpdateUserCashInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUpdateUserCashInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUpdateUserCashInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUpdateUserCashInfo::clear_charid() {
  charid_ = 0;
  clear_has_charid();
}
inline ::google::protobuf::int32 ResponseUpdateUserCashInfo::charid() const {
  return charid_;
}
inline void ResponseUpdateUserCashInfo::set_charid(::google::protobuf::int32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string account = 2;
inline bool ResponseUpdateUserCashInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseUpdateUserCashInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseUpdateUserCashInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseUpdateUserCashInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ResponseUpdateUserCashInfo::account() const {
  return *account_;
}
inline void ResponseUpdateUserCashInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseUpdateUserCashInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseUpdateUserCashInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseUpdateUserCashInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ResponseUpdateUserCashInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseUpdateUserCashInfo::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 cashpoint = 3;
inline bool ResponseUpdateUserCashInfo::has_cashpoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseUpdateUserCashInfo::set_has_cashpoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseUpdateUserCashInfo::clear_has_cashpoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseUpdateUserCashInfo::clear_cashpoint() {
  cashpoint_ = 0;
  clear_has_cashpoint();
}
inline ::google::protobuf::int32 ResponseUpdateUserCashInfo::cashpoint() const {
  return cashpoint_;
}
inline void ResponseUpdateUserCashInfo::set_cashpoint(::google::protobuf::int32 value) {
  set_has_cashpoint();
  cashpoint_ = value;
}

// optional int32 credits = 4;
inline bool ResponseUpdateUserCashInfo::has_credits() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseUpdateUserCashInfo::set_has_credits() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseUpdateUserCashInfo::clear_has_credits() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseUpdateUserCashInfo::clear_credits() {
  credits_ = 0;
  clear_has_credits();
}
inline ::google::protobuf::int32 ResponseUpdateUserCashInfo::credits() const {
  return credits_;
}
inline void ResponseUpdateUserCashInfo::set_credits(::google::protobuf::int32 value) {
  set_has_credits();
  credits_ = value;
}

// optional int32 type = 5;
inline bool ResponseUpdateUserCashInfo::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseUpdateUserCashInfo::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseUpdateUserCashInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseUpdateUserCashInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ResponseUpdateUserCashInfo::type() const {
  return type_;
}
inline void ResponseUpdateUserCashInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// RequestStopAccount

// optional string account = 1;
inline bool RequestStopAccount::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestStopAccount::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestStopAccount::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestStopAccount::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RequestStopAccount::account() const {
  return *account_;
}
inline void RequestStopAccount::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestStopAccount::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestStopAccount::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestStopAccount::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RequestStopAccount::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestStopAccount::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string charname = 2;
inline bool RequestStopAccount::has_charname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestStopAccount::set_has_charname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestStopAccount::clear_has_charname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestStopAccount::clear_charname() {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    charname_->clear();
  }
  clear_has_charname();
}
inline const ::std::string& RequestStopAccount::charname() const {
  return *charname_;
}
inline void RequestStopAccount::set_charname(const ::std::string& value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void RequestStopAccount::set_charname(const char* value) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(value);
}
inline void RequestStopAccount::set_charname(const char* value, size_t size) {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  charname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestStopAccount::mutable_charname() {
  set_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    charname_ = new ::std::string;
  }
  return charname_;
}
inline ::std::string* RequestStopAccount::release_charname() {
  clear_has_charname();
  if (charname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charname_;
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestStopAccount::set_allocated_charname(::std::string* charname) {
  if (charname_ != &::google::protobuf::internal::kEmptyString) {
    delete charname_;
  }
  if (charname) {
    set_has_charname();
    charname_ = charname;
  } else {
    clear_has_charname();
    charname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameServerPing

// optional int32 timestamp = 1;
inline bool GameServerPing::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameServerPing::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameServerPing::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameServerPing::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 GameServerPing::timestamp() const {
  return timestamp_;
}
inline void GameServerPing::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// RequestRegisterGatewayServer

// optional int32 zoneid = 1;
inline bool RequestRegisterGatewayServer::has_zoneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRegisterGatewayServer::set_has_zoneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRegisterGatewayServer::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRegisterGatewayServer::clear_zoneid() {
  zoneid_ = 0;
  clear_has_zoneid();
}
inline ::google::protobuf::int32 RequestRegisterGatewayServer::zoneid() const {
  return zoneid_;
}
inline void RequestRegisterGatewayServer::set_zoneid(::google::protobuf::int32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// optional int32 id = 2;
inline bool RequestRegisterGatewayServer::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRegisterGatewayServer::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRegisterGatewayServer::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRegisterGatewayServer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestRegisterGatewayServer::id() const {
  return id_;
}
inline void RequestRegisterGatewayServer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool RequestRegisterGatewayServer::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRegisterGatewayServer::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRegisterGatewayServer::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRegisterGatewayServer::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RequestRegisterGatewayServer::name() const {
  return *name_;
}
inline void RequestRegisterGatewayServer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestRegisterGatewayServer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequestRegisterGatewayServer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRegisterGatewayServer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RequestRegisterGatewayServer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestRegisterGatewayServer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 4;
inline bool RequestRegisterGatewayServer::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRegisterGatewayServer::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRegisterGatewayServer::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRegisterGatewayServer::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RequestRegisterGatewayServer::ip() const {
  return *ip_;
}
inline void RequestRegisterGatewayServer::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RequestRegisterGatewayServer::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RequestRegisterGatewayServer::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRegisterGatewayServer::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RequestRegisterGatewayServer::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestRegisterGatewayServer::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 5;
inline bool RequestRegisterGatewayServer::has_port() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRegisterGatewayServer::set_has_port() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRegisterGatewayServer::clear_has_port() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRegisterGatewayServer::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 RequestRegisterGatewayServer::port() const {
  return port_;
}
inline void RequestRegisterGatewayServer::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// ResponseRegisterGatewayServer

// optional int32 result = 1;
inline bool ResponseRegisterGatewayServer::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRegisterGatewayServer::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRegisterGatewayServer::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRegisterGatewayServer::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseRegisterGatewayServer::result() const {
  return result_;
}
inline void ResponseRegisterGatewayServer::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestRegUserToGateway

// optional int32 zoneid = 1;
inline bool RequestRegUserToGateway::has_zoneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRegUserToGateway::set_has_zoneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRegUserToGateway::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRegUserToGateway::clear_zoneid() {
  zoneid_ = 0;
  clear_has_zoneid();
}
inline ::google::protobuf::int32 RequestRegUserToGateway::zoneid() const {
  return zoneid_;
}
inline void RequestRegUserToGateway::set_zoneid(::google::protobuf::int32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// optional int32 gatewayid = 2;
inline bool RequestRegUserToGateway::has_gatewayid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRegUserToGateway::set_has_gatewayid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRegUserToGateway::clear_has_gatewayid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRegUserToGateway::clear_gatewayid() {
  gatewayid_ = 0;
  clear_has_gatewayid();
}
inline ::google::protobuf::int32 RequestRegUserToGateway::gatewayid() const {
  return gatewayid_;
}
inline void RequestRegUserToGateway::set_gatewayid(::google::protobuf::int32 value) {
  set_has_gatewayid();
  gatewayid_ = value;
}

// optional string account = 3;
inline bool RequestRegUserToGateway::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRegUserToGateway::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRegUserToGateway::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRegUserToGateway::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RequestRegUserToGateway::account() const {
  return *account_;
}
inline void RequestRegUserToGateway::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestRegUserToGateway::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RequestRegUserToGateway::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRegUserToGateway::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RequestRegUserToGateway::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestRegUserToGateway::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 4;
inline bool RequestRegUserToGateway::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRegUserToGateway::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRegUserToGateway::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRegUserToGateway::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& RequestRegUserToGateway::key() const {
  return *key_;
}
inline void RequestRegUserToGateway::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RequestRegUserToGateway::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void RequestRegUserToGateway::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRegUserToGateway::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* RequestRegUserToGateway::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequestRegUserToGateway::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResponseRegUserToGateway

// optional int32 zoneid = 1;
inline bool ResponseRegUserToGateway::has_zoneid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRegUserToGateway::set_has_zoneid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRegUserToGateway::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRegUserToGateway::clear_zoneid() {
  zoneid_ = 0;
  clear_has_zoneid();
}
inline ::google::protobuf::int32 ResponseRegUserToGateway::zoneid() const {
  return zoneid_;
}
inline void ResponseRegUserToGateway::set_zoneid(::google::protobuf::int32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// optional int32 gatewayid = 2;
inline bool ResponseRegUserToGateway::has_gatewayid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseRegUserToGateway::set_has_gatewayid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseRegUserToGateway::clear_has_gatewayid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseRegUserToGateway::clear_gatewayid() {
  gatewayid_ = 0;
  clear_has_gatewayid();
}
inline ::google::protobuf::int32 ResponseRegUserToGateway::gatewayid() const {
  return gatewayid_;
}
inline void ResponseRegUserToGateway::set_gatewayid(::google::protobuf::int32 value) {
  set_has_gatewayid();
  gatewayid_ = value;
}

// optional string account = 3;
inline bool ResponseRegUserToGateway::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseRegUserToGateway::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseRegUserToGateway::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseRegUserToGateway::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ResponseRegUserToGateway::account() const {
  return *account_;
}
inline void ResponseRegUserToGateway::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseRegUserToGateway::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ResponseRegUserToGateway::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseRegUserToGateway::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ResponseRegUserToGateway::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseRegUserToGateway::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 4;
inline bool ResponseRegUserToGateway::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseRegUserToGateway::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseRegUserToGateway::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseRegUserToGateway::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ResponseRegUserToGateway::key() const {
  return *key_;
}
inline void ResponseRegUserToGateway::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ResponseRegUserToGateway::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ResponseRegUserToGateway::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseRegUserToGateway::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ResponseRegUserToGateway::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseRegUserToGateway::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 result = 5;
inline bool ResponseRegUserToGateway::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseRegUserToGateway::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseRegUserToGateway::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseRegUserToGateway::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseRegUserToGateway::result() const {
  return result_;
}
inline void ResponseRegUserToGateway::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// NotifyUnregLoginUser

// optional string account = 1;
inline bool NotifyUnregLoginUser::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyUnregLoginUser::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyUnregLoginUser::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyUnregLoginUser::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& NotifyUnregLoginUser::account() const {
  return *account_;
}
inline void NotifyUnregLoginUser::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NotifyUnregLoginUser::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NotifyUnregLoginUser::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyUnregLoginUser::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* NotifyUnregLoginUser::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyUnregLoginUser::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 2;
inline bool NotifyUnregLoginUser::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyUnregLoginUser::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyUnregLoginUser::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyUnregLoginUser::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& NotifyUnregLoginUser::key() const {
  return *key_;
}
inline void NotifyUnregLoginUser::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void NotifyUnregLoginUser::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void NotifyUnregLoginUser::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyUnregLoginUser::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* NotifyUnregLoginUser::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyUnregLoginUser::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NotifyUnregGatewayUser

// optional string account = 1;
inline bool NotifyUnregGatewayUser::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyUnregGatewayUser::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyUnregGatewayUser::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyUnregGatewayUser::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& NotifyUnregGatewayUser::account() const {
  return *account_;
}
inline void NotifyUnregGatewayUser::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NotifyUnregGatewayUser::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NotifyUnregGatewayUser::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyUnregGatewayUser::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* NotifyUnregGatewayUser::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyUnregGatewayUser::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string key = 2;
inline bool NotifyUnregGatewayUser::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyUnregGatewayUser::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyUnregGatewayUser::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyUnregGatewayUser::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& NotifyUnregGatewayUser::key() const {
  return *key_;
}
inline void NotifyUnregGatewayUser::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void NotifyUnregGatewayUser::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void NotifyUnregGatewayUser::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NotifyUnregGatewayUser::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* NotifyUnregGatewayUser::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NotifyUnregGatewayUser::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MsgGatewayServerPing

// optional int32 timestamp = 1;
inline bool MsgGatewayServerPing::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgGatewayServerPing::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgGatewayServerPing::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgGatewayServerPing::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 MsgGatewayServerPing::timestamp() const {
  return timestamp_;
}
inline void MsgGatewayServerPing::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace LoginCmd

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LoginCmd::SvrGame2LoginOpCode>() {
  return ::LoginCmd::SvrGame2LoginOpCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LoginCmd::SvrGateway2LoginOpCode>() {
  return ::LoginCmd::SvrGateway2LoginOpCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoSvrLogin_2eproto__INCLUDED
